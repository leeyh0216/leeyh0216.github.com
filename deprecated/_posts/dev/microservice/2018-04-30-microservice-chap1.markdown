---
layout: post
title:  "[MSA] 마이크로서비스 아키텍쳐 구축 Part 1"
date:   2018-04-30 21:16:00 +0900
author: leeyh0216
categories: dev microservice architecture
---

> 이 문서는 마이크로서비스 아키텍쳐 구축(샘 뉴먼, 한빛미디어)의 1장의 내용과 기타 내용을 추가하여 작성한 문서입니다.

> 개인 공부 및 기록을 목적으로 작성한 문서이며, 문서 내용 중 이상한 내용이 있다면, leeyh0216@gmail.com 으로 언제든 연락 부탁드립니다.

# 들어가며...

2016년 9월 NCSOFT에 인턴으로 들어와서 현재(2018년 4월 말)까지 데이터 수집/처리/적재(ETL) 플랫폼을 만들고 있다.

2016년 9월부터 2017년 5월까지 ETL을 위한 플랫폼을 구성하였지만, 여러 문제점을 확인하고 2017년 6월부터 기존 아키텍쳐의 문제점과 새로운 개념(MSA)를 공부해 새로운 아키텍쳐를 설계하고 구현을 진행하고 있다.

첫 플랫폼을 만들 때, 팀장님께서 각 기능들이 **개별적으로 동작하고 개별적으로 배포가 가능**한 시스템을 염두하여 만들자고 하셨다. 당시 말씀하셨던 의도를 정확히 파악하지 못해 여러 기능이 포함된 **Monolith 구조의 API 서버와 Producer, Consumer를 가진 분산 메시징 시스템(을 흉내낸) 아키텍쳐**를 만들게 되었다.

물론 지금도 위 시스템은 별다른 이슈 없이 잘 동작하고 있다. 대규모 장애(단순한 네트워크, 단일 서버 장애를 넘어선)에도 불구하고 빠르게 복구할 수 있었던 것을 생각하면 오히려 '잘 동작하고 있는 시스템을 변경하려는 것인가?' 라는 생각도 들게 한다.

하지만 늘어나는 데이터의 양과 데이터 소스를 커버하기 위해서 계속해서 새로운 서비스를 개발하여 기존 시스템과 연동해야 하는 우리팀의 특성 상, 시스템의 **확장성**이 매우 중요했고, 기존 시스템은 이러한 확장성을 만족시켜주지 못했다.(물론 다른 이유도 존재한다)

그러던 도중 팀장님이 처음에 말씀하셨던 '개벌적으로 동작하고 개별적으로 배포가 가능한' 시스템인 '마이크로서비스 아키텍쳐'를 접하게 되었고 공부를 위해 한빛미디어에서 나온 '마이크로서비스 아키텍쳐 구축'을 공부하게 되었다.

물론 이 책을 모두 읽고 현재 시스템을 구축 중인 것도 아니고, 책에 나온 모든 개념을 시스템에 적용하고 있지도 않다. 하지만 시스템을 구현하며 책에 나오는 개념을 스스로 만족시키고 필요로하고 있다는 것을 느끼고, 좀 더 자세하게 공부하고 이를 적용하기 위해 다시 한번 책을 읽고 블로그에 정리하게 되었다.

# 마이크로서비스

## 모놀리식 시스템

기존에는 Presentation Layer, Service Layer, Data Access Layer로 이루어진 **3-티어 아키텍쳐로 서비스를 구현**했다.

- Presentation Layer: 클라이언트의 요청을 수신하여 이를 Service Layer로 전달한 후, 처리 결과가 반환되면 이를 다시 클라이언트에게 전달하는 계층. Web Framework에서 Controller가 이 계층을 담당한다.

- Service Layer: Presentation Layer로부터 수신한 요청을 비즈니스 로직에 맞게 처리하여 반환하는 계층. 이 과정에서 데이터의 저장/조회/수정 등이 필요하다면 Data Access Layer까지 접근한다.

- Data Access Layer: 데이터를 영구히 저장하는 보관소(데이터베이스)에 접근하여 데이터를 조작할 수 있는 기능을 제공하는 계층이다.

Spring, Django와 같은 Web Framework에서는 각자의 컴포넌트(Spring에서의 Controller, Service / Django에서의 View, Model, Controller)와 ORM Framework를 통해 3-티어 아키텍쳐 어플리케이션을 만들 수 있도록 지원해주었다.
개발자는 이러한 프레임워크의 컴포넌트를 이용하여 자신이 필요한 기능을 포함한 1개의 Web Application을 구성하면 되었다.

시간이 지나며 여러 기능이 추가되고, 이 과정에서 다음과 같은 문제점이 발생하게 된다.

- 모듈을 수정하므로써 발생하는 **Side Effect를 찾는데 오랜 시간**이 걸린다. 회귀 테스트까지 없다면 왜 코드 수정 후 어플리케이션이 정상적으로 동작하지 않는지 찾는데에 오랜 시간이 걸릴 수 있다.
- 데이터베이스에 관련된 제약사항을 관리하기가 어려워진다. 단순한 Constraint나 Relation이 아닌 **비즈니스 영역에서의 제약사항**을 의미한다.('회원 정보 수정시에는 이메일을 발송해야한다'는 등의 제약사항)
- **새로운 라이브러리나 프레임워크를 도입하기가 어려워**진다.

물론 낮은 결합도와 높은 응집력을 가지고 추상화, 모듈화, 문서화가 잘 되어 있으며 유지보수나 기능추가 시에도 이러한 기조가 잘 유지되는 프로그램이라면 적어도 1,2번째의 문제점을 피하거나 만나는 시기를 지연시킬 수 있다.(3번째는 역시 피하기 힘들다)

하지만 오랜 시간 개발/유지보수 된 프로그램일 경우 이를 만족시키기는 매우 어렵고, 이러한 문제점을 최대한 보완하기 위해 마이크로서비스 아키텍쳐가 등장하였다.

## 마이크로서비스 아키텍쳐

### 마이크로서비스란
> 마이크로서비스는 작고 자율적으로 협업하는 서비스를 의미한다.

위 문장은 마이크로서비스를 짧고 완전하게 표현했다고 생각한다. 책에서는 다음과 같은 특징을 설명하고 있다.

- 작고, 한가지 일을 잘하는데에 주력
  - 단일 책임 원칙
  - 추상화, 모듈화
  - 2주 이내 재작성이 가능한 크기
- 자율성
  - 분리된 개체
  - 서비스의 분산
  - 서비스, API 모델링

이 책을 읽으면서 가장 많이 다시 읽고, 관련 내용들을 찾은 부분이 위 내용들이 적혀있는 페이지(P.28 ~ P.31)였다. 