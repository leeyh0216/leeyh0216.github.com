---
layout: post
title:  "[MSA] 마이크로 서비스 아키텍쳐 - 서비스 모델링"
date:   2017-06-24 21:45:00 +0900
author: leeyh0216
categories: dev architecture microservice
---

> 마이크로 서비스 아키텍쳐 구축 3장을 공부하며 작성한 글입니다.

## 무엇이 좋은 서비스를 만드는가?

### 느슨한 결합

서비스가 느슨한 결합의 형태를 취하고 있다면, 한 서비스의 변경이 다른 서비스에 미치는 영향도가 줄어들게 된다.

모놀리식 아키텍쳐에서 느슨한 결합은 객체지향적 설계를 통해 내부 구현을 감추는 캡슐화와 함수 Interface 설계를 통해 이루어진다.

마이크로 서비스 아키텍쳐에서는 공유 모델을 통하여 필요한 정보만을 공유하고, 내부 구현은 감추어져 있다는 특성을 이용하여 느슨한 결합을 달성할 수 있다.

두 아키텍쳐의 차이는 이 관점이 코드 레벨인지, 서비스 레벨인지에 따라 나누어진다고 볼 수 있다.

2명 이상의 개발자가 하나의 코드 베이스로 작업하게 되는 경우를 생각해보자.
서로의 코드가 개방되어 있기 때문에, 상대방이 작성한 클래스 내에 내가 얻고자 하는 정보가 존재한다면 해당 필드를 막무가내로 public 으로 바꾸어 사용하게 될 수 있다.
만일, 다음 빌드 때 상대 개발자가 해당 필드가 더이상 필요하지 않다고 생각하여 삭제하는 경우, 빌드는 실패하게 될 것이다.

매우 극단적인 상황을 묘사했지만, 상대방의 내부 구현을 볼 수 있다면 당연히 나의 클래스는 상대방 클래스에 의존적으로 작성될 가능성이 높아지게 되고 이는 강한 결합도를 가진 내부 구현을 가진 프로그램으로 나타나게 된다.

마이크로 서비스 아키텍쳐의 경우, 외부에 공개된 Interface(API) 만을 볼 수 있기 때문에, 내부가 어떤 방식으로 작동하는지 알 수 없다.
따라서 상대 서비스의 내부 구현이 변경되는 경우에도 Interface의 변경이 없다면 내 서비스가 받는 영향은 없다고 볼 수 있다.(결합도가 낮아진다!)

### 강한 응집력

코드 레벨에서는 '클래스'라는 단위로 연관된 행위를 묶어놓는다. 마이크로 서비스 아키텍쳐에서는 '서비스' 라는 단위로 연관된 행위를 묶어놓게 된다.

만일 연관성이 높은 기능인데도 불구하고 이를 떨어뜨려놓게 되면, 프로그램이나 서비스들이 파편화되는 상황이 발생한다.
따라서 아무리 작은 기능으로 나누더라도, 연관된 기능들은 하나의 코드나 서비스로 구현하는 것이 응집력을 높이는 길이다.

### 정리
즉, 낮은 결합도와 강한 응집력을 달성하기 위해서는 내부 구현을 밖으로 공개하지 않고 반드시 필요한 정보만을 공개하는 것이 중요하다. 또한 기능을 너무 파편화시키면 안된다.

## 경계가 있는 콘텍스트

### 감춰진 공유 모델

예를 들어 Sqoop(http://sqoop.apache.org/) 과 Hive(http://hive.apache.org/)를 이용하여 데이터를 수집하고, 사용자에게 분석을 위한 DB를 제공하는 시스템을 만든다고 가정하자.

Sqoop은 RDBMS 데이터를 수집하여 HDFS 등으로 적재할 수 있는 Apache Open Source Project이고, Hive는 HDFS에 적재 된 데이터베이스를 SQL 형식으로 조회 할 수 있는 Apache Open Source Project이다.

Sqoop이 가동되기 위해서는, 수집 대상 데이터베이스의 정보(IP, Port, DB Category, Id, Password)와 수집 대상 테이블 정보(Table Name, Query), 수집된 데이터의 적재 경로(Hadoop Directory or Local Directory) 등을 알아야 한다.

Hive가 가동되기 위해서는 데이터의 경로와 생성할 데이터베이스명, 테이블명, 데이터의 구조 등을 알아야 한다.

두 서비스를 결합하여 사용한다고 할 때, Hive 입장에서는 Sqoop 작업이 수집한 데이터를 적재한 경로, 수집한 데이터의 구조를 알아야 한다.

마이크로 서비스 아키텍쳐에서 두 서비스의 경계에서 공유되어야 하는 부분을 '공유 모델' 이라고 지칭한다.
'공유 모델'은 작은 정보만을 가지고 있어야 한다. 너무 많은 내용을 공유하게 되면 다른 서비스가 불필요한 정보들에도 의존하게 되고, 이는 강한 결합성을 가지게 되기 때문이다.

### 모듈과 서비스

서비스 설계 시에 어떤 정보를 공유해야 하는지, 어떤 정보를 공유하면 안되는지 고려하므로써 강한 결합을 초래하는 함정을 회피할 수 있다.

이러한 부분은 코드 레벨에서도 진행할 수 있다(객체지향 설계의 '캡슐화'). 코드 레벨에서 이러한 결합도를 낮추게 되면, 추후 해당 코드로 구성된 '클래스' 또는 '모듈'을 서비스로 분리하기 편해진다.

무작정 '서비스' 레벨로 분리하다 보면, 서비스 경계를 잘못 설정하여 추후 재정비에 큰 비용이 들 수 있으므로 초기에는 코드 레벨로 분리 후에 마이크로 서비스 아키텍쳐에 익숙해진 후 '서비스' 레벨로 분리할 수 있게 된다.

### 정리

성급한 '서비스'로의 분리보다는 객체 수준에서의 분리를 수행한 후, 마이크로 서비스 아키텍쳐로의 이동을 택하는 편이 좋을 것이라는 생각이 든다.

설계 후 코드 작업이 시작되면, 다시 설계를 하는 부분으로 돌아가는 것이 힘들어질 수 있으므로(물론 조직 규모가 작거나, 애자일에 대한 이해도가 높은 회사라면 말이 달라지겠지만, 대부분의 회사가 프로젝트 초반 설계를 마지막까지 그대로 가져가는 경우가 많기 때문에 이러한 상황이 발생한다고 생각한다) 코드 레벨 분리 후 프로토 타이핑을 통하여 작은 서비스로 나누는 것도 나쁘지 않다고 생각한다.
