---
layout: post
title:  "[Code Complete] Chapter3. 준비는 철저하게 : 선행조건"
date:   2017-08-05 21:00:00 +0900
author: leeyh0216
categories: dev architecture code_complete
---

> 이 문서는 Code Complete 2판 3장 준비는 철저하게:선행조건를 정리한 글입니다.

# 준비는 철저하게: 선행조건

건물을 지을 때와 마찬가지로, 프로젝트의 준비 작업은 중요하다.
프로젝트가 성공할 것이냐 아니냐의 상당 부분은 구현을 시작하기 전에 이미 결정된다(선행 조건 단계에서).

구현 작업은 프로젝트 기간 중 30~65%의 비중을 차지하는 비싼 작업이다. 선행 조건 및 준비 작업을 소홀히 해서 프로젝트 기간 동안 2~3회의 구현 작업을 하는 것은 프로젝트를 실패로 이끄는 길이다.

## 선행 조건의 중요성

개발자들은 프로젝트의 시작, 중간, 끝 단계에서 품질을 측정한다.

* 프로젝트의 마지막 단계 : 시스템 테스트를 수행하여 품질을 측정한다. 그러나 시스템 테스트는 엉뚱한 잘못을 개발하거나 잘못된 방법으로 개발되는 등의 문제점을 발견할 수 없다.
* 프로젝트의 중간 단계 : 구현 방법에 역점을 둔다.
* 프로젝트의 시작 단계 : 요구사항을 수집하고 설계하고 계획하므로써 측정한다.

만일 중간 단계(구현)에서 잘못된 요구사항이 존재하는 경우에는, 시작 단계로 돌아가 요구사항 수집과 설계를 재수행하는 것이 좋다.

선행 조건을 충족시키지 못한다면, 엉뚱한 소프트웨어를 개발하고 있을 가능성이 높다.

### 선행 조건이 최신 소프트웨어에도 적용되는가?

최근 애자일 방법론이 대두되면서, 사람들은 폭포수 개발법에서의 과다한 문서 작업과 설계를 하지 않아도 된다고 생각한다. 그렇게 생각하는 것을 넘어 준비 작업(요구사항 분석, 설계 등)을 대충하고 구현으로 넘어가는 일도 존재한다.
하지만 이는 잘못된 생각이다.

준비 작업의 가장 중요한 목표는 **위험 축소**다. 소프트웨어에서 가장 빈번히 발생하는 문제는 잘못된 요구사항 수집과 설계로 인한 엉뚱한 소프트웨어의 개발이다. 이러한 위험을 미연에 방지하기 위하여 프로젝트에는 반드시 선행 조건 작업이 들어가 있어야 한다.

### 불완전한 준비의 원인

개발자들도 선행 작업의 중요성에 대해 알고 있고, 선행 작업을 충분히 수행한다고 하지만, 실제로는 그렇지 않다(그럴 수 없다).

대부분의 프로젝트는 개발자들이 아직 접해보지 않은 기술을 사용할 가능성이 높고, 프로젝트에 대한 전문가적인 지식을 아직 가지고 있는 상태가 아니기 때문에 어떤 부분을 준비해야 할 지 알 수 없다. 또한, 선행 작업을 어떻게 수행하여야 하는지에 대한 교육을 개발자들이 받지 않기 때문에, 불완전한 준비는 발생할 수 밖에 없다.완전해 질 수밖에 없다.

## 소프트웨어 선행조건 접근 방식

소프트웨어 선행 조건의 접근 방식은 크게 **순차적인 접근 방법**과 **반복적인 접근 방법**이 있다.

순차적인 접근 방법의 예는 폭포수 방법이 있고, 반복적인 접근 방법의 예는 진화적 프로토타이핑 접근방법, 진화적 출시 등이 있다.

### 선행 조건에서 반복적인 접근 방법이 갖는 효과

위에서 말했듯, 애자일 방식을 사용하는 사람들 중 선행 조건을 그리 중점적으로 다룰 필요가 없다고 생각하여 바로 구현으로 넘어 가는 사례가 존재한다. 하지만 반복적인 접근 방법에서도 선행 조건은 중요하다. 사람들이 반복적인 방법에서 선행 조건이 중요하지 않다고 생각하는 이유는 반복 주기가 짧기 때문에 자신들이 얼마나 재구현을 많이 반복하는지 몰라서이다.

순차적인 접근 방법은 프로젝트 완료 시점에 프로젝트의 결함을 확인하기 때문에 완료 시점에서의 작업 비용이 많이 들어간다. 

반복적인 접근 방법은 반복 주기(Iteration)마다 한번씩 결함을 확인하게 된다. 반복 주기가 전체 프로젝트 기간에 비해서는 짧기 때문에, 발견되는 결함의 크기도 작고 순차적인 접근 방식에 비해 빨리 고칠 수는 있다.
하지만 선행 조건을 잘 따지지 않았을 경우에는 문제가 달라진다.

구현 단계에서의 문제점이 아닌 요구사항, 설계 단계에서의 문제는 한 반복 주기를 다시 돌아야 하기 때문이다.
이러한 반복 주기가 많아지는 경우에는 선행 조건의 분석이 잘 된 순차적인 접근방법보다 더 많은 비용을 사용하게 된다.

물론 요구사항과 설계를 처음부터 100% 기술할 수는 없지만, 적어도 필수 요구사항과 설계상 요소는 초기에 정의하는 것이 대부분 프로젝트에 도움이 된다.

저자가 추천하는 방법은 요구사항 중에서 80%를 미리 명시하고 추가적으로 기술할 시간을 할당해 둔 다음, 프로젝트를 진행하면서 가장 중요하도고 생각되는 새로운 요구사항들만 수용할 수 있도록 실제 구조 변화를 꾀하는 것이다.

### 반복적인 방법과 순차적인 방법의 선택

#### 순차적인 방법이 유리한 프로젝트
* 요구사항이 상당히 안정적일 때
* 설계가 직관적이며 이해하기 쉬울 때
* 개발 팀이 해당 응용 분야에 익숙할 때
* 프로젝트의 위험 부담이 적을 때
* 장기적인 계획이 중요할 때
* 요구사항, 설계, 코드 변경 비용이 높을 것 같을 때


#### 반복적인 방법이 유리한 프로젝트
* 요구사항을 제대로 이해할 수 없거나 변경될 가능성이 많을 때
* 설계가 복잡하거나 어려울 때
* 개발 팀이 해당 응용 분야에 대해 잘 모를 때
* 프로젝트의 위험 부담이 높을 때
* 장기적인 계획이 중요하지 않을 때
* 요구사항, 설계, 코드 변경 비용이 높지 않을 것 같을 때

저자는 반복적인 방법이 순차적인 방법보다 훨씬 유용한 경우가 많다고 저술했고 나도 이 생각에는 동의하지만, 두 방법을 적절히 섞어 운영하는 것이 가장 유리할 것이라고 판단한다.

## 문제-정의 선행 조건

문제 정의는 시스템이 해결해야 하는 문제를 명확하게 기술하는 과정이다.

문제 정의는 해결책에 대해서는 언급하지 않고 문제가 무엇인지를 정의한다.
보통 한두장 분량의 문서이며 반드시 문제점에 대해 언급해야 한다.

* 문제 정의의 좋은 예 : 생산량을 기가트론의 주문 수량에 맞출 수 없다.
* 문제 정의의 나쁜 예 : 기가트론의 주문 수량에 맞추기 위해서 자동화된 데이터 입력 시스템을 최적화해야 한다.

나쁜 예의 경우에는 이미 문제에 대한 해결책이 있기 때문에 좋은 문제 정의라고 볼 수 없다(이미 해결책이 존재하기 때문에 더 이상의 좋은 생각을 하기에는 좋지 않을 것이다)

문제 정의는 반드시 사용자의 언어로 작성해야 하며 문제는 사용자 관점에서 기술해야 한다. 모든 문제를 해결하는데 반드시 컴퓨터가 필요하지는 않기 때문에, 개발하지 않아도 될 문제까지 컴퓨터로 개발해야 하는 상황을 피할 수 있기 때문이다.

문제를 정의하는데 실패하면 잘못된 문제를 해결하는데 많은 시간을 낭비하기 때문에 정확한 문제 정의를 해야 한다.

## 요구사항 선행 조건

요구사항은 시스템이 무엇을 수행해야 하는지에 대해 상세하게 기술하고 해결책을 구현하기 위한 과정이다.

### 왜 명시적인 요구사항이 필요한가?

명시적인 요구사항은 개발자 대신 사용자가 시스템의 기능을 주도하게 되는데 도움이 된다.
요구사항은 반드시 사용자가 동의할 수 있어야 한다. 그렇지 않다면 개발 중에 개발자가 명확하지 않은 요구사항에 대해 변경할 수 있기 때문이다.
명확한 요구사항을 정의하므로써 사용자가 원하는 것이 무엇인지를 알 수 있다.

또한, 요구사항을 정확히 정의 하면 중간에 바뀔 일이 거의 없기 때문에, 변경사항을 최소화 할 수 있다(구현을 반복하는 경우가 줄어든다는 의미).

### 견고한 요구사항에 대한 미신

요구사항이 견고하면 아키텍쳐부터 설계, 코드작성, 테스트까지 순서에 따라 예상한 대로 차분하게 프로젝트를 진행할 수 있다.

하지만 견고한 요구사항은 있을 수 없다. 개발자도 프로젝트를 진행하며 프로젝트에 대해서 더 많이 이해하듯이, 고객도 프로젝트가 진행될수록 프로젝트에 대해 더 잘 이해하고 더 많은 요구사항이 발생할 수 있기 때문이다.

견고한 요구사항을 바라는 것보다 요구사항이 변경되었을 때 잘 대처하는 것이 더 중요하다.

### 구현 중에 요구사항 변경 다루기

* 구현 중에 잘못된 요구사항이 있다면, 잠시 구현을 멈추고 요구사항 정의로 돌아가라. 잘못된 방향으로 가는 것보다 확인 후에 가는 것이 더 유리하다.
* 변경 사항들을 수용하는 개발 접근 방법을 사용한다(진화적 프로토타이핑 접근방법, 진화적 출시)
* 프로젝트의 사업성을 주시한다. 좋은 기능으로 보였을지 몰라도, 나중에 보면 터무니 없는 아이디어였을 수도 있다.

### 요구사항 체크리스트

#### 구체적인 기능 요구사항
* 시스템에 들어가는 모든 입력을 명시했는가?
* 시스템에서 나오는 모든 출력을 명시했는가?
* 모든 하드웨어와 소프트웨어 인터페이스를 명시했는가?
* 데이터 교환과 오류 검사, 통신 프로토콜을 포함한 모든 외부 통신 인터페이스를 명시했는가?
* 사용자가 수행하고자 하는 모든 작업을 명시했는가?
* 각 작업에 사용되는 데이터와 작업의 결과로 얻는 데이터를 명시했는가?

#### 비기능적(품질) 요구사항
* 모든 기능에 대해 예상 응답 시간을 사용자 관점에서 명시했는가?
* 처리 시간이나 데이터 전송률, 시스템 처리량과 같이 시간을 고려해야 하는 사항을 명시했는가?
* 보안 수준을 명시했는가?
* 소프트웨어 실패로 인한 결과와 실패 시 보호해야 하는 중요한 정보, 오류 검출과 복구를 위한 방법을 포함한 안정성에 대한 대책을 명시했는가?
* 프로젝트의 성공이나 실패에 대해서 정의했는가?

## 아키텍쳐 선행 조건

소프트웨어 아키텍쳐는 소프트웨어 설계의 상위 부분에 속하며 설계 중에서 더 상세한 부분을 담은 틀이다.
아키텍쳐는 '시스템 아키텍쳐', '상위 수준 설계', '최상위 설계'라고도 불린다.

아키텍처는 시스템 전반에 적용되는 설계상의 제약 사항을 가리킨다.
아키텍처의 품질은 시스템의 개념적인 무결성을 결정하기 때문에, 아키텍처 설계 작업은 매우 중요하다.

다음은 아키텍처의 구성요소들이다.

### 프로그램 구조
* 시스템을 일반적인 말로 기술할 개요가 필요하다(수많은 구조를 포함한 그림을 매번 설명할 수는 없으니까)
* 최종 구조에 대한 대안을 고려했던 근거와 다른 대안들 대신 지금의 구조를 선택한 이유를 찾아야 한다.
  * 구조적인 대안을 기술함으로써 아키텍쳐가 현재의 시스템 구조에 대한 논리적 근거를 제공하고 각 클래스가 신중하게 고려되었음을 보여주기 위해서
* 프로그램 내의 중요한 빌딩 블록을 정의해야 한다.
  * 빌딩 블록은 프로그램 크기에 따라 클래스일 수도 있고, 여러 개의 클래스로 구성된 서브시스템일 수도 있다.
  * 빌딩 블록에는 적어도 요구사항에서 명시한 기능이 하나는 들어가야 하고, 각 빌딩 블록은 자신의 분야에 대한 책임을 가지며 다른 빌딩 블록에 대해서는 가능한 조금 알아야 한다.
  * 빌딩 블록과의 커뮤니케이션 규칙도 명확하게 정의되어야 한다.

### 주요 클래스
* 각 주요 클래스가 맡은 역할과 클래스 사이의 상호작용에 대해 정의해야 한다.
* 클래스 계층 구조와 상태 전이, 객체 지속성에 대한 설명도 포함해야 한다.
* 클래스 명시 기준은 80대 20 법칙을 따른다(시스템의 80%를 담당하는 20%의 클래스를 명시)

### 데이터 설계
* 중요한 파일과 테이블 설계를 기술해야 한다.
* 데이터베이스의 고수준 구조와 내용에 대해서 명시해야 한다.

### 비즈니스 규칙
* 아키텍쳐가 특정한 비즈니스 규칙을 따른다면 반드시 이를 규명하고 그러한 규칙들이 시스템 설계에 미친 영향을 기술해야 한다.

이러한 아키텍쳐 구성요소를 제외하고도 보안, 성능, 확장성, 상호운용성, 입력/출력, 오류처리, 장애허용 등 많은 고려사항들이 존재한다.