---
layout: post
title:  "[Code Complete] Chapter5. 구현 설계"
date:   2017-08-13 12:00:00 +0900
author: leeyh0216
categories: dev architecture code_complete
---

> 이 문서는 Code Complete 2판 5장 구현 설계를 정리한 글입니다.

# 구현 설계

설계가 실질적인 구현 작업이 아니라고 말하는 사람도 있지만, 작은 프로젝트에서는 설계를 포함한 많은 작업이 구현에 범위에 들어간다고 생각해도 된다.

일부 대형 프로젝트에서는 형식적인 아키텍쳐 작업에서 시스템 수준의 사항만 다루고 의도적으로 설계 작업의 상당 부분을 구현으로 미룬다. 이는 설계 당시에 시스템에 대한 이해나 예측이 완벽하지 않기 때문이다.

## 설계의 어려움

'소프트웽어 설계'는 **컴퓨터 소프트웨어에 대한 명세를 동작 가능한 소프트웨어로 변환하기 위한 계획에 대한 구상이나 창작, 도구**를 뜻한다. 설계는 요구사항을 코드 작성과 디버깅에 연결하는 작업이다.
훌륭한 상위 수준 설계는 여러 개의 하위 수준 설계를 무리 없이 담을 수 있는 구조를 제공한다.

### 설계는 불명확한 문제다

'불명확한 문제'란 전체 혹은 일부를 해결해야만 정의할 수 있는 문제라고 정의한다. 이 말은 문제를 명확하게 정의하려면 문제를 한 번 '해결' 해야 하며, 작동하는 솔루션을 만들기 위해서 다시 문제를 해결해야 한다는 의미를 담고 있다.
실제 문제에 직면하기 전까지는 문제의 범위가 어디까지인지를 정확하게 파악할 수 없기 때문이다.

### 설계는 엉성한 프로세스다

설계 과정에서는 잘못된 길로 들어서는 경우도 많고 실수도 많이 한다. 하지만 실수를 하는 것이 설계의 핵심이다. 설계 단계에서 실수하고 고치는 것이 똑같은 실수를 코드 작성 후에 발견하여 코드를 수정하는 것보다 비용이 적게 들기 때문이다.

또한, 설계 과정에서는 어느 정도의 설계가 충분한지 알 수 없기 때문에, 설계를 완료하는 시점은 더이상 시간이 없을 때라고 규정할 수 있다.

### 설계는 절충과 우선순위의 문제다

많은 설계 요소 간에 상충이 발생할 수 있다. 상충하는 요소들의 특징을 비교하여 요소들 사이의 균형을 맞추는 것이 설계자의 주요 업무 중 하나이다.

### 설계에는 제약이 따른다

설계의 핵심은 어느 정도는 가능성을 만들고 어느 정도는 가능성을 제한하는데 있다. 자원은 한정적이기 때문에, 설계 상에도 제약 사항이 존재할 수 밖에 없다.

### 설계는 발견적 학습 과정이다

세 사람이 같은 문제를 해결하려고 할 경우 셋 모두 목적 달성이 가능한 대안을 내놓지만, 각 대안들은 방식이 다를 것이다. 설계에는 정답이 없기 때문에, 처릭 과정이라기 보다는 발견적 학습이라고 말할 수 있다.

따라서 설계에 만능인 도구는 없다.

### 설계는 창발적이다

설계는 누군가의 머릿속에서 완전한 형태로 갑자기 솟아나오지 않는다. 설계는 설계 검토와 격식 없는 토론, 코드 작성 경험 자체, 코드 수정 경험을 통해 진화하고 발전한다.

## 핵심 설계 개념

### 복잡성 관리

#### 본질적 어려움과 비본질적 어려움

철학에서 본질적인 속성은 어떠한 사물이 그러한 사물이 되기 위해서 반드시 가져야 하는 속성이다. 비본질적 속성은 부수적이고 임의적이며 추가적이고 우연한 것으로 생각할 수 있다.

예를 들어, 자동차는 자동차가 되기 위해서 엔진, 바퀴, 문이 있어야 한다. 이는 본질적인 속성이다. 이에 반해 비본질적인 특성은 자동차의 엔진이 V8엔진이냐 다른 엔진이 장착되어 있냐와 같은 문제이다.

프로그래밍은 어떠한 문제에 대한 본질적인 속성과 비본질적인 속성을 해결하기 위해서 존재하는 것이며, 이러한 속성들이 매우 복잡하게 얽혀있기 때문에 해결이 어려운 것이다.

#### 복잡성 관리의 중요성

대부분의 실패한 프로젝트는 요구사항이나 계획 수립, 관리가 부족해서 실패한다.
만일 프로젝트가 기술적인 이유로 실패했다면, 그 원인을 복잡성 관리 부족에서 찾을 수 있다.

소프트웨어는 무슨 일이 일어나는지 아무도 모를 정도로 복잡성이 증가할 수 있다. 프로젝트에서 한 영역의 코드를 변경했을 때 다른 부분에 어떤 영향을 미치는지 완벽하게 이해하는 사람이 없을 정도라면, 더 이상 개발을 할 수 없는 지경에 이른 것이다.

소프트웨어 개발자가 전체 프로그램을 억지로 한번에 이해하는 것 보다는 한 번에 한 부분을 이해할 수 있도록 프로그램을 구현해야 한다. 한 번 생각하는 프로그램의 크기를 최소화 하는 것이다.

소프트웨어 아키텍쳐 수준에서는 시스템을 서브시스템으로 나누어 문제의 복잡성을 줄인다. 모든 소프트웨어 설계 기법의 목표는 복잡한 문제를 간단한 문제로 나누는 것이다.

### 바람직한 설계의 특징

#### 복잡성 최소화

재치있는 설계를 피한다. 대신 간단하고 이해하기 쉬운 설계를 만들어야 한다. 특정한 부분을 살펴보고 있을 때 다른 부분에 대해서도 함께 살펴봐야 한다면 잘못된 설계라고 말할 수 있다.

#### 유지보수의 편리함

유지보수가 편리하다는 것은 유지보수 개발자를 위해 고려한 설계라는 뜻이다. 유지보수 개발자를 청중이라고 생각하고 시스템을 쉽게 이해할 수 있도록 설계한다.

#### 느슨한 결합

느슨한 결합이란 프로그램의 각 부분 사이의 연결을 최소화 하도록 설계하는 것을 의미한다. 클래스 사이의 연결을 최소화 하기 위해 클래스 인터페이스에서의 추상화, 캡슐화, 정보 은닉과 같은 방법을 사용한다.

#### 확장성

확장성은 내부 구조를 해치지 않고 시스템의 기능을 개선할 수 있다는 뜻이다. 예측 가능한 변경 사항을 미리 고민하면 시스템에 입히는 충격을 최소화 할 수 있다.

#### 재사용성

현재 시스템의 일부를 다른 시스템에 사용할 수 있도록 시스템을 설계하는 것을 의미한다.

#### 높은 팬인

높은 팬인은 특정 클래스를 사용하는 클래스의 수가 많다는 것을 의미한다. 높은 팬인은 시스템이 유틸리티 클래스를 잘 활용하도록 설계되었다는 것을 의미한다.

#### 낮은 팬아웃

낮은 팬아웃은 특정 클래스가 다른 클래스를 적게 사용한다는 것을 의미한다. 한 클래스가 너무 많은 클래스를 사용하는 것은 복잡도를 증가시킨다.

### 설계 수준

1. 소프트웨어 시스템
  
  전체 시스템 수준에서 설계를 진행한다.
  
2. 서브 시스템이나 패키지로 분할

  프로그램을 주요 서브 시스템을 어떻게 나눌 것인지, 각 서브시스템이 다른 서브시스템을 어떻게 사용하게 할 것인지를 결정하는 설계 작업이다. 이 단계에서는 서로 다른 서브시스템이 어떻게 소통할 것인지에 대한 규칙을 정하는 것이 중요하다.
  
  또한, 각 서브시스템은 모든 서브시스템과 상호작용하도록 설계해서는 안된다. 하나의 서브시스템이 다른 모든 서브시스템과 상호작용한다면 복잡도가 증가하고 하나의 서비시스템을 볼 때 시스템 전체를 이해해야하는 상황이 올 수 있다.
  
  따라서 서브시스템간의 커뮤니케이션은 서로 알 필요가 있을 때만 가능하게 만든다.

  또한, 서브시스템 간의 호출이 순환 구조를 갖지 않아야 한다.
    
3. 패키지 내에서 클래스로 분할

  시스템에 필요한 모든 클래스를 구체화 하는 작업이다. 클래스의 인터페이스가 정의된다.
  
4. 클래스 내에서 데이터와 루틴으로 분할

  클래스의 비공개(private) 루틴을 상세히 설계한다.
  
  클래스의 루틴을 완전하게 정의하는 작업을 통해서 클래스의 인터페이스에 대해 더 잘 이해하게 되면 인터페이스도 그것에 만게 변경되야 하는 경우가 생긴다. 이는 3번 과정으로 돌아가서 클래스 인터페이스를 수정해야 한다는 의미이다.
  
5. 내부 루틴 설계

  각 루틴의 상세한 기능을 구현한다.
  
