---
layout: post
title:  "[TDD] 테스트 주도 개발로 배우는 객체 지향 설계와 실천 1장 정리"
date:   2017-05-29 22:00:00 +0900
author: leeyh0216
categories: tdd study
---

> 이 문서는 테스트 주도 개발로 배우는 객체 지향 설계와 실천 1장을 정리한 문서입니다..

## 테스트 주도 개발의 핵심은 무엇인가?

### 학습 과정으로서의 소프트웨어 개발

일반적으로 소프트웨어를 개발할 때 새로운 기술을 한 가지 이상 사용하게 된다.
처음에는 이 기술에 대해 잘 알지 못하고 일정은 정해져 있으므로, 기술에 대한 정확한 이해 없이 프로그램이 동작할 정도로만 구현하게 된다.
이러한 문제를 '기술 부채(Technical Debt)' 라고 한다.

제품 출시 당시에는 프로그램이 정상적으로 동작하는 것 처럼 보이지만, 추후 유지 보수 기간에 몇몇 기능을 추가하거나 버그를 수정 할 때 이전에 만들어 놓은 너저분한 코드를 정리하고,
현재 구현하려는 기능과의 호환성을 유지하기 위해 코드를 변경하거나 리팩토링 하게 된다. 이를 '기술 부채의 이자를 갚는다' 라고 표현한다.

이렇게 우리는 프로젝트를 진행하며 모르는 기술에 대해 '학습' 하고 '학습' 과정에서 얻어낸 '경험'을 다시 시스템에 적용한다.
'학습' 과정에서 얻어낸 '경험'을 다시 시스템에 적용하는 과정을 '피드백' 이라고 정의한다.

특정 기능을 개발할 때 활동 주기를 정하고, 이 활동 주기 동안 분석, 설계, 구현, 배포를 진행한다. 배포 후에 개발자는 자신이 내린 가정을 검사할 기회가 생긴다.
배포 후에는 실제 프로그램의 동작 상황을 관찰하고, 오류를 탐지하고 수정하며 활동 주기를 조절할 수 있다.
때문에, '배포' 과정 없이는 피드백이 완전해지지 않는다.

위와 같이  학습 -> 경험 -> 시스템으로의 적용(피드백) 과정을 반복하며 소프트웨어 개발이 진행된다고 볼 수 있다.

#### 지속적 통합(Continous Integration)에의 적용

고전적인 개발 방법론(like Waterfall) 에서는 개발 기간 동안 병합/배포하지 않고 개발 기간이 완료된 후에 최종적으로 병합하고 배포한 후 테스트 하는 과정을 거쳤다.
이 방법의 단점은 다음과 같다.

- 개발 기간이 끝나기 전까지 동작하는 소프트웨어의 모습을 볼 수 없다.
- 코드 병합 시에 베이스 코드와 자신의 코드가 너무 달라져 통합이 어려워지는 '통합의 지옥'을 겪을 수 있다.

위와 같은 단점을 없애기 위해 지속적 통합(Continous Integration)이라는 방법론이 나왔다.
지속적 통합에서는 기능 개발-> 테스트 -> 코드 병합 의 주기를 줄이고 반복적으로 수행하는 것이다.
이를 통해 얻게 되는 장점은 다음과 같다.

- 개발 기간 내내 동작하는 소프트웨어의 모습을 볼 수 있다.
- 코드 병합 주기가 짧아지므로, 베이스 코드와의 차이점이 줄어들어 통합에 걸리는 시간과 노력이 줄어들게 된다.

단, 지속적 통합을 수행할 때에는 '테스트'가 매우 중요하다. 지속적 통합에서의 통합 후의 결과물은 항상 '동작하는 소프트웨어' 여야 하기 때문에 테스트를 거치지 않은 코드가 병합되어
병합 후에 소프트웨어가 정상적으로 동작하지 않는 상황을 방지해야 하기 때문이다.

### 회귀 오류와 신뢰할 수 있는 시스템

회귀 오류는 이전에 제대로 동작하던 소프트웨어 기능에 문제가 생기는 것을 의미한다.
테스트가 없는 소프트웨어 개발에서 우리는 일반적으로 코드를 작성하고 이를 배포한 뒤 기능이 정상적으로 작동하는 것을 확인했을 때 기능이 완성되었다고 생각한다.
기능이 잘 동작하고 있을 무렵 우리는 버그 또는 새로운 기능 추가로 인해, 코드를 건드리게 되고 다시 배포한 프로그램에서 이전에 잘 동작하던 기능이 동작하지 않는 것을 볼 수 있다.
이를 '회귀 오류'라고 한다.

테스트가 존재하는 코드에서는 이러한 버그가 배포 당시에(물론, Jenkins와 같은 배포 툴이 있을 경우에만) 발견되지만, 테스트가 존재하지 않는 코드에서는 배포 후에 기능이 동작하기 전까지
문제를 발견할 수 없다.

때문에 우리는 기능들에 대해 테스트를 작성하고, 배포 전에 모든 기능에 대해 테스트가 통과하는지 확인해야 한다.

### TDD(Test-Driven Development, 테스트 주도 개발)

일반적으로 특정 기능을 만들 때 우리는 다음 순서에 따라 개발하게 된다.

1. 요구사항 분석 및 설계
2. 기능 구현
3. 테스트

하지만 TDD에서는 다음과 같은 순서에 따라 개발하게 된다.

1. 테스트 작성(이 과정에서 요구사항에 따라 객체의 뼈대를 만들고, 함수 등을 정의한다. 단, 함수는 동작하지 않기 때문에 모든 테스트는 실패한다)
2. 테스트가 통과하는 수준의 코드를 작성한다.
3. 작성한 코드를 리팩토링 한다(2 과정에서는 하드코딩 등이 포함되어 있을 수 있기 때문에)

테스트를 작성하면서 아래와 같은 혜택을 얻을 수 있다.

1. 코드를 통한 설계가 가능해진다. 기존의 추상적인 설계보다 함수 단위까지의 명확한 설계를 진행할 수 있다.
2. 느슨하게 결합된 구성요소를 작성할 수 있게 된다.(결합도를 낮추고, 응집도를 높인다)
3. 코드가 하는 일에 대한 설명이 가능해진다.
4. 완전한 회귀 테스트가 늘어난다.

테스트를 실행하면 다음과 같은 혜택을 얻을 수 있다.

1. 오류를 탐지할 수 있다.
2. 추상적인 설계 과정에서 발생하는 과도한 최적화나 불필요한 기능을 더하지 않게 된다.

### 단위 테스트의 함정

일반적으로 TDD를 논할 때 단위 테스트가 먼저 생각나게 된다. 물론 클래스에 대한 단위 테스트는 중요하다. 하지만 기능은 하나의 클래스만으로 동작하지 않는다. 복잡한 기능의 경우 여러 개의 클래스가 합동하여 동작하게 되는데, 단위 클래스마다 테스트를 작성하고 기능을 구현했다고 하더라도, 이를 통함하는 과정에 대한 충분한 고려가 되어 있지 않는다면 단위 테스트는 아무런 의미가 없다.

예를 들어 특정 사이트의 페이지를 파싱하여 주어진 단어를 포함하는 문장을 찾아 이를 데이터베이스에 저장하는 기능이 있다고 생각해보자.
위 기능을 수행하는데에 필요한 클래스는 크게 세 가지로 생각할 수 있다.

1. 웹 페이지를 파싱하는 클래스
2. 글에서 단어를 포함하는 문장을 뽑아내는 클래스
3. 데이터베이스에 저장하는 클래스

위 세가지 클래스의 모든 기능 작성이 완료된다 하더라도, 위 세가지 클래스를 결합하여 실제로 기능을 수행하는 클래스에 대해서는 설계가 완료되지 않았다.
때문에, 각 클래스의 기능들을 포함하여 수행하고, 정상적인 결과가 발생하는지 확인할 수 있는 '인수 테스트'의 과정도 중요하다고 생각할 수 있다.


