---
layout: post
title:  "[알고리즘] 1012 유기농배추"
date:   2018-07-16 01:24:00 +0900
author: leeyh0216
categories: algorithm acmicpc
---

> 백준 온라인저지 1012번 유기농 배추(https://www.acmicpc.net/problem/1012)

## 문제 분석

문제 내용 중 **특히, 어떤 배추에 배추흰지렁이가 한 마리라도 살고 있으면 이 지렁이는 인접한 다른 배추로 이동할 수 있어, 그 배추들 역시 해충으로부터 보호받을 수 있다.** 부분이 가장 중요하다.

특정 좌표(x,y)에 배추가 심어져 있는 경우, 지렁이는 상(x, y-1),하(x, y+1),좌(x-1, y),우(x+1, y) 네 방향으로 이동할 수 있다는 뜻이다. 또한, 이동한 방향에도 배추가 심어져 있는 경우, 해당 좌표에서도 다시 상,하,좌,우로 이동할 수 있다는 뜻이 된다.

결론적으로 재귀함수를 이용하여 풀이가 가능하다.

## 소스코드

{% highlight c++ %}
#include<stdio.h>
#define MAXLEN 50

int arr[MAXLEN][MAXLEN];

void init_arr() {
	for (int i = 0; i < MAXLEN; i++) {
		for (int j = 0; j < MAXLEN; j++) {
			arr[i][j] = 0;
		}
	}
}

int testcase = 0;
int x = 0, y = 0;

void remove(int _x, int _y) {
	if (_x < 0 || x <= _x || _y < 0 || y <= _y)
		return;
	else {
		if (arr[_x][_y] == 0) 
			return;
		else {
			arr[_x][_y] = 0;
			remove(_x - 1, _y);
			remove(_x, _y - 1);
			remove(_x + 1, _y);
			remove(_x, _y + 1);
		}
	}
}
int main(void) {
	scanf("%d", &testcase);

	for (int t = 0; t < testcase; t++) {
		init_arr();
		int k = 0;
		scanf("%d %d %d", &x, &y, &k);
		
		for (int _k = 0; _k < k; _k++) {
			int tmp_x = 0, tmp_y = 0;
			scanf("%d %d", &tmp_x, &tmp_y);
			arr[tmp_x][tmp_y] = 1;
		}

		int c = 0;
		for (int _x = 0; _x < x; _x++) {
			for (int _y = 0; _y < y; _y++) {
				if (arr[_x][_y] == 1) {
					c++;
					remove(_x, _y);
				}
			}
		}
		printf("%d\n", c);
	}
}
{% endhighlight %}

## 소스코드 분석

1. 땅 모양 배열 생성

문제 입력에 가로, 세로 길이의 최대 값이 50으로 지정되어 있으므로, 50*50 배열(arr)을 선언해준다.

2. 배열 초기화 함수(init_arr)

매 테스트케이스마다 모든 땅에 배추가 심어져있지 않는 상태로 마킹하는 init_arr 함수를 선언해준다.

3. 배추 추적 함수(remove)

특정 좌표를 입력받아, 해당 좌표에 배추가 있는 경우(해당 좌표 배열 값이 1인 경우) 0으로 마킹하고, 상,하,좌,우에 대해 동일한 함수를 호출하여 인접한 땅의 배추도 추적한다.

4. 메인 함수

입력받은 x,y 값을 이용하여 2중 for문을 순회한다.
순회 중 해당 좌표에 배추가 있는 경우, 지렁이 수(cnt)를 1 증가시키고, 인접 배추를 추적, 제거하기 위해 remove 함수를 호출한다.

## 총평

거의 2년만에 풀어본 알고리즘 문제였고, scanf <-> scanf_s 문제 때문에 제출 과정에서 3번이나 컴파일 에러를 발생시켰다.
c++도 너무 오랫만에 사용해서 어색하고, 오랫만에 재귀함수를 작성해봐서 기저 사례를 다 채웠는지 긴가민가 했지만 결과적으로 정답을 맞추게 되었다.

앞으로는 일주일에 적어도 3문제는 꼬박꼬박 풀어서 감을 잃지 않아야겠다는 생각이 든다.