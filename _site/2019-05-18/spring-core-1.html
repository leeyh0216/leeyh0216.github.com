<!DOCTYPE html>
<html lang="en">

  <head>
  
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Spring IoC Container - Container, Bean overview | DevLog</title>
<meta name="generator" content="Jekyll v3.8.6" />
<meta property="og:title" content="Spring IoC Container - Container, Bean overview" />
<meta name="author" content="leeyh0216" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="The IoC Container Introduction to the Spring IoC Container and Beans Inversion of Control(IoC, 제어의 역전)은 Dependency Injection(DI, 의존성 주입)로도 알려져 있다. 객체는 자신이 동작하는데에 필요한 의존성(객체)을 생성자 팩토리 메서드의 인자 Setter 를 통해 설정할 수 있도록 한다. Container는 객체를 생성할 때 의존성들을 위에서 정의한 방법으로 주입해준다. 객체가 자신의 초기화나 의존성의 설정을 스스로 하는 것이 아니라 Container에 위임하는 방식이기 때문에 제어의 역전이라고 불리우는 것이다. org.springframework.beans와 org.springframework.context 패키지가 Spring Framework의 IoC Container의 기반을 제공한다. 이 중 BeanFactory 인터페이스는 객체를 관리하는 매커니즘을 제공하고, ApplicationContext는 BeanFactory 를 상속받은 하위 인터페이스로써, AOP Message Resource Handling Event Publication WebApplicationContext와 같은 Application-Layer Specific Context 등의 엔터프라이즈 기능을 추가적으로 제공한다. Spring에서 Application을 구성하는 객체들은 Spring IoC Container에 의해 관리되며, Bean이라고 불린다. Bean은 Spring IoC Container에 의해 초기화, 조합, 관리된다. 또한 Bean과 Bean을 구성하는 의존성들은 Container에게는 Configuration metadata로 표현된다. Container Overview org.springframework.context.ApplicationContext는 Spring IoC Container를 대표하는 인터페이스로써 앞에서 언급한 Bean의 생성, 구성, 조합을 담당한다. Container는 어떤 객체를 초기화하고 구성하고 조합할지를 Congiruation metadata를 사용해서 수행한다. Configuration metadata는 XML, Java Annotations, Java Code 등의 다양한 포맷으로 존재한다. XML 방식이 전통적인 Congiruation metadata 표현 방식이지만, Java Annotations나 Java Code로도 Configuration metadata를 표현할 수 있다. Spring Boot Application을 공부하려는 목적이 크기 때문에, XML이나 Application Context를 직접 초기화하는 방법은 시도하지 않은 예정이다. Bean Overview Container는 Bean을 관리할 때 BeanDefinition이라는 객체를 이용하여 관리한다. BeanDefinition 안에는 다음과 같은 속성들이 있다. package-qualified class name: Bean을 정의할 실제 구현 클래스 Container에서의 Bean의 동작 상태(scope, lifecycle callbacks 등) Bean이 동작하는데 필요한 다른 Bean(collaborators 나 dependencies로 불림) @Component로 생성된 Bean의 Bean Definition “HelloWorld!!” 를 출력하는 서비스를 아래와 같이 인터페이스와 구현 클래스를 만들었다. IHelloService.class package com.leeyh0216.springframeworkstudy.beandefinition; public interface IHelloService { void printHelloWorld(); } HelloServiceImpl.class package com.leeyh0216.springframeworkstudy.beandefinition; import org.springframework.stereotype.Component; @Component(&quot;HelloService&quot;) public class HelloServiceImpl implements IHelloService{ @Override public void printHelloWorld() { System.out.println(&quot;Hello World!!&quot;); } } 그리고 위에서 정의된 HelloServiceImpl Bean을 스캔할 수 있도록 Configuration 클래스를 아래와 같이 생성하였다. ApplicationConfiguration.class package com.leeyh0216.springframeworkstudy.beandefinition; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; @Configuration @ComponentScan(&quot;com.leeyh0216.springframeworkstudy.beandefinition&quot;) public class ApplicationConfiguration { } 아래와 같이 메인 함수를 작성하여 실행시켜보면 package com.leeyh0216.springframeworkstudy.beandefinition; import org.springframework.beans.factory.config.BeanDefinition; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args){ AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(ApplicationConfiguration.class); BeanDefinition beanDefinition = applicationContext.getBeanDefinition(&quot;HelloService&quot;); System.out.println(&quot;Bean class name: &quot; + beanDefinition.getBeanClassName()); System.out.println(&quot;Bean Scope: &quot; + beanDefinition.getScope()); System.out.println(&quot;Bean constructor argument values: &quot; + beanDefinition.getConstructorArgumentValues()); System.out.println(&quot;Bean depends on &quot; + beanDefinition.getDependsOn()); System.out.println(&quot;Is lazy init bean? &quot; + beanDefinition.isLazyInit()); System.out.println(&quot;Has bean property values? &quot; + beanDefinition.hasPropertyValues()); } } 다음과 같은 출력이 발생한다. Bean class name: com.leeyh0216.springframeworkstudy.beandefinition.HelloServiceImpl Bean Scope: singleton Bean constructor argument values: org.springframework.beans.factory.config.ConstructorArgumentValues@cb Bean depends on null Is lazy init bean? false Has bean property values? false 대부분의 정보가 정상적으로 출력되는 것을 알 수 있다. Factory 메소드로 생성된 Bean의 Bean Definition 위의 예제를 약간 수정하여 Factory Method로 Bean을 생성하도록 하였다. HelloServiceImpl.class package com.leeyh0216.springframeworkstudy.beandefinition; public class HelloServiceImpl implements IHelloService{ @Override public void printHelloWorld() { System.out.println(&quot;Hello World!!&quot;); } } HelloServiceImpl 클래스의 경우 @Component 어노테이션을 없애서 자동으로 Bean으로 생성되는 것을 방지하였다. ApplicationConfiguration.class package com.leeyh0216.springframeworkstudy.beandefinition; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; @Configuration @ComponentScan(&quot;com.leeyh0216.springframeworkstudy.beandefinition&quot;) public class ApplicationConfiguration { @Bean(&quot;HelloService&quot;) public IHelloService getIHelloService(){ return new HelloServiceImpl(); } } ApplicationConfiguration.class에서는 IHelloService Bean을 생성할 수 있는 Factory Method를 만들었다. 위 변경된 사항으로 다시 메인 함수를 실행했을 경우 아래와 같은 출력이 발생하는 것을 알 수 있다. Bean class name: null Bean Scope: Bean constructor argument values: org.springframework.beans.factory.config.ConstructorArgumentValues@cb Bean depends on null Is lazy init bean? false Has bean property values? false Factory Method로 생성한 Bean 정보의 행방 Factory Method로 생성한 Bean의 경우 기본 정보(Bean의 클래스명, Scope)가 null로 표기된다. 이러한 정보들은 어디에 있을까? Breakpoint를 잡아 BeanDefinition 객체를 확인해 보았다. beanDefinition 객체의 factoryMethodMetadata 내부에 어느정도 Bean Definition에 관련된 내용을 확인할 수 있는 것을 알 수 있다. 다만, Scope 등의 정보는 여기에도 없다. 하지만 Scope를 설정해주지 않고도 정상 동작하는 것과, 여러 번의 객체 생성을 시도하여도 동일 객체가 반환되는 것을 보면 역시 기본 Scope인 Singleton으로 동작하는 것을 확인할 수 있었다. 다만 @Component, @Service 등의 어노테이션을 붙여 Bean으로 만든 경우에는 아래와 같이 BeanDefinition에 설정한 정보들이 정상적으로 들어있는 것을 알 수 있다. Naming Beans 모든 Bean들은 1개 이상의 식별자를 가진다. Container가 Bean들을 관리하기 위해서는 이 식별자가 유일해야 한다. @Component 어노테이션을 확인해보면 다음과 같이 value가 이름을 나타내는 것을 볼 수 있다. /** * The value may indicate a suggestion for a logical component name, * to be turned into a Spring bean in case of an autodetected component. * @return the suggested component name, if any (or empty String otherwise) */ String value() default &quot;&quot;; 아래와 같은 예제를 작성해 보았다. ISimpleService.class package com.leeyh0216.springframeworkstudy.namingbeans; public interface ISimpleService { void printVersion(); } SimpleServiceImplV1.class package com.leeyh0216.springframeworkstudy.namingbeans; import org.springframework.stereotype.Component; @Component public class SimpleServiceImplV1 implements ISimpleService { @Override public void printVersion() { System.out.println(&quot;V1&quot;); } } SimpleServiceImplV2.class package com.leeyh0216.springframeworkstudy.namingbeans; import org.springframework.stereotype.Component; @Component(&quot;SimpleServiceImpl&quot;) public class SimpleServiceImplV2 implements ISimpleService{ @Override public void printVersion() { System.out.println(&quot;V2&quot;); } } SimpleServiceImplV3.class package com.leeyh0216.springframeworkstudy.namingbeans; public class SimpleServiceImplV3 implements ISimpleService { @Override public void printVersion() { System.out.println(&quot;V3&quot;); } } ApplicationConfiguration.class package com.leeyh0216.springframeworkstudy.namingbeans; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; @Configuration @ComponentScan(&quot;com.leeyh0216.springframeworkstudy.namingbeans&quot;) public class ApplicationConfiguration { @Bean(name={&quot;NewSimpleService&quot;,&quot;SimpleServiceV3&quot;}) public SimpleServiceImplV3 getSimpleServiceImplV3(){ return new SimpleServiceImplV3(); } } Application.class package com.leeyh0216.springframeworkstudy.namingbeans; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args){ AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(ApplicationConfiguration.class); ISimpleService b1 = applicationContext.getBean(&quot;simpleServiceImplV1&quot;, SimpleServiceImplV1.class); b1.printVersion(); ISimpleService b2 = applicationContext.getBean(&quot;SimpleServiceImpl&quot;, SimpleServiceImplV2.class); b2.printVersion(); ISimpleService b3_1 = applicationContext.getBean(&quot;NewSimpleService&quot;, SimpleServiceImplV3.class); b3_1.printVersion(); ISimpleService b3_2 = applicationContext.getBean(&quot;SimpleServiceV3&quot;, SimpleServiceImplV3.class); b3_2.printVersion(); } } SimpleServiceImplV1 클래스와 같이 이름을 지정하지 않은 경우 클래스명의 첫번째 문자를 소문자로 변경하고, Camel Case화 시켜서 이름으로 간주한다. SimpleServiceImplV2 클래스와 같이 이름을 명시적으로 지정하는 경우, 해당 이름을 사용하여 Bean을 찾을 수 있다. SimpleServiceImplV3 클래스의 경우 다른 클래스와 달리 팩토리 메서드로 생성했으며, @Bean 어노테이션이 사용되었다. @Bean 어노테이션의 경우 1개 이상의 이름을 지정할 수 있도록 되어 있다. 때문에 NewSimpleService, SimpleServiceV3 등으로 Bean을 접근하여도 동일한 Bean이 반환되는 것을 확인할 수 있다. @Bean 어노테이션의 name이 아래와 같이 지정되어 있기 때문에 1개 이상의 식별자를 사용할 수 있는 것으로 보인다. /** * The name of this bean, or if several names, a primary bean name plus aliases. * &lt;p&gt;If left unspecified, the name of the bean is the name of the annotated method. * If specified, the method name is ignored. * &lt;p&gt;The bean name and aliases may also be configured via the {@link #value} * attribute if no other attributes are declared. * @see #value */ @AliasFor(&quot;value&quot;) String[] name() default {};" />
<meta property="og:description" content="The IoC Container Introduction to the Spring IoC Container and Beans Inversion of Control(IoC, 제어의 역전)은 Dependency Injection(DI, 의존성 주입)로도 알려져 있다. 객체는 자신이 동작하는데에 필요한 의존성(객체)을 생성자 팩토리 메서드의 인자 Setter 를 통해 설정할 수 있도록 한다. Container는 객체를 생성할 때 의존성들을 위에서 정의한 방법으로 주입해준다. 객체가 자신의 초기화나 의존성의 설정을 스스로 하는 것이 아니라 Container에 위임하는 방식이기 때문에 제어의 역전이라고 불리우는 것이다. org.springframework.beans와 org.springframework.context 패키지가 Spring Framework의 IoC Container의 기반을 제공한다. 이 중 BeanFactory 인터페이스는 객체를 관리하는 매커니즘을 제공하고, ApplicationContext는 BeanFactory 를 상속받은 하위 인터페이스로써, AOP Message Resource Handling Event Publication WebApplicationContext와 같은 Application-Layer Specific Context 등의 엔터프라이즈 기능을 추가적으로 제공한다. Spring에서 Application을 구성하는 객체들은 Spring IoC Container에 의해 관리되며, Bean이라고 불린다. Bean은 Spring IoC Container에 의해 초기화, 조합, 관리된다. 또한 Bean과 Bean을 구성하는 의존성들은 Container에게는 Configuration metadata로 표현된다. Container Overview org.springframework.context.ApplicationContext는 Spring IoC Container를 대표하는 인터페이스로써 앞에서 언급한 Bean의 생성, 구성, 조합을 담당한다. Container는 어떤 객체를 초기화하고 구성하고 조합할지를 Congiruation metadata를 사용해서 수행한다. Configuration metadata는 XML, Java Annotations, Java Code 등의 다양한 포맷으로 존재한다. XML 방식이 전통적인 Congiruation metadata 표현 방식이지만, Java Annotations나 Java Code로도 Configuration metadata를 표현할 수 있다. Spring Boot Application을 공부하려는 목적이 크기 때문에, XML이나 Application Context를 직접 초기화하는 방법은 시도하지 않은 예정이다. Bean Overview Container는 Bean을 관리할 때 BeanDefinition이라는 객체를 이용하여 관리한다. BeanDefinition 안에는 다음과 같은 속성들이 있다. package-qualified class name: Bean을 정의할 실제 구현 클래스 Container에서의 Bean의 동작 상태(scope, lifecycle callbacks 등) Bean이 동작하는데 필요한 다른 Bean(collaborators 나 dependencies로 불림) @Component로 생성된 Bean의 Bean Definition “HelloWorld!!” 를 출력하는 서비스를 아래와 같이 인터페이스와 구현 클래스를 만들었다. IHelloService.class package com.leeyh0216.springframeworkstudy.beandefinition; public interface IHelloService { void printHelloWorld(); } HelloServiceImpl.class package com.leeyh0216.springframeworkstudy.beandefinition; import org.springframework.stereotype.Component; @Component(&quot;HelloService&quot;) public class HelloServiceImpl implements IHelloService{ @Override public void printHelloWorld() { System.out.println(&quot;Hello World!!&quot;); } } 그리고 위에서 정의된 HelloServiceImpl Bean을 스캔할 수 있도록 Configuration 클래스를 아래와 같이 생성하였다. ApplicationConfiguration.class package com.leeyh0216.springframeworkstudy.beandefinition; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; @Configuration @ComponentScan(&quot;com.leeyh0216.springframeworkstudy.beandefinition&quot;) public class ApplicationConfiguration { } 아래와 같이 메인 함수를 작성하여 실행시켜보면 package com.leeyh0216.springframeworkstudy.beandefinition; import org.springframework.beans.factory.config.BeanDefinition; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args){ AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(ApplicationConfiguration.class); BeanDefinition beanDefinition = applicationContext.getBeanDefinition(&quot;HelloService&quot;); System.out.println(&quot;Bean class name: &quot; + beanDefinition.getBeanClassName()); System.out.println(&quot;Bean Scope: &quot; + beanDefinition.getScope()); System.out.println(&quot;Bean constructor argument values: &quot; + beanDefinition.getConstructorArgumentValues()); System.out.println(&quot;Bean depends on &quot; + beanDefinition.getDependsOn()); System.out.println(&quot;Is lazy init bean? &quot; + beanDefinition.isLazyInit()); System.out.println(&quot;Has bean property values? &quot; + beanDefinition.hasPropertyValues()); } } 다음과 같은 출력이 발생한다. Bean class name: com.leeyh0216.springframeworkstudy.beandefinition.HelloServiceImpl Bean Scope: singleton Bean constructor argument values: org.springframework.beans.factory.config.ConstructorArgumentValues@cb Bean depends on null Is lazy init bean? false Has bean property values? false 대부분의 정보가 정상적으로 출력되는 것을 알 수 있다. Factory 메소드로 생성된 Bean의 Bean Definition 위의 예제를 약간 수정하여 Factory Method로 Bean을 생성하도록 하였다. HelloServiceImpl.class package com.leeyh0216.springframeworkstudy.beandefinition; public class HelloServiceImpl implements IHelloService{ @Override public void printHelloWorld() { System.out.println(&quot;Hello World!!&quot;); } } HelloServiceImpl 클래스의 경우 @Component 어노테이션을 없애서 자동으로 Bean으로 생성되는 것을 방지하였다. ApplicationConfiguration.class package com.leeyh0216.springframeworkstudy.beandefinition; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; @Configuration @ComponentScan(&quot;com.leeyh0216.springframeworkstudy.beandefinition&quot;) public class ApplicationConfiguration { @Bean(&quot;HelloService&quot;) public IHelloService getIHelloService(){ return new HelloServiceImpl(); } } ApplicationConfiguration.class에서는 IHelloService Bean을 생성할 수 있는 Factory Method를 만들었다. 위 변경된 사항으로 다시 메인 함수를 실행했을 경우 아래와 같은 출력이 발생하는 것을 알 수 있다. Bean class name: null Bean Scope: Bean constructor argument values: org.springframework.beans.factory.config.ConstructorArgumentValues@cb Bean depends on null Is lazy init bean? false Has bean property values? false Factory Method로 생성한 Bean 정보의 행방 Factory Method로 생성한 Bean의 경우 기본 정보(Bean의 클래스명, Scope)가 null로 표기된다. 이러한 정보들은 어디에 있을까? Breakpoint를 잡아 BeanDefinition 객체를 확인해 보았다. beanDefinition 객체의 factoryMethodMetadata 내부에 어느정도 Bean Definition에 관련된 내용을 확인할 수 있는 것을 알 수 있다. 다만, Scope 등의 정보는 여기에도 없다. 하지만 Scope를 설정해주지 않고도 정상 동작하는 것과, 여러 번의 객체 생성을 시도하여도 동일 객체가 반환되는 것을 보면 역시 기본 Scope인 Singleton으로 동작하는 것을 확인할 수 있었다. 다만 @Component, @Service 등의 어노테이션을 붙여 Bean으로 만든 경우에는 아래와 같이 BeanDefinition에 설정한 정보들이 정상적으로 들어있는 것을 알 수 있다. Naming Beans 모든 Bean들은 1개 이상의 식별자를 가진다. Container가 Bean들을 관리하기 위해서는 이 식별자가 유일해야 한다. @Component 어노테이션을 확인해보면 다음과 같이 value가 이름을 나타내는 것을 볼 수 있다. /** * The value may indicate a suggestion for a logical component name, * to be turned into a Spring bean in case of an autodetected component. * @return the suggested component name, if any (or empty String otherwise) */ String value() default &quot;&quot;; 아래와 같은 예제를 작성해 보았다. ISimpleService.class package com.leeyh0216.springframeworkstudy.namingbeans; public interface ISimpleService { void printVersion(); } SimpleServiceImplV1.class package com.leeyh0216.springframeworkstudy.namingbeans; import org.springframework.stereotype.Component; @Component public class SimpleServiceImplV1 implements ISimpleService { @Override public void printVersion() { System.out.println(&quot;V1&quot;); } } SimpleServiceImplV2.class package com.leeyh0216.springframeworkstudy.namingbeans; import org.springframework.stereotype.Component; @Component(&quot;SimpleServiceImpl&quot;) public class SimpleServiceImplV2 implements ISimpleService{ @Override public void printVersion() { System.out.println(&quot;V2&quot;); } } SimpleServiceImplV3.class package com.leeyh0216.springframeworkstudy.namingbeans; public class SimpleServiceImplV3 implements ISimpleService { @Override public void printVersion() { System.out.println(&quot;V3&quot;); } } ApplicationConfiguration.class package com.leeyh0216.springframeworkstudy.namingbeans; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; @Configuration @ComponentScan(&quot;com.leeyh0216.springframeworkstudy.namingbeans&quot;) public class ApplicationConfiguration { @Bean(name={&quot;NewSimpleService&quot;,&quot;SimpleServiceV3&quot;}) public SimpleServiceImplV3 getSimpleServiceImplV3(){ return new SimpleServiceImplV3(); } } Application.class package com.leeyh0216.springframeworkstudy.namingbeans; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args){ AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(ApplicationConfiguration.class); ISimpleService b1 = applicationContext.getBean(&quot;simpleServiceImplV1&quot;, SimpleServiceImplV1.class); b1.printVersion(); ISimpleService b2 = applicationContext.getBean(&quot;SimpleServiceImpl&quot;, SimpleServiceImplV2.class); b2.printVersion(); ISimpleService b3_1 = applicationContext.getBean(&quot;NewSimpleService&quot;, SimpleServiceImplV3.class); b3_1.printVersion(); ISimpleService b3_2 = applicationContext.getBean(&quot;SimpleServiceV3&quot;, SimpleServiceImplV3.class); b3_2.printVersion(); } } SimpleServiceImplV1 클래스와 같이 이름을 지정하지 않은 경우 클래스명의 첫번째 문자를 소문자로 변경하고, Camel Case화 시켜서 이름으로 간주한다. SimpleServiceImplV2 클래스와 같이 이름을 명시적으로 지정하는 경우, 해당 이름을 사용하여 Bean을 찾을 수 있다. SimpleServiceImplV3 클래스의 경우 다른 클래스와 달리 팩토리 메서드로 생성했으며, @Bean 어노테이션이 사용되었다. @Bean 어노테이션의 경우 1개 이상의 이름을 지정할 수 있도록 되어 있다. 때문에 NewSimpleService, SimpleServiceV3 등으로 Bean을 접근하여도 동일한 Bean이 반환되는 것을 확인할 수 있다. @Bean 어노테이션의 name이 아래와 같이 지정되어 있기 때문에 1개 이상의 식별자를 사용할 수 있는 것으로 보인다. /** * The name of this bean, or if several names, a primary bean name plus aliases. * &lt;p&gt;If left unspecified, the name of the bean is the name of the annotated method. * If specified, the method name is ignored. * &lt;p&gt;The bean name and aliases may also be configured via the {@link #value} * attribute if no other attributes are declared. * @see #value */ @AliasFor(&quot;value&quot;) String[] name() default {};" />
<link rel="canonical" href="http://localhost:4000/2019-05-18/spring-core-1" />
<meta property="og:url" content="http://localhost:4000/2019-05-18/spring-core-1" />
<meta property="og:site_name" content="DevLog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-05-18T10:00:00+09:00" />
<script type="application/ld+json">
{"author":{"@type":"Person","name":"leeyh0216"},"url":"http://localhost:4000/2019-05-18/spring-core-1","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2019-05-18/spring-core-1"},"headline":"Spring IoC Container - Container, Bean overview","dateModified":"2019-05-18T10:00:00+09:00","datePublished":"2019-05-18T10:00:00+09:00","description":"The IoC Container Introduction to the Spring IoC Container and Beans Inversion of Control(IoC, 제어의 역전)은 Dependency Injection(DI, 의존성 주입)로도 알려져 있다. 객체는 자신이 동작하는데에 필요한 의존성(객체)을 생성자 팩토리 메서드의 인자 Setter 를 통해 설정할 수 있도록 한다. Container는 객체를 생성할 때 의존성들을 위에서 정의한 방법으로 주입해준다. 객체가 자신의 초기화나 의존성의 설정을 스스로 하는 것이 아니라 Container에 위임하는 방식이기 때문에 제어의 역전이라고 불리우는 것이다. org.springframework.beans와 org.springframework.context 패키지가 Spring Framework의 IoC Container의 기반을 제공한다. 이 중 BeanFactory 인터페이스는 객체를 관리하는 매커니즘을 제공하고, ApplicationContext는 BeanFactory 를 상속받은 하위 인터페이스로써, AOP Message Resource Handling Event Publication WebApplicationContext와 같은 Application-Layer Specific Context 등의 엔터프라이즈 기능을 추가적으로 제공한다. Spring에서 Application을 구성하는 객체들은 Spring IoC Container에 의해 관리되며, Bean이라고 불린다. Bean은 Spring IoC Container에 의해 초기화, 조합, 관리된다. 또한 Bean과 Bean을 구성하는 의존성들은 Container에게는 Configuration metadata로 표현된다. Container Overview org.springframework.context.ApplicationContext는 Spring IoC Container를 대표하는 인터페이스로써 앞에서 언급한 Bean의 생성, 구성, 조합을 담당한다. Container는 어떤 객체를 초기화하고 구성하고 조합할지를 Congiruation metadata를 사용해서 수행한다. Configuration metadata는 XML, Java Annotations, Java Code 등의 다양한 포맷으로 존재한다. XML 방식이 전통적인 Congiruation metadata 표현 방식이지만, Java Annotations나 Java Code로도 Configuration metadata를 표현할 수 있다. Spring Boot Application을 공부하려는 목적이 크기 때문에, XML이나 Application Context를 직접 초기화하는 방법은 시도하지 않은 예정이다. Bean Overview Container는 Bean을 관리할 때 BeanDefinition이라는 객체를 이용하여 관리한다. BeanDefinition 안에는 다음과 같은 속성들이 있다. package-qualified class name: Bean을 정의할 실제 구현 클래스 Container에서의 Bean의 동작 상태(scope, lifecycle callbacks 등) Bean이 동작하는데 필요한 다른 Bean(collaborators 나 dependencies로 불림) @Component로 생성된 Bean의 Bean Definition “HelloWorld!!” 를 출력하는 서비스를 아래와 같이 인터페이스와 구현 클래스를 만들었다. IHelloService.class package com.leeyh0216.springframeworkstudy.beandefinition; public interface IHelloService { void printHelloWorld(); } HelloServiceImpl.class package com.leeyh0216.springframeworkstudy.beandefinition; import org.springframework.stereotype.Component; @Component(&quot;HelloService&quot;) public class HelloServiceImpl implements IHelloService{ @Override public void printHelloWorld() { System.out.println(&quot;Hello World!!&quot;); } } 그리고 위에서 정의된 HelloServiceImpl Bean을 스캔할 수 있도록 Configuration 클래스를 아래와 같이 생성하였다. ApplicationConfiguration.class package com.leeyh0216.springframeworkstudy.beandefinition; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; @Configuration @ComponentScan(&quot;com.leeyh0216.springframeworkstudy.beandefinition&quot;) public class ApplicationConfiguration { } 아래와 같이 메인 함수를 작성하여 실행시켜보면 package com.leeyh0216.springframeworkstudy.beandefinition; import org.springframework.beans.factory.config.BeanDefinition; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args){ AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(ApplicationConfiguration.class); BeanDefinition beanDefinition = applicationContext.getBeanDefinition(&quot;HelloService&quot;); System.out.println(&quot;Bean class name: &quot; + beanDefinition.getBeanClassName()); System.out.println(&quot;Bean Scope: &quot; + beanDefinition.getScope()); System.out.println(&quot;Bean constructor argument values: &quot; + beanDefinition.getConstructorArgumentValues()); System.out.println(&quot;Bean depends on &quot; + beanDefinition.getDependsOn()); System.out.println(&quot;Is lazy init bean? &quot; + beanDefinition.isLazyInit()); System.out.println(&quot;Has bean property values? &quot; + beanDefinition.hasPropertyValues()); } } 다음과 같은 출력이 발생한다. Bean class name: com.leeyh0216.springframeworkstudy.beandefinition.HelloServiceImpl Bean Scope: singleton Bean constructor argument values: org.springframework.beans.factory.config.ConstructorArgumentValues@cb Bean depends on null Is lazy init bean? false Has bean property values? false 대부분의 정보가 정상적으로 출력되는 것을 알 수 있다. Factory 메소드로 생성된 Bean의 Bean Definition 위의 예제를 약간 수정하여 Factory Method로 Bean을 생성하도록 하였다. HelloServiceImpl.class package com.leeyh0216.springframeworkstudy.beandefinition; public class HelloServiceImpl implements IHelloService{ @Override public void printHelloWorld() { System.out.println(&quot;Hello World!!&quot;); } } HelloServiceImpl 클래스의 경우 @Component 어노테이션을 없애서 자동으로 Bean으로 생성되는 것을 방지하였다. ApplicationConfiguration.class package com.leeyh0216.springframeworkstudy.beandefinition; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; @Configuration @ComponentScan(&quot;com.leeyh0216.springframeworkstudy.beandefinition&quot;) public class ApplicationConfiguration { @Bean(&quot;HelloService&quot;) public IHelloService getIHelloService(){ return new HelloServiceImpl(); } } ApplicationConfiguration.class에서는 IHelloService Bean을 생성할 수 있는 Factory Method를 만들었다. 위 변경된 사항으로 다시 메인 함수를 실행했을 경우 아래와 같은 출력이 발생하는 것을 알 수 있다. Bean class name: null Bean Scope: Bean constructor argument values: org.springframework.beans.factory.config.ConstructorArgumentValues@cb Bean depends on null Is lazy init bean? false Has bean property values? false Factory Method로 생성한 Bean 정보의 행방 Factory Method로 생성한 Bean의 경우 기본 정보(Bean의 클래스명, Scope)가 null로 표기된다. 이러한 정보들은 어디에 있을까? Breakpoint를 잡아 BeanDefinition 객체를 확인해 보았다. beanDefinition 객체의 factoryMethodMetadata 내부에 어느정도 Bean Definition에 관련된 내용을 확인할 수 있는 것을 알 수 있다. 다만, Scope 등의 정보는 여기에도 없다. 하지만 Scope를 설정해주지 않고도 정상 동작하는 것과, 여러 번의 객체 생성을 시도하여도 동일 객체가 반환되는 것을 보면 역시 기본 Scope인 Singleton으로 동작하는 것을 확인할 수 있었다. 다만 @Component, @Service 등의 어노테이션을 붙여 Bean으로 만든 경우에는 아래와 같이 BeanDefinition에 설정한 정보들이 정상적으로 들어있는 것을 알 수 있다. Naming Beans 모든 Bean들은 1개 이상의 식별자를 가진다. Container가 Bean들을 관리하기 위해서는 이 식별자가 유일해야 한다. @Component 어노테이션을 확인해보면 다음과 같이 value가 이름을 나타내는 것을 볼 수 있다. /** * The value may indicate a suggestion for a logical component name, * to be turned into a Spring bean in case of an autodetected component. * @return the suggested component name, if any (or empty String otherwise) */ String value() default &quot;&quot;; 아래와 같은 예제를 작성해 보았다. ISimpleService.class package com.leeyh0216.springframeworkstudy.namingbeans; public interface ISimpleService { void printVersion(); } SimpleServiceImplV1.class package com.leeyh0216.springframeworkstudy.namingbeans; import org.springframework.stereotype.Component; @Component public class SimpleServiceImplV1 implements ISimpleService { @Override public void printVersion() { System.out.println(&quot;V1&quot;); } } SimpleServiceImplV2.class package com.leeyh0216.springframeworkstudy.namingbeans; import org.springframework.stereotype.Component; @Component(&quot;SimpleServiceImpl&quot;) public class SimpleServiceImplV2 implements ISimpleService{ @Override public void printVersion() { System.out.println(&quot;V2&quot;); } } SimpleServiceImplV3.class package com.leeyh0216.springframeworkstudy.namingbeans; public class SimpleServiceImplV3 implements ISimpleService { @Override public void printVersion() { System.out.println(&quot;V3&quot;); } } ApplicationConfiguration.class package com.leeyh0216.springframeworkstudy.namingbeans; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; @Configuration @ComponentScan(&quot;com.leeyh0216.springframeworkstudy.namingbeans&quot;) public class ApplicationConfiguration { @Bean(name={&quot;NewSimpleService&quot;,&quot;SimpleServiceV3&quot;}) public SimpleServiceImplV3 getSimpleServiceImplV3(){ return new SimpleServiceImplV3(); } } Application.class package com.leeyh0216.springframeworkstudy.namingbeans; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args){ AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(ApplicationConfiguration.class); ISimpleService b1 = applicationContext.getBean(&quot;simpleServiceImplV1&quot;, SimpleServiceImplV1.class); b1.printVersion(); ISimpleService b2 = applicationContext.getBean(&quot;SimpleServiceImpl&quot;, SimpleServiceImplV2.class); b2.printVersion(); ISimpleService b3_1 = applicationContext.getBean(&quot;NewSimpleService&quot;, SimpleServiceImplV3.class); b3_1.printVersion(); ISimpleService b3_2 = applicationContext.getBean(&quot;SimpleServiceV3&quot;, SimpleServiceImplV3.class); b3_2.printVersion(); } } SimpleServiceImplV1 클래스와 같이 이름을 지정하지 않은 경우 클래스명의 첫번째 문자를 소문자로 변경하고, Camel Case화 시켜서 이름으로 간주한다. SimpleServiceImplV2 클래스와 같이 이름을 명시적으로 지정하는 경우, 해당 이름을 사용하여 Bean을 찾을 수 있다. SimpleServiceImplV3 클래스의 경우 다른 클래스와 달리 팩토리 메서드로 생성했으며, @Bean 어노테이션이 사용되었다. @Bean 어노테이션의 경우 1개 이상의 이름을 지정할 수 있도록 되어 있다. 때문에 NewSimpleService, SimpleServiceV3 등으로 Bean을 접근하여도 동일한 Bean이 반환되는 것을 확인할 수 있다. @Bean 어노테이션의 name이 아래와 같이 지정되어 있기 때문에 1개 이상의 식별자를 사용할 수 있는 것으로 보인다. /** * The name of this bean, or if several names, a primary bean name plus aliases. * &lt;p&gt;If left unspecified, the name of the bean is the name of the annotated method. * If specified, the method name is ignored. * &lt;p&gt;The bean name and aliases may also be configured via the {@link #value} * attribute if no other attributes are declared. * @see #value */ @AliasFor(&quot;value&quot;) String[] name() default {};","@type":"BlogPosting","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


  <!-- CSS -->
  <link rel="stylesheet" href="/assets/main.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">

  <!-- Favicon -->
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png">

  <!-- RSS -->
  <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="DevLog" />

  <!-- Google Analytics-->
  <script data-ad-client="ca-pub-8829030678254956" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
</head>


  <body>

    <nav class="nav">
  <div class="nav-container">
    <a href="/">
      <h2 class="nav-title">DevLog</h2>
    </a>
    <ul>
      <li><a href="/about">About</a></li>
      <li><a href="/">Posts</a></li>
      <li><a href="/tags">Tags</a></li>
    </ul>
  </div>
</nav>


    <main>
      <div class="post">
  <div class="post-info">
    <span>Written by</span>
    
        leeyh0216
    

    
      <br>
      <span>on&nbsp;</span><time datetime="2019-05-18 10:00:00 +0900">May 18, 2019</time>
    
    
    
      <br>
      <span>
      
        
        <a style="text-decoration: none;" href="/tag/spring"><code class="highligher-rouge"><nobr>spring</nobr></code>&nbsp;</a>
      
      </span>
    
  </span>
  </div>

  <h1 class="post-title">Spring IoC Container - Container, Bean overview</h1>
  <div class="post-line"></div>

  <h1 id="the-ioc-container">The IoC Container</h1>

<h2 id="introduction-to-the-spring-ioc-container-and-beans">Introduction to the Spring IoC Container and Beans</h2>

<p>Inversion of Control(IoC, 제어의 역전)은 Dependency Injection(DI, 의존성 주입)로도 알려져 있다.</p>

<p>객체는 자신이 동작하는데에 필요한 의존성(객체)을</p>
<ul>
  <li>생성자</li>
  <li>팩토리 메서드의 인자</li>
  <li>Setter
를 통해 설정할 수 있도록 한다.</li>
</ul>

<p>Container는 객체를 생성할 때 의존성들을 위에서 정의한 방법으로 주입해준다.</p>

<p>객체가 자신의 초기화나 의존성의 설정을 스스로 하는 것이 아니라 Container에 위임하는 방식이기 때문에 제어의 역전이라고 불리우는 것이다.</p>

<hr />

<p><code class="highlighter-rouge">org.springframework.beans</code>와 <code class="highlighter-rouge">org.springframework.context</code> 패키지가 Spring Framework의 IoC Container의 기반을 제공한다.</p>

<p>이 중 <code class="highlighter-rouge">BeanFactory</code> 인터페이스는 객체를 관리하는 매커니즘을 제공하고, <code class="highlighter-rouge">ApplicationContext</code>는 <code class="highlighter-rouge">BeanFactory</code> 를 상속받은 하위 인터페이스로써,</p>

<ul>
  <li>AOP</li>
  <li>Message Resource Handling</li>
  <li>Event Publication</li>
  <li>WebApplicationContext와 같은 Application-Layer Specific Context</li>
</ul>

<p>등의 엔터프라이즈 기능을 추가적으로 제공한다.</p>

<p>Spring에서 Application을 구성하는 객체들은 Spring IoC Container에 의해 관리되며, Bean이라고 불린다. Bean은 Spring IoC Container에 의해 초기화, 조합, 관리된다.</p>

<p>또한 Bean과 Bean을 구성하는 의존성들은 Container에게는 Configuration metadata로 표현된다.</p>

<h2 id="container-overview">Container Overview</h2>

<p><img src="/assets/spring/spring_ioc_container.jpg" alt="Spring IoC Container" /></p>

<p><code class="highlighter-rouge">org.springframework.context.ApplicationContext</code>는 Spring IoC Container를 대표하는 인터페이스로써 앞에서 언급한 Bean의 생성, 구성, 조합을 담당한다.</p>

<p>Container는 어떤 객체를 초기화하고 구성하고 조합할지를 Congiruation metadata를 사용해서 수행한다. Configuration metadata는 <code class="highlighter-rouge">XML</code>, <code class="highlighter-rouge">Java Annotations</code>, <code class="highlighter-rouge">Java Code</code> 등의 다양한 포맷으로 존재한다.</p>

<p><code class="highlighter-rouge">XML</code> 방식이 전통적인 Congiruation metadata 표현 방식이지만, <code class="highlighter-rouge">Java Annotations</code>나 <code class="highlighter-rouge">Java Code</code>로도 Configuration metadata를 표현할 수 있다.</p>

<blockquote>
  <p>Spring Boot Application을 공부하려는 목적이 크기 때문에, <code class="highlighter-rouge">XML</code>이나 <code class="highlighter-rouge">Application Context</code>를 직접 초기화하는 방법은 시도하지 않은 예정이다.</p>
</blockquote>

<h2 id="bean-overview">Bean Overview</h2>

<p>Container는 Bean을 관리할 때 <code class="highlighter-rouge">BeanDefinition</code>이라는 객체를 이용하여 관리한다. <code class="highlighter-rouge">BeanDefinition</code> 안에는 다음과 같은 속성들이 있다.</p>

<ul>
  <li><code class="highlighter-rouge">package-qualified class name</code>: Bean을 정의할 실제 구현 클래스</li>
  <li>Container에서의 Bean의 동작 상태(scope, lifecycle callbacks 등)</li>
  <li>Bean이 동작하는데 필요한 다른 Bean(collaborators 나 dependencies로 불림)</li>
</ul>

<h3 id="component로-생성된-bean의-bean-definition"><code class="highlighter-rouge">@Component</code>로 생성된 Bean의 Bean Definition</h3>

<p>“HelloWorld!!” 를 출력하는 서비스를 아래와 같이 인터페이스와 구현 클래스를 만들었다.</p>

<p><code class="highlighter-rouge">IHelloService.class</code></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">com</span><span class="p">.</span><span class="n">leeyh0216</span><span class="p">.</span><span class="n">springframeworkstudy</span><span class="p">.</span><span class="n">beandefinition</span><span class="p">;</span>

<span class="k">public</span> <span class="n">interface</span> <span class="n">IHelloService</span> <span class="p">{</span>

    <span class="n">void</span> <span class="n">printHelloWorld</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">HelloServiceImpl.class</code></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">com</span><span class="p">.</span><span class="n">leeyh0216</span><span class="p">.</span><span class="n">springframeworkstudy</span><span class="p">.</span><span class="n">beandefinition</span><span class="p">;</span>

<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">stereotype</span><span class="p">.</span><span class="n">Component</span><span class="p">;</span>

<span class="p">@</span><span class="n">Component</span><span class="p">(</span><span class="s2">"HelloService"</span><span class="p">)</span>
<span class="k">public</span> <span class="n">class</span> <span class="n">HelloServiceImpl</span> <span class="n">implements</span> <span class="n">IHelloService</span><span class="p">{</span>

    <span class="p">@</span><span class="n">Override</span>
    <span class="k">public</span> <span class="n">void</span> <span class="n">printHelloWorld</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s2">"Hello World!!"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>그리고 위에서 정의된 <code class="highlighter-rouge">HelloServiceImpl</code> Bean을 스캔할 수 있도록 Configuration 클래스를 아래와 같이 생성하였다.</p>

<p><code class="highlighter-rouge">ApplicationConfiguration.class</code></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">com</span><span class="p">.</span><span class="n">leeyh0216</span><span class="p">.</span><span class="n">springframeworkstudy</span><span class="p">.</span><span class="n">beandefinition</span><span class="p">;</span>

<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">context</span><span class="p">.</span><span class="n">annotation</span><span class="p">.</span><span class="n">ComponentScan</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">context</span><span class="p">.</span><span class="n">annotation</span><span class="p">.</span><span class="n">Configuration</span><span class="p">;</span>

<span class="p">@</span><span class="n">Configuration</span>
<span class="p">@</span><span class="n">ComponentScan</span><span class="p">(</span><span class="s2">"com.leeyh0216.springframeworkstudy.beandefinition"</span><span class="p">)</span>
<span class="k">public</span> <span class="n">class</span> <span class="n">ApplicationConfiguration</span> <span class="p">{</span>
<span class="p">}</span>
</code></pre></div></div>

<p>아래와 같이 메인 함수를 작성하여 실행시켜보면</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">com</span><span class="p">.</span><span class="n">leeyh0216</span><span class="p">.</span><span class="n">springframeworkstudy</span><span class="p">.</span><span class="n">beandefinition</span><span class="p">;</span>

<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">beans</span><span class="p">.</span><span class="n">factory</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">BeanDefinition</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">context</span><span class="p">.</span><span class="n">annotation</span><span class="p">.</span><span class="n">AnnotationConfigApplicationContext</span><span class="p">;</span>

<span class="k">public</span> <span class="n">class</span> <span class="n">Application</span> <span class="p">{</span>

    <span class="k">public</span> <span class="n">static</span> <span class="n">void</span> <span class="n">main</span><span class="p">(</span><span class="k">String</span><span class="p">[]</span> <span class="n">args</span><span class="p">){</span>
        <span class="n">AnnotationConfigApplicationContext</span> <span class="n">applicationContext</span> <span class="p">=</span> <span class="n">new</span> <span class="n">AnnotationConfigApplicationContext</span><span class="p">(</span><span class="n">ApplicationConfiguration</span><span class="p">.</span><span class="n">class</span><span class="p">);</span>
        <span class="n">BeanDefinition</span> <span class="n">beanDefinition</span> <span class="p">=</span> <span class="n">applicationContext</span><span class="p">.</span><span class="n">getBeanDefinition</span><span class="p">(</span><span class="s2">"HelloService"</span><span class="p">);</span>

        <span class="nf">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s2">"Bean class name: "</span> <span class="p">+</span> <span class="n">beanDefinition</span><span class="p">.</span><span class="n">getBeanClassName</span><span class="p">());</span>
        <span class="nf">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s2">"Bean Scope: "</span> <span class="p">+</span> <span class="n">beanDefinition</span><span class="p">.</span><span class="n">getScope</span><span class="p">());</span>
        <span class="nf">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s2">"Bean constructor argument values: "</span> <span class="p">+</span> <span class="n">beanDefinition</span><span class="p">.</span><span class="n">getConstructorArgumentValues</span><span class="p">());</span>
        <span class="nf">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s2">"Bean depends on "</span> <span class="p">+</span> <span class="n">beanDefinition</span><span class="p">.</span><span class="n">getDependsOn</span><span class="p">());</span>
        <span class="nf">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s2">"Is lazy init bean? "</span> <span class="p">+</span> <span class="n">beanDefinition</span><span class="p">.</span><span class="n">isLazyInit</span><span class="p">());</span>
        <span class="nf">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s2">"Has bean property values? "</span> <span class="p">+</span> <span class="n">beanDefinition</span><span class="p">.</span><span class="n">hasPropertyValues</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>다음과 같은 출력이 발생한다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Bean class name: com.leeyh0216.springframeworkstudy.beandefinition.HelloServiceImpl
Bean Scope: singleton
Bean constructor argument values: org.springframework.beans.factory.config.ConstructorArgumentValues@cb
Bean depends on null
Is lazy init bean? false
Has bean property values? false
</code></pre></div></div>

<p>대부분의 정보가 정상적으로 출력되는 것을 알 수 있다.</p>

<h3 id="factory-메소드로-생성된-bean의-bean-definition">Factory 메소드로 생성된 Bean의 Bean Definition</h3>

<p>위의 예제를 약간 수정하여 Factory Method로 Bean을 생성하도록 하였다.</p>

<p><code class="highlighter-rouge">HelloServiceImpl.class</code></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">com</span><span class="p">.</span><span class="n">leeyh0216</span><span class="p">.</span><span class="n">springframeworkstudy</span><span class="p">.</span><span class="n">beandefinition</span><span class="p">;</span>

<span class="k">public</span> <span class="n">class</span> <span class="n">HelloServiceImpl</span> <span class="n">implements</span> <span class="n">IHelloService</span><span class="p">{</span>

    <span class="p">@</span><span class="n">Override</span>
    <span class="k">public</span> <span class="n">void</span> <span class="n">printHelloWorld</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s2">"Hello World!!"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">HelloServiceImpl</code> 클래스의 경우 <code class="highlighter-rouge">@Component</code> 어노테이션을 없애서 자동으로 Bean으로 생성되는 것을 방지하였다.</p>

<p><code class="highlighter-rouge">ApplicationConfiguration.class</code></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">com</span><span class="p">.</span><span class="n">leeyh0216</span><span class="p">.</span><span class="n">springframeworkstudy</span><span class="p">.</span><span class="n">beandefinition</span><span class="p">;</span>

<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">context</span><span class="p">.</span><span class="n">annotation</span><span class="p">.</span><span class="n">Bean</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">context</span><span class="p">.</span><span class="n">annotation</span><span class="p">.</span><span class="n">ComponentScan</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">context</span><span class="p">.</span><span class="n">annotation</span><span class="p">.</span><span class="n">Configuration</span><span class="p">;</span>

<span class="p">@</span><span class="n">Configuration</span>
<span class="p">@</span><span class="n">ComponentScan</span><span class="p">(</span><span class="s2">"com.leeyh0216.springframeworkstudy.beandefinition"</span><span class="p">)</span>
<span class="k">public</span> <span class="n">class</span> <span class="n">ApplicationConfiguration</span> <span class="p">{</span>

    <span class="p">@</span><span class="n">Bean</span><span class="p">(</span><span class="s2">"HelloService"</span><span class="p">)</span>
    <span class="k">public</span> <span class="n">IHelloService</span> <span class="n">getIHelloService</span><span class="p">(){</span>
        <span class="n">return</span> <span class="n">new</span> <span class="n">HelloServiceImpl</span><span class="p">();</span>
    <span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>
<p><code class="highlighter-rouge">ApplicationConfiguration.class</code>에서는 <code class="highlighter-rouge">IHelloService</code> Bean을 생성할 수 있는 Factory Method를 만들었다.</p>

<p>위 변경된 사항으로 다시 메인 함수를 실행했을 경우 아래와 같은 출력이 발생하는 것을 알 수 있다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Bean class name: null
Bean Scope: 
Bean constructor argument values: org.springframework.beans.factory.config.ConstructorArgumentValues@cb
Bean depends on null
Is lazy init bean? false
Has bean property values? false
</code></pre></div></div>

<h3 id="factory-method로-생성한-bean-정보의-행방">Factory Method로 생성한 Bean 정보의 행방</h3>

<p>Factory Method로 생성한 Bean의 경우 기본 정보(Bean의 클래스명, Scope)가 null로 표기된다. 이러한 정보들은 어디에 있을까? Breakpoint를 잡아 BeanDefinition 객체를 확인해 보았다.</p>

<p><img src="/assets/spring/factory_method_beandefinition.png" alt="Factory Method Bean Definition" /></p>

<p><code class="highlighter-rouge">beanDefinition</code> 객체의 <code class="highlighter-rouge">factoryMethodMetadata</code> 내부에 어느정도 Bean Definition에 관련된 내용을 확인할 수 있는 것을 알 수 있다.</p>

<p>다만, Scope 등의 정보는 여기에도 없다. 하지만 Scope를 설정해주지 않고도 정상 동작하는 것과, 여러 번의 객체 생성을 시도하여도 동일 객체가 반환되는 것을 보면 역시 기본 Scope인 Singleton으로 동작하는 것을 확인할 수 있었다.</p>

<p>다만 <code class="highlighter-rouge">@Component</code>, <code class="highlighter-rouge">@Service</code> 등의 어노테이션을 붙여 Bean으로 만든 경우에는 아래와 같이 BeanDefinition에 설정한 정보들이 정상적으로 들어있는 것을 알 수 있다.</p>

<p><img src="/assets/spring/annotated_bean_beandefinition.png" alt="Annotated Bean Bean Definition" /></p>

<hr />
<h3 id="naming-beans">Naming Beans</h3>

<p>모든 Bean들은 1개 이상의 식별자를 가진다. Container가 Bean들을 관리하기 위해서는 이 식별자가 유일해야 한다.</p>

<p><code class="highlighter-rouge">@Component</code> 어노테이션을 확인해보면 다음과 같이 value가 이름을 나타내는 것을 볼 수 있다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/**
 * The value may indicate a suggestion for a logical component name,
 * to be turned into a Spring bean in case of an autodetected component.
 * @return the suggested component name, if any (or empty String otherwise)
 */
String value() default "";
</code></pre></div></div>

<p>아래와 같은 예제를 작성해 보았다.</p>

<p><code class="highlighter-rouge">ISimpleService.class</code></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">com</span><span class="p">.</span><span class="n">leeyh0216</span><span class="p">.</span><span class="n">springframeworkstudy</span><span class="p">.</span><span class="n">namingbeans</span><span class="p">;</span>

<span class="k">public</span> <span class="n">interface</span> <span class="n">ISimpleService</span> <span class="p">{</span>

    <span class="n">void</span> <span class="n">printVersion</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">SimpleServiceImplV1.class</code></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">com</span><span class="p">.</span><span class="n">leeyh0216</span><span class="p">.</span><span class="n">springframeworkstudy</span><span class="p">.</span><span class="n">namingbeans</span><span class="p">;</span>

<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">stereotype</span><span class="p">.</span><span class="n">Component</span><span class="p">;</span>

<span class="p">@</span><span class="n">Component</span>
<span class="k">public</span> <span class="n">class</span> <span class="n">SimpleServiceImplV1</span> <span class="n">implements</span> <span class="n">ISimpleService</span> <span class="p">{</span>
    <span class="p">@</span><span class="n">Override</span>
    <span class="k">public</span> <span class="n">void</span> <span class="n">printVersion</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s2">"V1"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">SimpleServiceImplV2.class</code></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">com</span><span class="p">.</span><span class="n">leeyh0216</span><span class="p">.</span><span class="n">springframeworkstudy</span><span class="p">.</span><span class="n">namingbeans</span><span class="p">;</span>

<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">stereotype</span><span class="p">.</span><span class="n">Component</span><span class="p">;</span>

<span class="p">@</span><span class="n">Component</span><span class="p">(</span><span class="s2">"SimpleServiceImpl"</span><span class="p">)</span>
<span class="k">public</span> <span class="n">class</span> <span class="n">SimpleServiceImplV2</span> <span class="n">implements</span> <span class="n">ISimpleService</span><span class="p">{</span>
    <span class="p">@</span><span class="n">Override</span>
    <span class="k">public</span> <span class="n">void</span> <span class="n">printVersion</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s2">"V2"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">SimpleServiceImplV3.class</code></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">com</span><span class="p">.</span><span class="n">leeyh0216</span><span class="p">.</span><span class="n">springframeworkstudy</span><span class="p">.</span><span class="n">namingbeans</span><span class="p">;</span>

<span class="k">public</span> <span class="n">class</span> <span class="n">SimpleServiceImplV3</span> <span class="n">implements</span> <span class="n">ISimpleService</span> <span class="p">{</span>
    <span class="p">@</span><span class="n">Override</span>
    <span class="k">public</span> <span class="n">void</span> <span class="n">printVersion</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s2">"V3"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">ApplicationConfiguration.class</code></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">com</span><span class="p">.</span><span class="n">leeyh0216</span><span class="p">.</span><span class="n">springframeworkstudy</span><span class="p">.</span><span class="n">namingbeans</span><span class="p">;</span>

<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">context</span><span class="p">.</span><span class="n">annotation</span><span class="p">.</span><span class="n">Bean</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">context</span><span class="p">.</span><span class="n">annotation</span><span class="p">.</span><span class="n">ComponentScan</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">context</span><span class="p">.</span><span class="n">annotation</span><span class="p">.</span><span class="n">Configuration</span><span class="p">;</span>

<span class="p">@</span><span class="n">Configuration</span>
<span class="p">@</span><span class="n">ComponentScan</span><span class="p">(</span><span class="s2">"com.leeyh0216.springframeworkstudy.namingbeans"</span><span class="p">)</span>
<span class="k">public</span> <span class="n">class</span> <span class="n">ApplicationConfiguration</span> <span class="p">{</span>
    <span class="p">@</span><span class="n">Bean</span><span class="p">(</span><span class="n">name</span><span class="p">={</span><span class="s2">"NewSimpleService"</span><span class="p">,</span><span class="s2">"SimpleServiceV3"</span><span class="p">})</span>
    <span class="k">public</span> <span class="n">SimpleServiceImplV3</span> <span class="n">getSimpleServiceImplV3</span><span class="p">(){</span>
        <span class="n">return</span> <span class="n">new</span> <span class="n">SimpleServiceImplV3</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">Application.class</code></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">com</span><span class="p">.</span><span class="n">leeyh0216</span><span class="p">.</span><span class="n">springframeworkstudy</span><span class="p">.</span><span class="n">namingbeans</span><span class="p">;</span>

<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">context</span><span class="p">.</span><span class="n">annotation</span><span class="p">.</span><span class="n">AnnotationConfigApplicationContext</span><span class="p">;</span>

<span class="k">public</span> <span class="n">class</span> <span class="n">Application</span> <span class="p">{</span>
    <span class="k">public</span> <span class="n">static</span> <span class="n">void</span> <span class="n">main</span><span class="p">(</span><span class="k">String</span><span class="p">[]</span> <span class="n">args</span><span class="p">){</span>
        <span class="n">AnnotationConfigApplicationContext</span> <span class="n">applicationContext</span> <span class="p">=</span> <span class="n">new</span> <span class="n">AnnotationConfigApplicationContext</span><span class="p">(</span><span class="n">ApplicationConfiguration</span><span class="p">.</span><span class="n">class</span><span class="p">);</span>

        <span class="n">ISimpleService</span> <span class="n">b1</span> <span class="p">=</span> <span class="n">applicationContext</span><span class="p">.</span><span class="n">getBean</span><span class="p">(</span><span class="s2">"simpleServiceImplV1"</span><span class="p">,</span> <span class="n">SimpleServiceImplV1</span><span class="p">.</span><span class="n">class</span><span class="p">);</span>
        <span class="n">b1</span><span class="p">.</span><span class="n">printVersion</span><span class="p">();</span>

        <span class="n">ISimpleService</span> <span class="n">b2</span> <span class="p">=</span> <span class="n">applicationContext</span><span class="p">.</span><span class="n">getBean</span><span class="p">(</span><span class="s2">"SimpleServiceImpl"</span><span class="p">,</span> <span class="n">SimpleServiceImplV2</span><span class="p">.</span><span class="n">class</span><span class="p">);</span>
        <span class="n">b2</span><span class="p">.</span><span class="n">printVersion</span><span class="p">();</span>

        <span class="n">ISimpleService</span> <span class="n">b3_1</span> <span class="p">=</span> <span class="n">applicationContext</span><span class="p">.</span><span class="n">getBean</span><span class="p">(</span><span class="s2">"NewSimpleService"</span><span class="p">,</span> <span class="n">SimpleServiceImplV3</span><span class="p">.</span><span class="n">class</span><span class="p">);</span>
        <span class="n">b3_1</span><span class="p">.</span><span class="n">printVersion</span><span class="p">();</span>

        <span class="n">ISimpleService</span> <span class="n">b3_2</span> <span class="p">=</span> <span class="n">applicationContext</span><span class="p">.</span><span class="n">getBean</span><span class="p">(</span><span class="s2">"SimpleServiceV3"</span><span class="p">,</span> <span class="n">SimpleServiceImplV3</span><span class="p">.</span><span class="n">class</span><span class="p">);</span>
        <span class="n">b3_2</span><span class="p">.</span><span class="n">printVersion</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="highlighter-rouge">SimpleServiceImplV1</code> 클래스와 같이 이름을 지정하지 않은 경우 클래스명의 첫번째 문자를 소문자로 변경하고, Camel Case화 시켜서 이름으로 간주한다.</p>

<p><code class="highlighter-rouge">SimpleServiceImplV2</code> 클래스와 같이 이름을 명시적으로 지정하는 경우, 해당 이름을 사용하여 Bean을 찾을 수 있다.</p>

<p><code class="highlighter-rouge">SimpleServiceImplV3</code> 클래스의 경우 다른 클래스와 달리 팩토리 메서드로 생성했으며, <code class="highlighter-rouge">@Bean</code> 어노테이션이 사용되었다. <code class="highlighter-rouge">@Bean</code> 어노테이션의 경우 1개 이상의 이름을 지정할 수 있도록 되어 있다. 때문에 NewSimpleService, SimpleServiceV3 등으로 Bean을 접근하여도 동일한 Bean이 반환되는 것을 확인할 수 있다.</p>

<p><code class="highlighter-rouge">@Bean</code> 어노테이션의 name이 아래와 같이 지정되어 있기 때문에 1개 이상의 식별자를 사용할 수 있는 것으로 보인다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/**
 * The name of this bean, or if several names, a primary bean name plus aliases.
 * &lt;p&gt;If left unspecified, the name of the bean is the name of the annotated method.
 * If specified, the method name is ignored.
 * &lt;p&gt;The bean name and aliases may also be configured via the {@link #value}
 * attribute if no other attributes are declared.
 * @see #value
 */
@AliasFor("value")
String[] name() default {};
</code></pre></div></div>


</div>

<div class="pagination">
  
    <a href="/2019-06-22/streaming-101" class="left arrow">&#8592;</a>
  
  
    <a href="/2019-05-06/spring-with-docker-1" class="right arrow">&#8594;</a>
  

  <a href="#" class="top">Top</a>
</div>

    </main>

    <footer>
  <span>
    &copy; <time datetime="2019-11-05 21:14:23 +0900">2019</time> leeyh0216. Made with Jekyll using the <a href="https://github.com/chesterhow/tale/">Tale</a> theme.
  </span>
</footer>

  </body>
</html>
