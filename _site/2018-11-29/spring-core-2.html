<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Spring Core Technologies - The IoC Container(2) | leeyh0216’s devlog</title>
<meta name="generator" content="Jekyll v3.8.6" />
<meta property="og:title" content="Spring Core Technologies - The IoC Container(2)" />
<meta name="author" content="leeyh0216" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="The IoC Container Introduction to the Spring IoC Container and Beans Bean 선언 시의 Interface 활용 Bean 객체를 초기화하여 반환하는 메소드(@Bean 어노테이션이 붙은) 만들어 ApplicationContext에서 찾아 사용하는 예제를 이전 글에서 만들어 보았다. 해당 예제에서는 초기화하여 반환하는 객체의 타입과 반환 타입이 완전히 일치했는데, 반환 타입은 구체화된 클래스가 아닌 Interface 혹은 Abstract Class로 설정할 수 있다. 먼저 아래와 같이 하위 클래스가 구현해야하는 인터페이스를 만든다. package com.leeyh0216.springstudy.interfacebean; public interface IMyService { void printServiceName(); } 위의 인터페이스를 상속한 MyServiceV1을 구현한다. package com.leeyh0216.springstudy.interfacebean; public class MyServiceV1 implements IMyService { private static final String SERVICE_NAME = &quot;MY_SERVICE_V1&quot;; public MyServiceV1(){ } @Override public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } 그 후, IMyService Bean을 초기화할 Configuration 클래스와 메서드를 아래와 같이 구현한다. package com.leeyh0216.springstudy.interfacebean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class AppConfig { @Bean public IMyService getMyService(){ return new MyServiceV1(); } } 위 getMyService 함수에서 반환 형은 IMyService이지만, 실제 반환되는 객체는 IMyService를 상속한 클래스인 MyServiceV1의 객체인 것을 확인할 수 있다. 이를 테스트하는 Application 클래스를 아래와 같이 생성한다. package com.leeyh0216.springstudy.interfacebean; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); IMyService myService = applicationContext.getBean(IMyService.class); myService.printServiceName(); } } 실행 결과는 아래와 같다. 21:12:32.878 [main] DEBUG org.springframework.core.env.StandardEnvironment - Adding [systemProperties] PropertySource with lowest search precedence 21:12:32.886 [main] DEBUG org.springframework.core.env.StandardEnvironment - Adding [systemEnvironment] PropertySource with lowest search precedence ...생략 21:12:33.427 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Returning cached instance of singleton bean &#39;getMyService&#39; My Service: MY_SERVICE_V1 위 코드의 장점은 무엇일까? 인터페이스 기반으로 작성되었기 때문에, 추후 기능 개선 혹은 추가를 위해 새로운 버전의 클래스인 MyServiceV2를 만들었을 때, Bean을 반환하는 메소드의 초기화 부분만을 수정하면, 이외의 코드는 수정하지 않고 그대로 사용할 수 있다. 아래와 같이 MyServiceV2를 IMyService 인터페이스를 상속받아 구현하고, package com.leeyh0216.springstudy.interfacebean; public class MyServiceV2 implements IMyService { private static final String SERVICE_NAME = &quot;MY_SERVICE_V2&quot;; public MyServiceV2(){ } @Override public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } 아래와 같이 Configuration 클래스의 getMyService 메소드만 살짝 수정해주면 package com.leeyh0216.springstudy.interfacebean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class AppConfig { @Bean public IMyService getMyService(){ return new MyServiceV2(); } } 동일한 Application를 실행했을 때, 아래와 같이 다른 코드의 수정 없이도 정상적으로 동작하는 것을 확인할 수 있다. 21:21:04.147 [main] DEBUG org.springframework.core.env.StandardEnvironment - Adding [systemProperties] PropertySource with lowest search precedence 21:21:04.157 [main] DEBUG org.springframework.core.env.StandardEnvironment - Adding [systemEnvironment] PropertySource with lowest search precedence ...생략 21:21:04.929 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Returning cached instance of singleton bean &#39;getMyService&#39; My Service: MY_SERVICE_V2 여러 개의 인터페이스를 구현한 하나의 클래스를 통해 초기화된 객체 아래와 같이 2개의 인터페이스(IMyService, IAnotherService)와 이 둘을 구현한 MyService 클래스가 있다고 생각해보자. package com.leeyh0216.springstudy.manyinterfacebean; public interface IMyService { void printServiceName(); } package com.leeyh0216.springstudy.manyinterfacebean; public interface IAnotherService { void printAnotherName(); } package com.leeyh0216.springstudy.manyinterfacebean; public class MyServiceV1 implements IMyService, IAnotherService { private static final String SERVICE_NAME = &quot;MY_SERVICE_V1&quot;; public MyServiceV1(){ } @Override public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } @Override public void printAnotherName() { System.out.println(String.format(&quot;I also implement %s&quot;, IAnotherService.class.getName()));} } Configuration 클래스는 어떻게 구성해야 할까? 일단 아래와 같이 각각 IMyService, IAnotherService 를 반환타입으로 가지는 메서드를 포함한 Configuration 클래스를 만들어 보았다. package com.leeyh0216.springstudy.manyinterfacebean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class AppConfig { private static final MyServiceV1 myService = new MyServiceV1(); @Bean public IMyService getMyService(){ return myService; } @Bean public IAnotherService getAnotherService(){ return myService; } } 테스트를 위해 아래와 같이 IMyService, IAnotherService 타입의 Bean을 ApplicationContext로부터 가져오려 했지만, package com.leeyh0216.springstudy.manyinterfacebean; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); IMyService myService = applicationContext.getBean(IMyService.class); IAnotherService anotherService = applicationContext.getBean(IAnotherService.class); myService.printServiceName(); anotherService.printAnotherName(); System.out.println(myService == anotherService); } } 다음과 같은 오류 메시지가 발생하며 실행에 실패하는 것을 확인할 수 있었다. Exception in thread &quot;main&quot; org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type &#39;com.leeyh0216.springstudy.manyinterfacebean.IMyService&#39; available: expected single matching bean but found 2: getMyService,getAnotherService at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveNamedBean(DefaultListableBeanFactory.java:1041) at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:345) ...생략 IMyService 타입의 Bean에 만족하는 Bean이 getMyService와 getAnotherService 2개가 발견되었다는 메시지가 발생한다. 분명 getAnotherService 함수는 IAnotherService 인터페이스를 반환했는데도 이러한 오류가 발생하는 것을 확인할 수 있었다. Stacktrace 첫번째 라인의 함수의 2번째 줄을 보면, String[] candidateNames = getBeanNamesForType(requiredType); 와 같이, Application에 등록된 Bean 중 우리가 인자로 전달한 IMyService 타입을 가진 Bean을 반환하는 getBeanNamesForType을 반환하는 것을 볼 수 있으며, 실제 오류가 나는 부분을 보면 private &lt;T&gt; NamedBeanHolder&lt;T&gt; resolveNamedBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException { Assert.notNull(requiredType, &quot;Required type must not be null&quot;); String[] candidateNames = getBeanNamesForType(requiredType); if (candidateNames.length &gt; 1) { List&lt;String&gt; autowireCandidates = new ArrayList&lt;String&gt;(candidateNames.length); for (String beanName : candidateNames) { if (!containsBeanDefinition(beanName) || getBeanDefinition(beanName).isAutowireCandidate()) { autowireCandidates.add(beanName); } } if (!autowireCandidates.isEmpty()) { candidateNames = autowireCandidates.toArray(new String[autowireCandidates.size()]); } } if (candidateNames.length == 1) { String beanName = candidateNames[0]; return new NamedBeanHolder&lt;T&gt;(beanName, getBean(beanName, requiredType, args)); } else if (candidateNames.length &gt; 1) { Map&lt;String, Object&gt; candidates = new LinkedHashMap&lt;String, Object&gt;(candidateNames.length); for (String beanName : candidateNames) { if (containsSingleton(beanName)) { candidates.put(beanName, getBean(beanName, requiredType, args)); } else { candidates.put(beanName, getType(beanName)); } } String candidateName = determinePrimaryCandidate(candidates, requiredType); if (candidateName == null) { candidateName = determineHighestPriorityCandidate(candidates, requiredType); } if (candidateName != null) { Object beanInstance = candidates.get(candidateName); if (beanInstance instanceof Class) { beanInstance = getBean(candidateName, requiredType, args); } return new NamedBeanHolder&lt;T&gt;(candidateName, (T) beanInstance); } throw new NoUniqueBeanDefinitionException(requiredType, candidates.keySet()); } return null; } 거의 맨 아랫줄의 throw new NoUniqueBeanDefinitionException에서 발생하는 것을 확인할 수 있다. 원인은 위 함수의 거의 맨 윗 줄에 있는 String[] candidateNames = getBeanNamesForType(requiredType); 의 getBeanNamesForType 함수이다. 이 함수는 org.springframework.beans.factory 패키지에 선언된 ListableBeanFactory의 getBeanNamesForType을 구현한 것인데, 해당 함수는 아래와 같이 설명되어 있다. 주어진 타입(SubClass를 포함하여)과 일치하는 Bean 목록을 반환합니다. SubClass를 포함했다는 사실이 매우 중요하다. 우리가 IMyService를 반환하는 getMyService와 IAnotherService를 반환하는 getAnotherService를 구현했어도, 결과적으로 반환되는 객체는 MyService 타입이다. 즉, IMyService 클래스를 getBeanNamesForType에 넘긴다 해도 구체화 클래스인 MyService 클래스의 객체인 getMyService Bean과 getAnotherService Bean이 반환된다. 두 개의 Bean을 반환할 수는 없기 때문에, Springframework에서 제시하는 기준에 맞춰지는 Bean을 반환하려고 candidate를 찾는 과정이 위의 resolveNamedBean 메소드에 구현되어 있는데, getBeanNamesForType에서 반환한 Bean 이름이 1개인 경우 해당 이름을 가진 Bean을 반환 getBeanNamesForType에서 반환한 Bean 이름이 여러개인 경우 @Primiary 어노테이션 등을 통해 Bean의 우선 순위를 지정한 경우 가장 높은 우선순위를 가지는 Bean을 반환 우선 순위가 명확하지 않은 경우 NoUniqueBeanDefinitionException 예외를 throw 와 같은 과정을 가지고 있다. 위 과정을 우리의 코드에 적용해보자면 선택지는 3개가 된다. Class가 아닌 Bean 이름을 통해 Bean을 선택하는 방법 IMyService, IAnotherService를 모두를 상속받는 인터페이스를 MyService 클래스가 구현하여 Bean을 1개로 만드는 방법 @Primary와 같은 우선순위 어노테이션을 이용하여 우선순위에 따라 선택되게 만드는 방법 각 방법을 테스트해보도록 하겠다. Class가 아닌 Bean 이름을 통해 Bean을 선택하는 방법 아래와 같이 기존에 getBean의 인자를 Class를 전달했던 방식에서 실제 Bean 이름을 전달하는 방식으로 변경한다. package com.leeyh0216.springstudy.manyinterfacebean; import org.springframework.beans.factory.NoUniqueBeanDefinitionException; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); System.out.println(applicationContext.getBeanNamesForType(IMyService.class).length); IMyService myService = (IMyService)applicationContext.getBean(&quot;getMyService&quot;); IAnotherService anotherService = (IAnotherService)applicationContext.getBean(&quot;getAnotherService&quot;); myService.printServiceName(); anotherService.printAnotherName(); System.out.println(myService == anotherService); } } 이 경우 또한 ApplicationContext에 getMyService와 getAnotherService Bean 모두가 등록되어 있지만 getMyService 이름을 가진 Bean만을 가져오기 때문에 위와 같은 오류가 발생하지 않는 것이다. IMyService, IAnotherService 를 상속받은 인터페이스를 MyService가 구현하는 방법 아래와 같이 IMyService, IAnotherService를 상속하는 ITotalService 인터페이스를 만든다. package com.leeyh0216.springstudy.manyinterfacebean; public interface ITotalService extends IMyService, IAnotherService{ } 그 후 MyService가 해당 Interface를 구현하도록 한다. package com.leeyh0216.springstudy.manyinterfacebean; public class MyServiceV1 implements ITotalService { private static final String SERVICE_NAME = &quot;MY_SERVICE_V1&quot;; public MyServiceV1(){ } @Override public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } @Override public void printAnotherName() { System.out.println(String.format(&quot;I also implement %s&quot;, IAnotherService.class.getName()));} } 또한 Configuration 클래스 또한 아래와 같이 ITotalService를 반환하도록 수정해주고 package com.leeyh0216.springstudy.manyinterfacebean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class AppConfig { @Bean public ITotalService getTotalService(){ return new MyServiceV1(); } } main 함수 또한 아래와 같이 IMyService, IAnotherService를 따로 가져오는 것이 아닌 ITotalService 하나만을 가져오도록 수정하면 정상적으로 동작하는 것을 확인할 수 있다. package com.leeyh0216.springstudy.manyinterfacebean; import org.springframework.beans.factory.NoUniqueBeanDefinitionException; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); ITotalService totalService = applicationContext.getBean(ITotalService.class); totalService.printServiceName(); totalService.printAnotherName(); } } 이 경우는 Bean은 1개가 등록되어 있고, 타입에 따라 가져올 수 있도록 구현된 경우이다. @Primary 어노테이션을 이용하여 우선순위에 따라 선택되게 만드는 방법 우선 MyService 클래스를 아래와 같이 수정하여, getMyService와 getAnotherService에서 반환되는 객체를 구분할 수 있도록 하자. package com.leeyh0216.springstudy.manyinterfacebean; public class MyServiceV1 implements IMyService, IAnotherService { private String serviceName; public MyServiceV1(String serviceName){ this.serviceName = serviceName; } @Override public void printServiceName(){ System.out.println(&quot;My Service: &quot; + serviceName); } @Override public void printAnotherName() { System.out.println(String.format(&quot;I also implement %s&quot;, IAnotherService.class.getName()));} } Configuration 클래스의 getMyService 메서드에 아래와 같이 @Primary 어노테이션을 붙여준다. 또한 두 객체를 구분할 수 있도록 생성자에 각각 “primary”와 “no priority”를 넣어준다. package com.leeyh0216.springstudy.manyinterfacebean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Primary; @Configuration public class AppConfig { @Primary @Bean public IMyService getMyService(){ return new MyServiceV1(&quot;primary&quot;); } @Bean public IAnotherService getAnotherService(){ return new MyServiceV1(&quot;no priority&quot;); } } 그 후 main 함수를 아래와 같이 작성하여 돌려보면 getMyService 메서드에서 반환한 Bean이 우선적으로 선택되는 것을 볼 수 있다. package com.leeyh0216.springstudy.manyinterfacebean; import org.springframework.beans.factory.NoUniqueBeanDefinitionException; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); IMyService myService = applicationContext.getBean(IMyService.class); IAnotherService anotherService = applicationContext.getBean(IAnotherService.class); myService.printServiceName(); anotherService.printAnotherName(); System.out.println(myService == anotherService); } } 이 경우 또한 ApplicationContext에 getMyService와 getAnotherService Bean 모두가 등록되어 있지만 우선순위에 의해 1개만 선택되는 경우이다. 여기까지 Interface 타입을 활용하는 방법과, Bean의 우선순위에 대해 알아보았다." />
<meta property="og:description" content="The IoC Container Introduction to the Spring IoC Container and Beans Bean 선언 시의 Interface 활용 Bean 객체를 초기화하여 반환하는 메소드(@Bean 어노테이션이 붙은) 만들어 ApplicationContext에서 찾아 사용하는 예제를 이전 글에서 만들어 보았다. 해당 예제에서는 초기화하여 반환하는 객체의 타입과 반환 타입이 완전히 일치했는데, 반환 타입은 구체화된 클래스가 아닌 Interface 혹은 Abstract Class로 설정할 수 있다. 먼저 아래와 같이 하위 클래스가 구현해야하는 인터페이스를 만든다. package com.leeyh0216.springstudy.interfacebean; public interface IMyService { void printServiceName(); } 위의 인터페이스를 상속한 MyServiceV1을 구현한다. package com.leeyh0216.springstudy.interfacebean; public class MyServiceV1 implements IMyService { private static final String SERVICE_NAME = &quot;MY_SERVICE_V1&quot;; public MyServiceV1(){ } @Override public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } 그 후, IMyService Bean을 초기화할 Configuration 클래스와 메서드를 아래와 같이 구현한다. package com.leeyh0216.springstudy.interfacebean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class AppConfig { @Bean public IMyService getMyService(){ return new MyServiceV1(); } } 위 getMyService 함수에서 반환 형은 IMyService이지만, 실제 반환되는 객체는 IMyService를 상속한 클래스인 MyServiceV1의 객체인 것을 확인할 수 있다. 이를 테스트하는 Application 클래스를 아래와 같이 생성한다. package com.leeyh0216.springstudy.interfacebean; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); IMyService myService = applicationContext.getBean(IMyService.class); myService.printServiceName(); } } 실행 결과는 아래와 같다. 21:12:32.878 [main] DEBUG org.springframework.core.env.StandardEnvironment - Adding [systemProperties] PropertySource with lowest search precedence 21:12:32.886 [main] DEBUG org.springframework.core.env.StandardEnvironment - Adding [systemEnvironment] PropertySource with lowest search precedence ...생략 21:12:33.427 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Returning cached instance of singleton bean &#39;getMyService&#39; My Service: MY_SERVICE_V1 위 코드의 장점은 무엇일까? 인터페이스 기반으로 작성되었기 때문에, 추후 기능 개선 혹은 추가를 위해 새로운 버전의 클래스인 MyServiceV2를 만들었을 때, Bean을 반환하는 메소드의 초기화 부분만을 수정하면, 이외의 코드는 수정하지 않고 그대로 사용할 수 있다. 아래와 같이 MyServiceV2를 IMyService 인터페이스를 상속받아 구현하고, package com.leeyh0216.springstudy.interfacebean; public class MyServiceV2 implements IMyService { private static final String SERVICE_NAME = &quot;MY_SERVICE_V2&quot;; public MyServiceV2(){ } @Override public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } 아래와 같이 Configuration 클래스의 getMyService 메소드만 살짝 수정해주면 package com.leeyh0216.springstudy.interfacebean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class AppConfig { @Bean public IMyService getMyService(){ return new MyServiceV2(); } } 동일한 Application를 실행했을 때, 아래와 같이 다른 코드의 수정 없이도 정상적으로 동작하는 것을 확인할 수 있다. 21:21:04.147 [main] DEBUG org.springframework.core.env.StandardEnvironment - Adding [systemProperties] PropertySource with lowest search precedence 21:21:04.157 [main] DEBUG org.springframework.core.env.StandardEnvironment - Adding [systemEnvironment] PropertySource with lowest search precedence ...생략 21:21:04.929 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Returning cached instance of singleton bean &#39;getMyService&#39; My Service: MY_SERVICE_V2 여러 개의 인터페이스를 구현한 하나의 클래스를 통해 초기화된 객체 아래와 같이 2개의 인터페이스(IMyService, IAnotherService)와 이 둘을 구현한 MyService 클래스가 있다고 생각해보자. package com.leeyh0216.springstudy.manyinterfacebean; public interface IMyService { void printServiceName(); } package com.leeyh0216.springstudy.manyinterfacebean; public interface IAnotherService { void printAnotherName(); } package com.leeyh0216.springstudy.manyinterfacebean; public class MyServiceV1 implements IMyService, IAnotherService { private static final String SERVICE_NAME = &quot;MY_SERVICE_V1&quot;; public MyServiceV1(){ } @Override public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } @Override public void printAnotherName() { System.out.println(String.format(&quot;I also implement %s&quot;, IAnotherService.class.getName()));} } Configuration 클래스는 어떻게 구성해야 할까? 일단 아래와 같이 각각 IMyService, IAnotherService 를 반환타입으로 가지는 메서드를 포함한 Configuration 클래스를 만들어 보았다. package com.leeyh0216.springstudy.manyinterfacebean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class AppConfig { private static final MyServiceV1 myService = new MyServiceV1(); @Bean public IMyService getMyService(){ return myService; } @Bean public IAnotherService getAnotherService(){ return myService; } } 테스트를 위해 아래와 같이 IMyService, IAnotherService 타입의 Bean을 ApplicationContext로부터 가져오려 했지만, package com.leeyh0216.springstudy.manyinterfacebean; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); IMyService myService = applicationContext.getBean(IMyService.class); IAnotherService anotherService = applicationContext.getBean(IAnotherService.class); myService.printServiceName(); anotherService.printAnotherName(); System.out.println(myService == anotherService); } } 다음과 같은 오류 메시지가 발생하며 실행에 실패하는 것을 확인할 수 있었다. Exception in thread &quot;main&quot; org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type &#39;com.leeyh0216.springstudy.manyinterfacebean.IMyService&#39; available: expected single matching bean but found 2: getMyService,getAnotherService at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveNamedBean(DefaultListableBeanFactory.java:1041) at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:345) ...생략 IMyService 타입의 Bean에 만족하는 Bean이 getMyService와 getAnotherService 2개가 발견되었다는 메시지가 발생한다. 분명 getAnotherService 함수는 IAnotherService 인터페이스를 반환했는데도 이러한 오류가 발생하는 것을 확인할 수 있었다. Stacktrace 첫번째 라인의 함수의 2번째 줄을 보면, String[] candidateNames = getBeanNamesForType(requiredType); 와 같이, Application에 등록된 Bean 중 우리가 인자로 전달한 IMyService 타입을 가진 Bean을 반환하는 getBeanNamesForType을 반환하는 것을 볼 수 있으며, 실제 오류가 나는 부분을 보면 private &lt;T&gt; NamedBeanHolder&lt;T&gt; resolveNamedBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException { Assert.notNull(requiredType, &quot;Required type must not be null&quot;); String[] candidateNames = getBeanNamesForType(requiredType); if (candidateNames.length &gt; 1) { List&lt;String&gt; autowireCandidates = new ArrayList&lt;String&gt;(candidateNames.length); for (String beanName : candidateNames) { if (!containsBeanDefinition(beanName) || getBeanDefinition(beanName).isAutowireCandidate()) { autowireCandidates.add(beanName); } } if (!autowireCandidates.isEmpty()) { candidateNames = autowireCandidates.toArray(new String[autowireCandidates.size()]); } } if (candidateNames.length == 1) { String beanName = candidateNames[0]; return new NamedBeanHolder&lt;T&gt;(beanName, getBean(beanName, requiredType, args)); } else if (candidateNames.length &gt; 1) { Map&lt;String, Object&gt; candidates = new LinkedHashMap&lt;String, Object&gt;(candidateNames.length); for (String beanName : candidateNames) { if (containsSingleton(beanName)) { candidates.put(beanName, getBean(beanName, requiredType, args)); } else { candidates.put(beanName, getType(beanName)); } } String candidateName = determinePrimaryCandidate(candidates, requiredType); if (candidateName == null) { candidateName = determineHighestPriorityCandidate(candidates, requiredType); } if (candidateName != null) { Object beanInstance = candidates.get(candidateName); if (beanInstance instanceof Class) { beanInstance = getBean(candidateName, requiredType, args); } return new NamedBeanHolder&lt;T&gt;(candidateName, (T) beanInstance); } throw new NoUniqueBeanDefinitionException(requiredType, candidates.keySet()); } return null; } 거의 맨 아랫줄의 throw new NoUniqueBeanDefinitionException에서 발생하는 것을 확인할 수 있다. 원인은 위 함수의 거의 맨 윗 줄에 있는 String[] candidateNames = getBeanNamesForType(requiredType); 의 getBeanNamesForType 함수이다. 이 함수는 org.springframework.beans.factory 패키지에 선언된 ListableBeanFactory의 getBeanNamesForType을 구현한 것인데, 해당 함수는 아래와 같이 설명되어 있다. 주어진 타입(SubClass를 포함하여)과 일치하는 Bean 목록을 반환합니다. SubClass를 포함했다는 사실이 매우 중요하다. 우리가 IMyService를 반환하는 getMyService와 IAnotherService를 반환하는 getAnotherService를 구현했어도, 결과적으로 반환되는 객체는 MyService 타입이다. 즉, IMyService 클래스를 getBeanNamesForType에 넘긴다 해도 구체화 클래스인 MyService 클래스의 객체인 getMyService Bean과 getAnotherService Bean이 반환된다. 두 개의 Bean을 반환할 수는 없기 때문에, Springframework에서 제시하는 기준에 맞춰지는 Bean을 반환하려고 candidate를 찾는 과정이 위의 resolveNamedBean 메소드에 구현되어 있는데, getBeanNamesForType에서 반환한 Bean 이름이 1개인 경우 해당 이름을 가진 Bean을 반환 getBeanNamesForType에서 반환한 Bean 이름이 여러개인 경우 @Primiary 어노테이션 등을 통해 Bean의 우선 순위를 지정한 경우 가장 높은 우선순위를 가지는 Bean을 반환 우선 순위가 명확하지 않은 경우 NoUniqueBeanDefinitionException 예외를 throw 와 같은 과정을 가지고 있다. 위 과정을 우리의 코드에 적용해보자면 선택지는 3개가 된다. Class가 아닌 Bean 이름을 통해 Bean을 선택하는 방법 IMyService, IAnotherService를 모두를 상속받는 인터페이스를 MyService 클래스가 구현하여 Bean을 1개로 만드는 방법 @Primary와 같은 우선순위 어노테이션을 이용하여 우선순위에 따라 선택되게 만드는 방법 각 방법을 테스트해보도록 하겠다. Class가 아닌 Bean 이름을 통해 Bean을 선택하는 방법 아래와 같이 기존에 getBean의 인자를 Class를 전달했던 방식에서 실제 Bean 이름을 전달하는 방식으로 변경한다. package com.leeyh0216.springstudy.manyinterfacebean; import org.springframework.beans.factory.NoUniqueBeanDefinitionException; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); System.out.println(applicationContext.getBeanNamesForType(IMyService.class).length); IMyService myService = (IMyService)applicationContext.getBean(&quot;getMyService&quot;); IAnotherService anotherService = (IAnotherService)applicationContext.getBean(&quot;getAnotherService&quot;); myService.printServiceName(); anotherService.printAnotherName(); System.out.println(myService == anotherService); } } 이 경우 또한 ApplicationContext에 getMyService와 getAnotherService Bean 모두가 등록되어 있지만 getMyService 이름을 가진 Bean만을 가져오기 때문에 위와 같은 오류가 발생하지 않는 것이다. IMyService, IAnotherService 를 상속받은 인터페이스를 MyService가 구현하는 방법 아래와 같이 IMyService, IAnotherService를 상속하는 ITotalService 인터페이스를 만든다. package com.leeyh0216.springstudy.manyinterfacebean; public interface ITotalService extends IMyService, IAnotherService{ } 그 후 MyService가 해당 Interface를 구현하도록 한다. package com.leeyh0216.springstudy.manyinterfacebean; public class MyServiceV1 implements ITotalService { private static final String SERVICE_NAME = &quot;MY_SERVICE_V1&quot;; public MyServiceV1(){ } @Override public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } @Override public void printAnotherName() { System.out.println(String.format(&quot;I also implement %s&quot;, IAnotherService.class.getName()));} } 또한 Configuration 클래스 또한 아래와 같이 ITotalService를 반환하도록 수정해주고 package com.leeyh0216.springstudy.manyinterfacebean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class AppConfig { @Bean public ITotalService getTotalService(){ return new MyServiceV1(); } } main 함수 또한 아래와 같이 IMyService, IAnotherService를 따로 가져오는 것이 아닌 ITotalService 하나만을 가져오도록 수정하면 정상적으로 동작하는 것을 확인할 수 있다. package com.leeyh0216.springstudy.manyinterfacebean; import org.springframework.beans.factory.NoUniqueBeanDefinitionException; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); ITotalService totalService = applicationContext.getBean(ITotalService.class); totalService.printServiceName(); totalService.printAnotherName(); } } 이 경우는 Bean은 1개가 등록되어 있고, 타입에 따라 가져올 수 있도록 구현된 경우이다. @Primary 어노테이션을 이용하여 우선순위에 따라 선택되게 만드는 방법 우선 MyService 클래스를 아래와 같이 수정하여, getMyService와 getAnotherService에서 반환되는 객체를 구분할 수 있도록 하자. package com.leeyh0216.springstudy.manyinterfacebean; public class MyServiceV1 implements IMyService, IAnotherService { private String serviceName; public MyServiceV1(String serviceName){ this.serviceName = serviceName; } @Override public void printServiceName(){ System.out.println(&quot;My Service: &quot; + serviceName); } @Override public void printAnotherName() { System.out.println(String.format(&quot;I also implement %s&quot;, IAnotherService.class.getName()));} } Configuration 클래스의 getMyService 메서드에 아래와 같이 @Primary 어노테이션을 붙여준다. 또한 두 객체를 구분할 수 있도록 생성자에 각각 “primary”와 “no priority”를 넣어준다. package com.leeyh0216.springstudy.manyinterfacebean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Primary; @Configuration public class AppConfig { @Primary @Bean public IMyService getMyService(){ return new MyServiceV1(&quot;primary&quot;); } @Bean public IAnotherService getAnotherService(){ return new MyServiceV1(&quot;no priority&quot;); } } 그 후 main 함수를 아래와 같이 작성하여 돌려보면 getMyService 메서드에서 반환한 Bean이 우선적으로 선택되는 것을 볼 수 있다. package com.leeyh0216.springstudy.manyinterfacebean; import org.springframework.beans.factory.NoUniqueBeanDefinitionException; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); IMyService myService = applicationContext.getBean(IMyService.class); IAnotherService anotherService = applicationContext.getBean(IAnotherService.class); myService.printServiceName(); anotherService.printAnotherName(); System.out.println(myService == anotherService); } } 이 경우 또한 ApplicationContext에 getMyService와 getAnotherService Bean 모두가 등록되어 있지만 우선순위에 의해 1개만 선택되는 경우이다. 여기까지 Interface 타입을 활용하는 방법과, Bean의 우선순위에 대해 알아보았다." />
<link rel="canonical" href="http://localhost:4000/2018-11-29/spring-core-2" />
<meta property="og:url" content="http://localhost:4000/2018-11-29/spring-core-2" />
<meta property="og:site_name" content="leeyh0216’s devlog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-11-29T21:00:00+09:00" />
<script type="application/ld+json">
{"headline":"Spring Core Technologies - The IoC Container(2)","dateModified":"2018-11-29T21:00:00+09:00","datePublished":"2018-11-29T21:00:00+09:00","url":"http://localhost:4000/2018-11-29/spring-core-2","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2018-11-29/spring-core-2"},"author":{"@type":"Person","name":"leeyh0216"},"description":"The IoC Container Introduction to the Spring IoC Container and Beans Bean 선언 시의 Interface 활용 Bean 객체를 초기화하여 반환하는 메소드(@Bean 어노테이션이 붙은) 만들어 ApplicationContext에서 찾아 사용하는 예제를 이전 글에서 만들어 보았다. 해당 예제에서는 초기화하여 반환하는 객체의 타입과 반환 타입이 완전히 일치했는데, 반환 타입은 구체화된 클래스가 아닌 Interface 혹은 Abstract Class로 설정할 수 있다. 먼저 아래와 같이 하위 클래스가 구현해야하는 인터페이스를 만든다. package com.leeyh0216.springstudy.interfacebean; public interface IMyService { void printServiceName(); } 위의 인터페이스를 상속한 MyServiceV1을 구현한다. package com.leeyh0216.springstudy.interfacebean; public class MyServiceV1 implements IMyService { private static final String SERVICE_NAME = &quot;MY_SERVICE_V1&quot;; public MyServiceV1(){ } @Override public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } 그 후, IMyService Bean을 초기화할 Configuration 클래스와 메서드를 아래와 같이 구현한다. package com.leeyh0216.springstudy.interfacebean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class AppConfig { @Bean public IMyService getMyService(){ return new MyServiceV1(); } } 위 getMyService 함수에서 반환 형은 IMyService이지만, 실제 반환되는 객체는 IMyService를 상속한 클래스인 MyServiceV1의 객체인 것을 확인할 수 있다. 이를 테스트하는 Application 클래스를 아래와 같이 생성한다. package com.leeyh0216.springstudy.interfacebean; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); IMyService myService = applicationContext.getBean(IMyService.class); myService.printServiceName(); } } 실행 결과는 아래와 같다. 21:12:32.878 [main] DEBUG org.springframework.core.env.StandardEnvironment - Adding [systemProperties] PropertySource with lowest search precedence 21:12:32.886 [main] DEBUG org.springframework.core.env.StandardEnvironment - Adding [systemEnvironment] PropertySource with lowest search precedence ...생략 21:12:33.427 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Returning cached instance of singleton bean &#39;getMyService&#39; My Service: MY_SERVICE_V1 위 코드의 장점은 무엇일까? 인터페이스 기반으로 작성되었기 때문에, 추후 기능 개선 혹은 추가를 위해 새로운 버전의 클래스인 MyServiceV2를 만들었을 때, Bean을 반환하는 메소드의 초기화 부분만을 수정하면, 이외의 코드는 수정하지 않고 그대로 사용할 수 있다. 아래와 같이 MyServiceV2를 IMyService 인터페이스를 상속받아 구현하고, package com.leeyh0216.springstudy.interfacebean; public class MyServiceV2 implements IMyService { private static final String SERVICE_NAME = &quot;MY_SERVICE_V2&quot;; public MyServiceV2(){ } @Override public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } 아래와 같이 Configuration 클래스의 getMyService 메소드만 살짝 수정해주면 package com.leeyh0216.springstudy.interfacebean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class AppConfig { @Bean public IMyService getMyService(){ return new MyServiceV2(); } } 동일한 Application를 실행했을 때, 아래와 같이 다른 코드의 수정 없이도 정상적으로 동작하는 것을 확인할 수 있다. 21:21:04.147 [main] DEBUG org.springframework.core.env.StandardEnvironment - Adding [systemProperties] PropertySource with lowest search precedence 21:21:04.157 [main] DEBUG org.springframework.core.env.StandardEnvironment - Adding [systemEnvironment] PropertySource with lowest search precedence ...생략 21:21:04.929 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Returning cached instance of singleton bean &#39;getMyService&#39; My Service: MY_SERVICE_V2 여러 개의 인터페이스를 구현한 하나의 클래스를 통해 초기화된 객체 아래와 같이 2개의 인터페이스(IMyService, IAnotherService)와 이 둘을 구현한 MyService 클래스가 있다고 생각해보자. package com.leeyh0216.springstudy.manyinterfacebean; public interface IMyService { void printServiceName(); } package com.leeyh0216.springstudy.manyinterfacebean; public interface IAnotherService { void printAnotherName(); } package com.leeyh0216.springstudy.manyinterfacebean; public class MyServiceV1 implements IMyService, IAnotherService { private static final String SERVICE_NAME = &quot;MY_SERVICE_V1&quot;; public MyServiceV1(){ } @Override public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } @Override public void printAnotherName() { System.out.println(String.format(&quot;I also implement %s&quot;, IAnotherService.class.getName()));} } Configuration 클래스는 어떻게 구성해야 할까? 일단 아래와 같이 각각 IMyService, IAnotherService 를 반환타입으로 가지는 메서드를 포함한 Configuration 클래스를 만들어 보았다. package com.leeyh0216.springstudy.manyinterfacebean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class AppConfig { private static final MyServiceV1 myService = new MyServiceV1(); @Bean public IMyService getMyService(){ return myService; } @Bean public IAnotherService getAnotherService(){ return myService; } } 테스트를 위해 아래와 같이 IMyService, IAnotherService 타입의 Bean을 ApplicationContext로부터 가져오려 했지만, package com.leeyh0216.springstudy.manyinterfacebean; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); IMyService myService = applicationContext.getBean(IMyService.class); IAnotherService anotherService = applicationContext.getBean(IAnotherService.class); myService.printServiceName(); anotherService.printAnotherName(); System.out.println(myService == anotherService); } } 다음과 같은 오류 메시지가 발생하며 실행에 실패하는 것을 확인할 수 있었다. Exception in thread &quot;main&quot; org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type &#39;com.leeyh0216.springstudy.manyinterfacebean.IMyService&#39; available: expected single matching bean but found 2: getMyService,getAnotherService at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveNamedBean(DefaultListableBeanFactory.java:1041) at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:345) ...생략 IMyService 타입의 Bean에 만족하는 Bean이 getMyService와 getAnotherService 2개가 발견되었다는 메시지가 발생한다. 분명 getAnotherService 함수는 IAnotherService 인터페이스를 반환했는데도 이러한 오류가 발생하는 것을 확인할 수 있었다. Stacktrace 첫번째 라인의 함수의 2번째 줄을 보면, String[] candidateNames = getBeanNamesForType(requiredType); 와 같이, Application에 등록된 Bean 중 우리가 인자로 전달한 IMyService 타입을 가진 Bean을 반환하는 getBeanNamesForType을 반환하는 것을 볼 수 있으며, 실제 오류가 나는 부분을 보면 private &lt;T&gt; NamedBeanHolder&lt;T&gt; resolveNamedBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException { Assert.notNull(requiredType, &quot;Required type must not be null&quot;); String[] candidateNames = getBeanNamesForType(requiredType); if (candidateNames.length &gt; 1) { List&lt;String&gt; autowireCandidates = new ArrayList&lt;String&gt;(candidateNames.length); for (String beanName : candidateNames) { if (!containsBeanDefinition(beanName) || getBeanDefinition(beanName).isAutowireCandidate()) { autowireCandidates.add(beanName); } } if (!autowireCandidates.isEmpty()) { candidateNames = autowireCandidates.toArray(new String[autowireCandidates.size()]); } } if (candidateNames.length == 1) { String beanName = candidateNames[0]; return new NamedBeanHolder&lt;T&gt;(beanName, getBean(beanName, requiredType, args)); } else if (candidateNames.length &gt; 1) { Map&lt;String, Object&gt; candidates = new LinkedHashMap&lt;String, Object&gt;(candidateNames.length); for (String beanName : candidateNames) { if (containsSingleton(beanName)) { candidates.put(beanName, getBean(beanName, requiredType, args)); } else { candidates.put(beanName, getType(beanName)); } } String candidateName = determinePrimaryCandidate(candidates, requiredType); if (candidateName == null) { candidateName = determineHighestPriorityCandidate(candidates, requiredType); } if (candidateName != null) { Object beanInstance = candidates.get(candidateName); if (beanInstance instanceof Class) { beanInstance = getBean(candidateName, requiredType, args); } return new NamedBeanHolder&lt;T&gt;(candidateName, (T) beanInstance); } throw new NoUniqueBeanDefinitionException(requiredType, candidates.keySet()); } return null; } 거의 맨 아랫줄의 throw new NoUniqueBeanDefinitionException에서 발생하는 것을 확인할 수 있다. 원인은 위 함수의 거의 맨 윗 줄에 있는 String[] candidateNames = getBeanNamesForType(requiredType); 의 getBeanNamesForType 함수이다. 이 함수는 org.springframework.beans.factory 패키지에 선언된 ListableBeanFactory의 getBeanNamesForType을 구현한 것인데, 해당 함수는 아래와 같이 설명되어 있다. 주어진 타입(SubClass를 포함하여)과 일치하는 Bean 목록을 반환합니다. SubClass를 포함했다는 사실이 매우 중요하다. 우리가 IMyService를 반환하는 getMyService와 IAnotherService를 반환하는 getAnotherService를 구현했어도, 결과적으로 반환되는 객체는 MyService 타입이다. 즉, IMyService 클래스를 getBeanNamesForType에 넘긴다 해도 구체화 클래스인 MyService 클래스의 객체인 getMyService Bean과 getAnotherService Bean이 반환된다. 두 개의 Bean을 반환할 수는 없기 때문에, Springframework에서 제시하는 기준에 맞춰지는 Bean을 반환하려고 candidate를 찾는 과정이 위의 resolveNamedBean 메소드에 구현되어 있는데, getBeanNamesForType에서 반환한 Bean 이름이 1개인 경우 해당 이름을 가진 Bean을 반환 getBeanNamesForType에서 반환한 Bean 이름이 여러개인 경우 @Primiary 어노테이션 등을 통해 Bean의 우선 순위를 지정한 경우 가장 높은 우선순위를 가지는 Bean을 반환 우선 순위가 명확하지 않은 경우 NoUniqueBeanDefinitionException 예외를 throw 와 같은 과정을 가지고 있다. 위 과정을 우리의 코드에 적용해보자면 선택지는 3개가 된다. Class가 아닌 Bean 이름을 통해 Bean을 선택하는 방법 IMyService, IAnotherService를 모두를 상속받는 인터페이스를 MyService 클래스가 구현하여 Bean을 1개로 만드는 방법 @Primary와 같은 우선순위 어노테이션을 이용하여 우선순위에 따라 선택되게 만드는 방법 각 방법을 테스트해보도록 하겠다. Class가 아닌 Bean 이름을 통해 Bean을 선택하는 방법 아래와 같이 기존에 getBean의 인자를 Class를 전달했던 방식에서 실제 Bean 이름을 전달하는 방식으로 변경한다. package com.leeyh0216.springstudy.manyinterfacebean; import org.springframework.beans.factory.NoUniqueBeanDefinitionException; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); System.out.println(applicationContext.getBeanNamesForType(IMyService.class).length); IMyService myService = (IMyService)applicationContext.getBean(&quot;getMyService&quot;); IAnotherService anotherService = (IAnotherService)applicationContext.getBean(&quot;getAnotherService&quot;); myService.printServiceName(); anotherService.printAnotherName(); System.out.println(myService == anotherService); } } 이 경우 또한 ApplicationContext에 getMyService와 getAnotherService Bean 모두가 등록되어 있지만 getMyService 이름을 가진 Bean만을 가져오기 때문에 위와 같은 오류가 발생하지 않는 것이다. IMyService, IAnotherService 를 상속받은 인터페이스를 MyService가 구현하는 방법 아래와 같이 IMyService, IAnotherService를 상속하는 ITotalService 인터페이스를 만든다. package com.leeyh0216.springstudy.manyinterfacebean; public interface ITotalService extends IMyService, IAnotherService{ } 그 후 MyService가 해당 Interface를 구현하도록 한다. package com.leeyh0216.springstudy.manyinterfacebean; public class MyServiceV1 implements ITotalService { private static final String SERVICE_NAME = &quot;MY_SERVICE_V1&quot;; public MyServiceV1(){ } @Override public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } @Override public void printAnotherName() { System.out.println(String.format(&quot;I also implement %s&quot;, IAnotherService.class.getName()));} } 또한 Configuration 클래스 또한 아래와 같이 ITotalService를 반환하도록 수정해주고 package com.leeyh0216.springstudy.manyinterfacebean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class AppConfig { @Bean public ITotalService getTotalService(){ return new MyServiceV1(); } } main 함수 또한 아래와 같이 IMyService, IAnotherService를 따로 가져오는 것이 아닌 ITotalService 하나만을 가져오도록 수정하면 정상적으로 동작하는 것을 확인할 수 있다. package com.leeyh0216.springstudy.manyinterfacebean; import org.springframework.beans.factory.NoUniqueBeanDefinitionException; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); ITotalService totalService = applicationContext.getBean(ITotalService.class); totalService.printServiceName(); totalService.printAnotherName(); } } 이 경우는 Bean은 1개가 등록되어 있고, 타입에 따라 가져올 수 있도록 구현된 경우이다. @Primary 어노테이션을 이용하여 우선순위에 따라 선택되게 만드는 방법 우선 MyService 클래스를 아래와 같이 수정하여, getMyService와 getAnotherService에서 반환되는 객체를 구분할 수 있도록 하자. package com.leeyh0216.springstudy.manyinterfacebean; public class MyServiceV1 implements IMyService, IAnotherService { private String serviceName; public MyServiceV1(String serviceName){ this.serviceName = serviceName; } @Override public void printServiceName(){ System.out.println(&quot;My Service: &quot; + serviceName); } @Override public void printAnotherName() { System.out.println(String.format(&quot;I also implement %s&quot;, IAnotherService.class.getName()));} } Configuration 클래스의 getMyService 메서드에 아래와 같이 @Primary 어노테이션을 붙여준다. 또한 두 객체를 구분할 수 있도록 생성자에 각각 “primary”와 “no priority”를 넣어준다. package com.leeyh0216.springstudy.manyinterfacebean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Primary; @Configuration public class AppConfig { @Primary @Bean public IMyService getMyService(){ return new MyServiceV1(&quot;primary&quot;); } @Bean public IAnotherService getAnotherService(){ return new MyServiceV1(&quot;no priority&quot;); } } 그 후 main 함수를 아래와 같이 작성하여 돌려보면 getMyService 메서드에서 반환한 Bean이 우선적으로 선택되는 것을 볼 수 있다. package com.leeyh0216.springstudy.manyinterfacebean; import org.springframework.beans.factory.NoUniqueBeanDefinitionException; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); IMyService myService = applicationContext.getBean(IMyService.class); IAnotherService anotherService = applicationContext.getBean(IAnotherService.class); myService.printServiceName(); anotherService.printAnotherName(); System.out.println(myService == anotherService); } } 이 경우 또한 ApplicationContext에 getMyService와 getAnotherService Bean 모두가 등록되어 있지만 우선순위에 의해 1개만 선택되는 경우이다. 여기까지 Interface 타입을 활용하는 방법과, Bean의 우선순위에 대해 알아보았다.","@type":"BlogPosting","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


  <!-- CSS -->
  <link rel="stylesheet" href="/assets/main.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">

  <!-- Favicon -->
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png">

  <!-- RSS -->
  <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="leeyh0216's devlog" />

  <!-- Google Analytics-->
  
</head>


  <body>

    <nav class="nav">
  <div class="nav-container">
    <a href="/">
      <h2 class="nav-title">leeyh0216's devlog</h2>
    </a>
    <ul>
      <li><a href="/about">About</a></li>
      <li><a href="/">Posts</a></li>
    </ul>
  </div>
</nav>


    <main>
      <div class="post">
  <div class="post-info">
    <span>Written by</span>
    
        leeyh0216
    

    
      <br>
      <span>on&nbsp;</span><time datetime="2018-11-29 21:00:00 +0900">November 29, 2018</time>
    
  </div>

  <h1 class="post-title">Spring Core Technologies - The IoC Container(2)</h1>
  <div class="post-line"></div>

  <h1 id="the-ioc-container">The IoC Container</h1>

<h2 id="introduction-to-the-spring-ioc-container-and-beans">Introduction to the Spring IoC Container and Beans</h2>

<h3 id="bean-선언-시의-interface-활용">Bean 선언 시의 Interface 활용</h3>

<p>Bean 객체를 초기화하여 반환하는 메소드(<code class="highlighter-rouge">@Bean</code> 어노테이션이 붙은) 만들어 ApplicationContext에서 찾아 사용하는 예제를 이전 글에서 만들어 보았다.</p>

<p>해당 예제에서는 초기화하여 반환하는 객체의 타입과 반환 타입이 완전히 일치했는데, 반환 타입은 구체화된 클래스가 아닌 Interface 혹은 Abstract Class로 설정할 수 있다.</p>

<p>먼저 아래와 같이 하위 클래스가 구현해야하는 인터페이스를 만든다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leeyh0216</span><span class="o">.</span><span class="na">springstudy</span><span class="o">.</span><span class="na">interfacebean</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">IMyService</span> <span class="o">{</span>

    <span class="kt">void</span> <span class="nf">printServiceName</span><span class="o">();</span>
    
<span class="o">}</span></code></pre></figure>

<p>위의 인터페이스를 상속한 MyServiceV1을 구현한다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leeyh0216</span><span class="o">.</span><span class="na">springstudy</span><span class="o">.</span><span class="na">interfacebean</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyServiceV1</span> <span class="kd">implements</span> <span class="nc">IMyService</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">SERVICE_NAME</span> <span class="o">=</span> <span class="s">"MY_SERVICE_V1"</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MyServiceV1</span><span class="o">(){</span>

    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printServiceName</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"My Service: "</span> <span class="o">+</span> <span class="no">SERVICE_NAME</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span></code></pre></figure>

<p>그 후, IMyService Bean을 초기화할 Configuration 클래스와 메서드를 아래와 같이 구현한다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leeyh0216</span><span class="o">.</span><span class="na">springstudy</span><span class="o">.</span><span class="na">interfacebean</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Bean</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Configuration</span><span class="o">;</span>

<span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">IMyService</span> <span class="nf">getMyService</span><span class="o">(){</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">MyServiceV1</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span></code></pre></figure>

<p>위 getMyService 함수에서 반환 형은 IMyService이지만, 실제 반환되는 객체는 IMyService를 상속한 클래스인 MyServiceV1의 객체인 것을 확인할 수 있다.</p>

<p>이를 테스트하는 Application 클래스를 아래와 같이 생성한다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leeyh0216</span><span class="o">.</span><span class="na">springstudy</span><span class="o">.</span><span class="na">interfacebean</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.context.ApplicationContext</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.AnnotationConfigApplicationContext</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Application</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">ApplicationContext</span> <span class="n">applicationContext</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">AppConfig</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">IMyService</span> <span class="n">myService</span> <span class="o">=</span> <span class="n">applicationContext</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">IMyService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">myService</span><span class="o">.</span><span class="na">printServiceName</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>실행 결과는 아래와 같다.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">21:12:32.878 [main] DEBUG org.springframework.core.env.StandardEnvironment - Adding [systemProperties] PropertySource with lowest search precedence
21:12:32.886 [main] DEBUG org.springframework.core.env.StandardEnvironment - Adding [systemEnvironment] PropertySource with lowest search precedence
...생략
21:12:33.427 [main] DEBUG org.springframework.beans.factory.support.DefaultListableBeanFactory - Returning cached instance of singleton bean 'getMyService'
My Service: MY_SERVICE_V1</code></pre></figure>

<p>위 코드의 장점은 무엇일까? 인터페이스 기반으로 작성되었기 때문에, 추후 기능 개선 혹은 추가를 위해 새로운 버전의 클래스인 MyServiceV2를 만들었을 때, Bean을 반환하는 메소드의 초기화 부분만을 수정하면, 이외의 코드는 수정하지 않고 그대로 사용할 수 있다.</p>

<p>아래와 같이 MyServiceV2를 IMyService 인터페이스를 상속받아 구현하고,</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leeyh0216</span><span class="o">.</span><span class="na">springstudy</span><span class="o">.</span><span class="na">interfacebean</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyServiceV2</span> <span class="kd">implements</span> <span class="nc">IMyService</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">SERVICE_NAME</span> <span class="o">=</span> <span class="s">"MY_SERVICE_V2"</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MyServiceV2</span><span class="o">(){</span>

    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printServiceName</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"My Service: "</span> <span class="o">+</span> <span class="no">SERVICE_NAME</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span></code></pre></figure>

<p>아래와 같이 Configuration 클래스의 getMyService 메소드만 살짝 수정해주면</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leeyh0216</span><span class="o">.</span><span class="na">springstudy</span><span class="o">.</span><span class="na">interfacebean</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Bean</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Configuration</span><span class="o">;</span>

<span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">IMyService</span> <span class="nf">getMyService</span><span class="o">(){</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">MyServiceV2</span><span class="o">();</span>
    <span class="o">}</span>

<span class="o">}</span></code></pre></figure>

<p>동일한 Application를 실행했을 때, 아래와 같이 다른 코드의 수정 없이도 정상적으로 동작하는 것을 확인할 수 있다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="mi">21</span><span class="o">:</span><span class="mi">21</span><span class="o">:</span><span class="mf">04.147</span> <span class="o">[</span><span class="n">main</span><span class="o">]</span> <span class="no">DEBUG</span> <span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">core</span><span class="o">.</span><span class="na">env</span><span class="o">.</span><span class="na">StandardEnvironment</span> <span class="o">-</span> <span class="nc">Adding</span> <span class="o">[</span><span class="n">systemProperties</span><span class="o">]</span> <span class="nc">PropertySource</span> <span class="n">with</span> <span class="n">lowest</span> <span class="n">search</span> <span class="n">precedence</span>
<span class="mi">21</span><span class="o">:</span><span class="mi">21</span><span class="o">:</span><span class="mf">04.157</span> <span class="o">[</span><span class="n">main</span><span class="o">]</span> <span class="no">DEBUG</span> <span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">core</span><span class="o">.</span><span class="na">env</span><span class="o">.</span><span class="na">StandardEnvironment</span> <span class="o">-</span> <span class="nc">Adding</span> <span class="o">[</span><span class="n">systemEnvironment</span><span class="o">]</span> <span class="nc">PropertySource</span> <span class="n">with</span> <span class="n">lowest</span> <span class="n">search</span> <span class="n">precedence</span>
<span class="o">...</span><span class="err">생략</span>
<span class="mi">21</span><span class="o">:</span><span class="mi">21</span><span class="o">:</span><span class="mf">04.929</span> <span class="o">[</span><span class="n">main</span><span class="o">]</span> <span class="no">DEBUG</span> <span class="n">org</span><span class="o">.</span><span class="na">springframework</span><span class="o">.</span><span class="na">beans</span><span class="o">.</span><span class="na">factory</span><span class="o">.</span><span class="na">support</span><span class="o">.</span><span class="na">DefaultListableBeanFactory</span> <span class="o">-</span> <span class="nc">Returning</span> <span class="n">cached</span> <span class="n">instance</span> <span class="n">of</span> <span class="n">singleton</span> <span class="n">bean</span> <span class="err">'</span><span class="n">getMyService</span><span class="err">'</span>
<span class="nc">My</span> <span class="nl">Service:</span> <span class="no">MY_SERVICE_V2</span></code></pre></figure>

<h3 id="여러-개의-인터페이스를-구현한-하나의-클래스를-통해-초기화된-객체">여러 개의 인터페이스를 구현한 하나의 클래스를 통해 초기화된 객체</h3>

<p>아래와 같이 2개의 인터페이스(IMyService, IAnotherService)와 이 둘을 구현한 MyService 클래스가 있다고 생각해보자.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leeyh0216</span><span class="o">.</span><span class="na">springstudy</span><span class="o">.</span><span class="na">manyinterfacebean</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">IMyService</span> <span class="o">{</span>

    <span class="kt">void</span> <span class="nf">printServiceName</span><span class="o">();</span>
    
<span class="o">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leeyh0216</span><span class="o">.</span><span class="na">springstudy</span><span class="o">.</span><span class="na">manyinterfacebean</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">IAnotherService</span> <span class="o">{</span>

    <span class="kt">void</span> <span class="nf">printAnotherName</span><span class="o">();</span>

<span class="o">}</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leeyh0216</span><span class="o">.</span><span class="na">springstudy</span><span class="o">.</span><span class="na">manyinterfacebean</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyServiceV1</span> <span class="kd">implements</span> <span class="nc">IMyService</span><span class="o">,</span> <span class="nc">IAnotherService</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">SERVICE_NAME</span> <span class="o">=</span> <span class="s">"MY_SERVICE_V1"</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MyServiceV1</span><span class="o">(){</span>

    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printServiceName</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"My Service: "</span> <span class="o">+</span> <span class="no">SERVICE_NAME</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printAnotherName</span><span class="o">()</span> <span class="o">{</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"I also implement %s"</span><span class="o">,</span> <span class="nc">IAnotherService</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getName</span><span class="o">()));}</span>

<span class="o">}</span></code></pre></figure>

<p>Configuration 클래스는 어떻게 구성해야 할까? 일단 아래와 같이 각각 IMyService, IAnotherService 를 반환타입으로 가지는 메서드를 포함한 Configuration 클래스를 만들어 보았다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leeyh0216</span><span class="o">.</span><span class="na">springstudy</span><span class="o">.</span><span class="na">manyinterfacebean</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Bean</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Configuration</span><span class="o">;</span>

<span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">MyServiceV1</span> <span class="n">myService</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyServiceV1</span><span class="o">();</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">IMyService</span> <span class="nf">getMyService</span><span class="o">(){</span> <span class="k">return</span> <span class="n">myService</span><span class="o">;</span> <span class="o">}</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">IAnotherService</span> <span class="nf">getAnotherService</span><span class="o">(){</span> <span class="k">return</span> <span class="n">myService</span><span class="o">;</span> <span class="o">}</span>

<span class="o">}</span></code></pre></figure>

<p>테스트를 위해 아래와 같이 IMyService, IAnotherService 타입의 Bean을 ApplicationContext로부터 가져오려 했지만,</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leeyh0216</span><span class="o">.</span><span class="na">springstudy</span><span class="o">.</span><span class="na">manyinterfacebean</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.context.ApplicationContext</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.AnnotationConfigApplicationContext</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Application</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">ApplicationContext</span> <span class="n">applicationContext</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">AppConfig</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">IMyService</span> <span class="n">myService</span> <span class="o">=</span> <span class="n">applicationContext</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">IMyService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">IAnotherService</span> <span class="n">anotherService</span> <span class="o">=</span> <span class="n">applicationContext</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">IAnotherService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">myService</span><span class="o">.</span><span class="na">printServiceName</span><span class="o">();</span>
        <span class="n">anotherService</span><span class="o">.</span><span class="na">printAnotherName</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">myService</span> <span class="o">==</span> <span class="n">anotherService</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>다음과 같은 오류 메시지가 발생하며 실행에 실패하는 것을 확인할 수 있었다.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">Exception in thread "main" org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type 'com.leeyh0216.springstudy.manyinterfacebean.IMyService' available: expected single matching bean but found 2: getMyService,getAnotherService
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveNamedBean(DefaultListableBeanFactory.java:1041)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:345)
...생략</code></pre></figure>

<p>IMyService 타입의 Bean에 만족하는 Bean이 getMyService와 getAnotherService 2개가 발견되었다는 메시지가 발생한다.</p>

<p>분명 getAnotherService 함수는 IAnotherService 인터페이스를 반환했는데도 이러한 오류가 발생하는 것을 확인할 수 있었다.</p>

<p>Stacktrace 첫번째 라인의 함수의 2번째 줄을 보면,</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nc">String</span><span class="o">[]</span> <span class="n">candidateNames</span> <span class="o">=</span> <span class="n">getBeanNamesForType</span><span class="o">(</span><span class="n">requiredType</span><span class="o">);</span></code></pre></figure>

<p>와 같이, Application에 등록된 Bean 중 우리가 인자로 전달한 IMyService 타입을 가진 Bean을 반환하는 getBeanNamesForType을 반환하는 것을 볼 수 있으며, 실제 오류가 나는 부분을 보면</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java">	<span class="kd">private</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">NamedBeanHolder</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">resolveNamedBean</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">requiredType</span><span class="o">,</span> <span class="nc">Object</span><span class="o">...</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">BeansException</span> <span class="o">{</span>
		<span class="nc">Assert</span><span class="o">.</span><span class="na">notNull</span><span class="o">(</span><span class="n">requiredType</span><span class="o">,</span> <span class="s">"Required type must not be null"</span><span class="o">);</span>
		<span class="nc">String</span><span class="o">[]</span> <span class="n">candidateNames</span> <span class="o">=</span> <span class="n">getBeanNamesForType</span><span class="o">(</span><span class="n">requiredType</span><span class="o">);</span>

		<span class="k">if</span> <span class="o">(</span><span class="n">candidateNames</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
			<span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">autowireCandidates</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;(</span><span class="n">candidateNames</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
			<span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">beanName</span> <span class="o">:</span> <span class="n">candidateNames</span><span class="o">)</span> <span class="o">{</span>
				<span class="k">if</span> <span class="o">(!</span><span class="n">containsBeanDefinition</span><span class="o">(</span><span class="n">beanName</span><span class="o">)</span> <span class="o">||</span> <span class="n">getBeanDefinition</span><span class="o">(</span><span class="n">beanName</span><span class="o">).</span><span class="na">isAutowireCandidate</span><span class="o">())</span> <span class="o">{</span>
					<span class="n">autowireCandidates</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">beanName</span><span class="o">);</span>
				<span class="o">}</span>
			<span class="o">}</span>
			<span class="k">if</span> <span class="o">(!</span><span class="n">autowireCandidates</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
				<span class="n">candidateNames</span> <span class="o">=</span> <span class="n">autowireCandidates</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="nc">String</span><span class="o">[</span><span class="n">autowireCandidates</span><span class="o">.</span><span class="na">size</span><span class="o">()]);</span>
			<span class="o">}</span>
		<span class="o">}</span>

		<span class="k">if</span> <span class="o">(</span><span class="n">candidateNames</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
			<span class="nc">String</span> <span class="n">beanName</span> <span class="o">=</span> <span class="n">candidateNames</span><span class="o">[</span><span class="mi">0</span><span class="o">];</span>
			<span class="k">return</span> <span class="k">new</span> <span class="nc">NamedBeanHolder</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">getBean</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">requiredType</span><span class="o">,</span> <span class="n">args</span><span class="o">));</span>
		<span class="o">}</span>
		<span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">candidateNames</span><span class="o">.</span><span class="na">length</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
			<span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">candidates</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LinkedHashMap</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;(</span><span class="n">candidateNames</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
			<span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">beanName</span> <span class="o">:</span> <span class="n">candidateNames</span><span class="o">)</span> <span class="o">{</span>
				<span class="k">if</span> <span class="o">(</span><span class="n">containsSingleton</span><span class="o">(</span><span class="n">beanName</span><span class="o">))</span> <span class="o">{</span>
					<span class="n">candidates</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">getBean</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">requiredType</span><span class="o">,</span> <span class="n">args</span><span class="o">));</span>
				<span class="o">}</span>
				<span class="k">else</span> <span class="o">{</span>
					<span class="n">candidates</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">beanName</span><span class="o">,</span> <span class="n">getType</span><span class="o">(</span><span class="n">beanName</span><span class="o">));</span>
				<span class="o">}</span>
			<span class="o">}</span>
			<span class="nc">String</span> <span class="n">candidateName</span> <span class="o">=</span> <span class="n">determinePrimaryCandidate</span><span class="o">(</span><span class="n">candidates</span><span class="o">,</span> <span class="n">requiredType</span><span class="o">);</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">candidateName</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
				<span class="n">candidateName</span> <span class="o">=</span> <span class="n">determineHighestPriorityCandidate</span><span class="o">(</span><span class="n">candidates</span><span class="o">,</span> <span class="n">requiredType</span><span class="o">);</span>
			<span class="o">}</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">candidateName</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
				<span class="nc">Object</span> <span class="n">beanInstance</span> <span class="o">=</span> <span class="n">candidates</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">candidateName</span><span class="o">);</span>
				<span class="k">if</span> <span class="o">(</span><span class="n">beanInstance</span> <span class="k">instanceof</span> <span class="nc">Class</span><span class="o">)</span> <span class="o">{</span>
					<span class="n">beanInstance</span> <span class="o">=</span> <span class="n">getBean</span><span class="o">(</span><span class="n">candidateName</span><span class="o">,</span> <span class="n">requiredType</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
				<span class="o">}</span>
				<span class="k">return</span> <span class="k">new</span> <span class="nc">NamedBeanHolder</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;(</span><span class="n">candidateName</span><span class="o">,</span> <span class="o">(</span><span class="no">T</span><span class="o">)</span> <span class="n">beanInstance</span><span class="o">);</span>
			<span class="o">}</span>
			<span class="k">throw</span> <span class="k">new</span> <span class="nf">NoUniqueBeanDefinitionException</span><span class="o">(</span><span class="n">requiredType</span><span class="o">,</span> <span class="n">candidates</span><span class="o">.</span><span class="na">keySet</span><span class="o">());</span>
		<span class="o">}</span>

		<span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
	<span class="o">}</span></code></pre></figure>

<p>거의 맨 아랫줄의 throw new NoUniqueBeanDefinitionException에서 발생하는 것을 확인할 수 있다.</p>

<p>원인은 위 함수의 거의 맨 윗 줄에 있는</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nc">String</span><span class="o">[]</span> <span class="n">candidateNames</span> <span class="o">=</span> <span class="n">getBeanNamesForType</span><span class="o">(</span><span class="n">requiredType</span><span class="o">);</span></code></pre></figure>

<p>의 <code class="highlighter-rouge">getBeanNamesForType</code> 함수이다.</p>

<p>이 함수는 <code class="highlighter-rouge">org.springframework.beans.factory</code> 패키지에 선언된 <code class="highlighter-rouge">ListableBeanFactory</code>의 getBeanNamesForType을 구현한 것인데, 해당 함수는 아래와 같이 설명되어 있다.</p>

<blockquote>
  <p>주어진 타입(<strong>SubClass를 포함하여</strong>)과 일치하는 Bean 목록을 반환합니다.</p>
</blockquote>

<p>SubClass를 포함했다는 사실이 매우 중요하다.</p>

<p>우리가 IMyService를 반환하는 getMyService와 IAnotherService를 반환하는 getAnotherService를 구현했어도, 결과적으로 반환되는 객체는 MyService 타입이다.</p>

<p>즉, IMyService 클래스를 <code class="highlighter-rouge">getBeanNamesForType</code>에 넘긴다 해도 구체화 클래스인 <code class="highlighter-rouge">MyService</code> 클래스의 객체인 <code class="highlighter-rouge">getMyService</code> Bean과 <code class="highlighter-rouge">getAnotherService</code> Bean이 반환된다.</p>

<p>두 개의 Bean을 반환할 수는 없기 때문에, Springframework에서 제시하는 기준에 맞춰지는 Bean을 반환하려고 candidate를 찾는 과정이 위의 <code class="highlighter-rouge">resolveNamedBean</code> 메소드에 구현되어 있는데,</p>

<ol>
  <li><code class="highlighter-rouge">getBeanNamesForType</code>에서 반환한 Bean 이름이 1개인 경우 해당 이름을 가진 Bean을 반환</li>
  <li><code class="highlighter-rouge">getBeanNamesForType</code>에서 반환한 Bean 이름이 여러개인 경우
    <ol>
      <li><code class="highlighter-rouge">@Primiary</code> 어노테이션 등을 통해 Bean의 우선 순위를 지정한 경우 가장 높은 우선순위를 가지는 Bean을 반환</li>
      <li>우선 순위가 명확하지 않은 경우 NoUniqueBeanDefinitionException 예외를 throw</li>
    </ol>
  </li>
</ol>

<p>와 같은 과정을 가지고 있다.</p>

<p>위 과정을 우리의 코드에 적용해보자면 선택지는 3개가 된다.</p>

<ol>
  <li>Class가 아닌 Bean 이름을 통해 Bean을 선택하는 방법</li>
  <li><code class="highlighter-rouge">IMyService</code>, <code class="highlighter-rouge">IAnotherService</code>를 모두를 상속받는 인터페이스를 <code class="highlighter-rouge">MyService</code> 클래스가 구현하여 Bean을 1개로 만드는 방법</li>
  <li><code class="highlighter-rouge">@Primary</code>와 같은 우선순위 어노테이션을 이용하여 우선순위에 따라 선택되게 만드는 방법</li>
</ol>

<p>각 방법을 테스트해보도록 하겠다.</p>

<h4 id="class가-아닌-bean-이름을-통해-bean을-선택하는-방법">Class가 아닌 Bean 이름을 통해 Bean을 선택하는 방법</h4>

<p>아래와 같이 기존에 getBean의 인자를 Class를 전달했던 방식에서 실제 Bean 이름을 전달하는 방식으로 변경한다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leeyh0216</span><span class="o">.</span><span class="na">springstudy</span><span class="o">.</span><span class="na">manyinterfacebean</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.NoUniqueBeanDefinitionException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.ApplicationContext</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.AnnotationConfigApplicationContext</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Application</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">ApplicationContext</span> <span class="n">applicationContext</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">AppConfig</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">applicationContext</span><span class="o">.</span><span class="na">getBeanNamesForType</span><span class="o">(</span><span class="nc">IMyService</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">length</span><span class="o">);</span>
        <span class="nc">IMyService</span> <span class="n">myService</span> <span class="o">=</span> <span class="o">(</span><span class="nc">IMyService</span><span class="o">)</span><span class="n">applicationContext</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"getMyService"</span><span class="o">);</span>
        <span class="nc">IAnotherService</span> <span class="n">anotherService</span> <span class="o">=</span> <span class="o">(</span><span class="nc">IAnotherService</span><span class="o">)</span><span class="n">applicationContext</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"getAnotherService"</span><span class="o">);</span>
        <span class="n">myService</span><span class="o">.</span><span class="na">printServiceName</span><span class="o">();</span>
        <span class="n">anotherService</span><span class="o">.</span><span class="na">printAnotherName</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">myService</span> <span class="o">==</span> <span class="n">anotherService</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>이 경우 또한 ApplicationContext에 <code class="highlighter-rouge">getMyService</code>와 <code class="highlighter-rouge">getAnotherService</code> Bean 모두가 등록되어 있지만 <code class="highlighter-rouge">getMyService</code> 이름을 가진 Bean만을 가져오기 때문에 위와 같은 오류가 발생하지 않는 것이다.</p>

<h4 id="imyservice-ianotherservice-를-상속받은-인터페이스를-myservice가-구현하는-방법"><code class="highlighter-rouge">IMyService</code>, <code class="highlighter-rouge">IAnotherService</code> 를 상속받은 인터페이스를 MyService가 구현하는 방법</h4>

<p>아래와 같이 <code class="highlighter-rouge">IMyService</code>, <code class="highlighter-rouge">IAnotherService</code>를 상속하는 <code class="highlighter-rouge">ITotalService</code> 인터페이스를 만든다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leeyh0216</span><span class="o">.</span><span class="na">springstudy</span><span class="o">.</span><span class="na">manyinterfacebean</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ITotalService</span> <span class="kd">extends</span> <span class="nc">IMyService</span><span class="o">,</span> <span class="nc">IAnotherService</span><span class="o">{</span>
<span class="o">}</span></code></pre></figure>

<p>그 후 MyService가 해당 Interface를 구현하도록 한다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leeyh0216</span><span class="o">.</span><span class="na">springstudy</span><span class="o">.</span><span class="na">manyinterfacebean</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyServiceV1</span> <span class="kd">implements</span> <span class="nc">ITotalService</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">SERVICE_NAME</span> <span class="o">=</span> <span class="s">"MY_SERVICE_V1"</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MyServiceV1</span><span class="o">(){</span>

    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printServiceName</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"My Service: "</span> <span class="o">+</span> <span class="no">SERVICE_NAME</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printAnotherName</span><span class="o">()</span> <span class="o">{</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"I also implement %s"</span><span class="o">,</span> <span class="nc">IAnotherService</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getName</span><span class="o">()));}</span>

<span class="o">}</span></code></pre></figure>

<p>또한 Configuration 클래스 또한 아래와 같이 <code class="highlighter-rouge">ITotalService</code>를 반환하도록 수정해주고</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leeyh0216</span><span class="o">.</span><span class="na">springstudy</span><span class="o">.</span><span class="na">manyinterfacebean</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Bean</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Configuration</span><span class="o">;</span>

<span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">ITotalService</span> <span class="nf">getTotalService</span><span class="o">(){</span> <span class="k">return</span> <span class="k">new</span> <span class="nc">MyServiceV1</span><span class="o">();</span> <span class="o">}</span>

<span class="o">}</span></code></pre></figure>

<p>main 함수 또한 아래와 같이 <code class="highlighter-rouge">IMyService</code>, <code class="highlighter-rouge">IAnotherService</code>를 따로 가져오는 것이 아닌 <code class="highlighter-rouge">ITotalService</code> 하나만을 가져오도록 수정하면 정상적으로 동작하는 것을 확인할 수 있다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leeyh0216</span><span class="o">.</span><span class="na">springstudy</span><span class="o">.</span><span class="na">manyinterfacebean</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.NoUniqueBeanDefinitionException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.ApplicationContext</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.AnnotationConfigApplicationContext</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Application</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">ApplicationContext</span> <span class="n">applicationContext</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">AppConfig</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">ITotalService</span> <span class="n">totalService</span> <span class="o">=</span> <span class="n">applicationContext</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">ITotalService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">totalService</span><span class="o">.</span><span class="na">printServiceName</span><span class="o">();</span>
        <span class="n">totalService</span><span class="o">.</span><span class="na">printAnotherName</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>이 경우는 Bean은 1개가 등록되어 있고, 타입에 따라 가져올 수 있도록 구현된 경우이다.</p>

<h4 id="primary-어노테이션을-이용하여-우선순위에-따라-선택되게-만드는-방법"><code class="highlighter-rouge">@Primary</code> 어노테이션을 이용하여 우선순위에 따라 선택되게 만드는 방법</h4>

<p>우선 MyService 클래스를 아래와 같이 수정하여, <code class="highlighter-rouge">getMyService</code>와 <code class="highlighter-rouge">getAnotherService</code>에서 반환되는 객체를 구분할 수 있도록 하자.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leeyh0216</span><span class="o">.</span><span class="na">springstudy</span><span class="o">.</span><span class="na">manyinterfacebean</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyServiceV1</span> <span class="kd">implements</span> <span class="nc">IMyService</span><span class="o">,</span> <span class="nc">IAnotherService</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">serviceName</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MyServiceV1</span><span class="o">(</span><span class="nc">String</span> <span class="n">serviceName</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">serviceName</span> <span class="o">=</span> <span class="n">serviceName</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printServiceName</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"My Service: "</span> <span class="o">+</span> <span class="n">serviceName</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printAnotherName</span><span class="o">()</span> <span class="o">{</span> <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="nc">String</span><span class="o">.</span><span class="na">format</span><span class="o">(</span><span class="s">"I also implement %s"</span><span class="o">,</span> <span class="nc">IAnotherService</span><span class="o">.</span><span class="na">class</span><span class="o">.</span><span class="na">getName</span><span class="o">()));}</span>

<span class="o">}</span></code></pre></figure>

<p>Configuration 클래스의 <code class="highlighter-rouge">getMyService</code> 메서드에 아래와 같이 <code class="highlighter-rouge">@Primary</code> 어노테이션을 붙여준다. 또한 두 객체를 구분할 수 있도록 생성자에 각각 “primary”와 “no priority”를 넣어준다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leeyh0216</span><span class="o">.</span><span class="na">springstudy</span><span class="o">.</span><span class="na">manyinterfacebean</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Bean</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Configuration</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Primary</span><span class="o">;</span>

<span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>

    <span class="nd">@Primary</span>
    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">IMyService</span> <span class="nf">getMyService</span><span class="o">(){</span> <span class="k">return</span> <span class="k">new</span> <span class="nc">MyServiceV1</span><span class="o">(</span><span class="s">"primary"</span><span class="o">);</span> <span class="o">}</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">IAnotherService</span> <span class="nf">getAnotherService</span><span class="o">(){</span> <span class="k">return</span> <span class="k">new</span> <span class="nc">MyServiceV1</span><span class="o">(</span><span class="s">"no priority"</span><span class="o">);</span> <span class="o">}</span>

<span class="o">}</span></code></pre></figure>

<p>그 후 main 함수를 아래와 같이 작성하여 돌려보면 <code class="highlighter-rouge">getMyService</code> 메서드에서 반환한 Bean이 우선적으로 선택되는 것을 볼 수 있다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leeyh0216</span><span class="o">.</span><span class="na">springstudy</span><span class="o">.</span><span class="na">manyinterfacebean</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.NoUniqueBeanDefinitionException</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.ApplicationContext</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.AnnotationConfigApplicationContext</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Application</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">ApplicationContext</span> <span class="n">applicationContext</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">AppConfig</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">IMyService</span> <span class="n">myService</span> <span class="o">=</span> <span class="n">applicationContext</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">IMyService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">IAnotherService</span> <span class="n">anotherService</span> <span class="o">=</span> <span class="n">applicationContext</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">IAnotherService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">myService</span><span class="o">.</span><span class="na">printServiceName</span><span class="o">();</span>
        <span class="n">anotherService</span><span class="o">.</span><span class="na">printAnotherName</span><span class="o">();</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">myService</span> <span class="o">==</span> <span class="n">anotherService</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>이 경우 또한 ApplicationContext에 <code class="highlighter-rouge">getMyService</code>와 <code class="highlighter-rouge">getAnotherService</code> Bean 모두가 등록되어 있지만 우선순위에 의해 1개만 선택되는 경우이다.</p>

<p>여기까지 Interface 타입을 활용하는 방법과, Bean의 우선순위에 대해 알아보았다.</p>


</div>

<div class="pagination">
  
    <a href="/2018-12-03/spring-core-3" class="left arrow">&#8592;</a>
  
  
    <a href="/2018-11-19/elasticsearch-1" class="right arrow">&#8594;</a>
  

  <a href="#" class="top">Top</a>
</div>

    </main>

    <footer>
  <span>
    &copy; <time datetime="2019-10-08 19:35:35 +0900">2019</time> leeyh0216. Made with Jekyll using the <a href="https://github.com/chesterhow/tale/">Tale</a> theme.
  </span>
</footer>

  </body>
</html>
