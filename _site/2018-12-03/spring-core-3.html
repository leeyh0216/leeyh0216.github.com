<!DOCTYPE html>
<html lang="en">

  <head>
  
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Spring Core Technologies - The IoC Container(3) | DevLog</title>
<meta name="generator" content="Jekyll v3.8.6" />
<meta property="og:title" content="Spring Core Technologies - The IoC Container(3)" />
<meta name="author" content="leeyh0216" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="The IoC Container Introduction to the Spring IoC Container and Beans Bean Dependencies Application에 Service Layer 역할을 하는 MyService와 Persistent Layer 역할을 하는 MyRepository 클래스가 있다고 가정해보자. MyService 클래스가 동작하기 위해서는 MyRepository 객체가 필요하다.(즉, MyService 클래스가 MyRepository 클래스에 의존적이다) 이러한 경우 아래와 같은 코드를 작성해야 할까? package com.leeyh0216.springstudy.beandependencies; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class AppConfig { @Bean public MyService getMyService(){ return new MyService(new MyRepository()); } } getMyService 함수에서 MyService 객체 초기화 시, MyRepository 객체 또한 같이 초기화하여 생성자로 전달하고 있다. 이러한 방식을 사용할 경우, MyService의 의존 객체가 많을 경우 getMyService 함수 또한 비대해진다. ApplicationContext는 모든 Bean을 관리하고, @Bean 어노테이션이 붙은 함수의 인자와 일치하는 Bean을 찾아 주입시켜주는 기능을 가지고 있다. 즉, 아래와 같이 MyRepository Bean을 초기화하는 @Bean 어노테이션이 붙은 메소드를 만들고, getMyService 함수의 인자로는 MyService를 초기화하는데 필요한 MyRepository를 선언한다. 그러면 Spring의 ApplicationContext는 MyRepository Bean을 먼저 getMyRepository 함수를 호출하여 초기화하고, MyService Bean 초기화 함수인 getMyService의 인수로 이미 Bean으로 생성되어 있는 MyRepository 객체를 주입시켜준다. package com.leeyh0216.springstudy.beandependencies; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class AppConfig { @Bean public MyRepository getMyRepository(){ return new MyRepository(); } @Bean public MyService getMyService(MyRepository myRepository){ return new MyService(myRepository); } } Receiving Lifecycle Callbacks @Bean 어노테이션으로 초기화되는 객체들은 JSR-250 스펙에 정의된 @PostConstruct와 @PreDestory 어노테이션을 통한 Lifecycle Callback을 호출받을 수 있다. 또한 Spring Framework의 InitializingBean, DisposableBean, Lifecycle을 상속받으면 Container에 의해 Lifecycle을 관리받을 수 있다. InitializingBean을 상속하는 방법 InitializingBean는 Bean이 BeanFactory에 의해 생성되고, 모든 의존성이 주입되어졌을 때 한번 호출되는 함수를 필요로 할 때 구현하는 인터페이스이다. 그렇다면 생성자와 다른 점은 무엇인가? 객체는 생성자 호출 시 필요한 의존 객체를 주입받을 수도 있지만, 생성된 이후에도 Setter를 통해 의존 객체를 주입받을 수 있다. InitializingBean은 이렇게 객체 생성 이후에 Setter를 통해 의존 객체를 주입받는 경우 구현해야하는 인터페이스이다. InitializingBean 인터페이스를 상속받은 클래스는 void afterPropertiesSet() 메서드를 구현해야 한다. 이 함수는 Bean의 의존 객체가 모두 설정된 후 호출된다. 다루지는 않았었지만 @Autowired 어노테이션을 Bean으로 만들 클래스의 Setter에 설정해주면, Bean 생성 시 Setter의 인자와 동일한 객체가 있는 경우 BeanFactory가 주입해준다. 아래와 같은 MyService 클래스가 있다고 생각해보자. package com.leeyh0216.springstudy.initializingbean; import org.springframework.beans.factory.InitializingBean; import org.springframework.beans.factory.annotation.Autowired; public class MyService implements InitializingBean { private static final String SERVICE_NAME = &quot;MY_SERVICE&quot;; private MyRepository myRepository; public MyService(){ System.out.println(&quot;MyService Constructor Called&quot;); } @Autowired public void setMyRepository(MyRepository myRepository){ System.out.println(&quot;setMyRepository Called&quot;); this.myRepository = myRepository; } @Override public void afterPropertiesSet() throws Exception { System.out.println(&quot;afterPropertiesSet Called&quot;); } public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } Spring Application을 호출하면 위 객체의 메서드(혹은 생성자)가 아래와 같은 순서로 호출된다. MyService 클래스의 생성자 setMyRepository 메서드 afterPropertiesSet 메서드 즉, InitializingBean 인터페이스의 afterPropertiesSet() 함수는 생성자 뿐만 아니라, Bean의 의존 객체를 BeanFactory가 모두 Injection 해준 후 호출되는 함수이다. @PostConstruct 어노테이션을 붙인 메서드를 만드는 방법 Bean 클래스 내에 @PostConstruct 어노테이션을 붙인 메서드를 만드는 경우, BeanFactory가 Bean을 생성한 후 해당 함수를 호출하게 된다. package com.leeyh0216.springstudy.initializingbean; import org.springframework.beans.factory.InitializingBean; import org.springframework.beans.factory.annotation.Autowired; import javax.annotation.PostConstruct; public class MyService { private static final String SERVICE_NAME = &quot;MY_SERVICE&quot;; private MyRepository myRepository; public MyService(){ System.out.println(&quot;MyService Constructor Called&quot;); } @Autowired public void setMyRepository(MyRepository myRepository){ System.out.println(&quot;setMyRepository Called&quot;); this.myRepository = myRepository; } @PostConstruct public void postConstruct(){ System.out.println(&quot;postConstruct Called&quot;); } public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } 위와 같이 @PostConstruct 어노테이션을 함수 위에 붙이는 경우, 아래와 같은 순서로 호출이 진행된다. MyService 클래스의 생성자 setMyRepository 메서드 postConstruct 메서드 그렇다면 @PostConstruct 어노테이션이 붙은 메서드에 인자를 추가할 수 있을까? 아래와 같이 @PostConstruct 어노테이션이 붙은 메서드에 인자를 추가해보았다. @PostConstruct public void postConstruct(String author){ System.out.println(&quot;postConstruct Called&quot;); } 호출해보면 아래와 같은 오류가 발생한다. Exception in thread &quot;main&quot; org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;getMyService&#39; defined in com.leeyh0216.springstudy.initializingbean.AppConfig: Post-processing of merged bean definition failed; nested exception is java.lang.IllegalStateException: Lifecycle method annotation requires a no-arg method: public void com.leeyh0216.springstudy.initializingbean.MyService.postConstruct(java.lang.String) Lifecycle method annotation requires a no-arg method. 즉, Lifecycle 관련 Annotation이 붙은 메서드는 Argument를 가질 수 없다는 의미이다. @PostConstruct vs afterPropertiesSet 그렇다면 @PostConstruct와 afterPropertiesSet 둘 모두를 구현하는 경우 어떻게 동작할까? 아래와 같이 MyService 클래스를 만든 후, Application을 동작시켜보았다. package com.leeyh0216.springstudy.initializingbean; import org.springframework.beans.factory.InitializingBean; import org.springframework.beans.factory.annotation.Autowired; import javax.annotation.PostConstruct; public class MyService implements InitializingBean { private static final String SERVICE_NAME = &quot;MY_SERVICE&quot;; private MyRepository myRepository; public MyService(){ System.out.println(&quot;MyService Constructor Called&quot;); } @Autowired public void setMyRepository(MyRepository myRepository){ System.out.println(&quot;setMyRepository Called&quot;); this.myRepository = myRepository; } @Override public void afterPropertiesSet() throws Exception { System.out.println(&quot;afterPropertiesSet Called&quot;); } @PostConstruct public void postConstruct(){ System.out.println(&quot;postConstruct Called&quot;); } public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } 호출 결과 아래와 같은 로그가 발생하였다. MyService Constructor Called setMyRepository Called postConstruct Called afterPropertiesSet Called 즉, @PostConstruct 어노테이션이 붙은 메서드가 afterPropertiesSet 메서드보다 우선순위가 높은 것을 확인할 수 있다. DisposableBean 인터페이스를 상속하는 방법 Bean이 파괴될 때(대부분 Application이 종료될 때) 호출되는 메소드를 구현할 수 있는 인터페이스이다. void destroy() 메소드를 구현해야 한다. 아래와 같이 DisposableBean 인터페이스를 구현한 MyService 클래스를 구현해보았다. package com.leeyh0216.springstudy.initializingbean; import org.springframework.beans.factory.DisposableBean; public class MyService implements DisposableBean { private static final String SERVICE_NAME = &quot;MY_SERVICE&quot;; private MyRepository myRepository; public MyService(){ System.out.println(&quot;MyService Constructor Called&quot;); } @Override public void destroy() throws Exception { System.out.println(&quot;destroy Called&quot;); } public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } 이대로 실행시켜보면 “destroyCalled” 라는 메시지가 남지 않고 Application이 종료되는 것을 확인할 수 있다. ApplicationContext가 종료될 때 Bean들의 destroy 메소드를 호출하는데, ApplicationContext가 종료되는 시점을 인지시키기 위해서는, AbstractApplicationContext의 registerShutdownHook() 메서드를 호출해주어야 한다. 즉, 변경된 Application 클래스 코드는 아래와 같다. package com.leeyh0216.springstudy.initializingbean; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; import org.springframework.context.support.AbstractApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext= new AnnotationConfigApplicationContext(AppConfig.class); MyService myService = applicationContext.getBean(MyService.class); myService.printServiceName(); ((AbstractApplicationContext)applicationContext).registerShutdownHook(); } } 위와 같이 코드를 변경하면 destroy 메서드가 정상적으로 호출되는 것을 확인할 수 있다. @PreDestroy 어노테이션을 붙인 메서드를 만드는 방법 Bean 클래스 내에 @PreDestroy 어노테이션을 붙인 메서드를 만드는 경우, BeanFactory가 객체를 파괴하기 전에(혹은 객체가 파괴되기 전에) @PreDestory 어노테이션을 붙인 함수를 호출하게 된다. 아래와 같이 MyService에 @PreDestory 어노테이션이 붙은 메서드를 구현해보자. package com.leeyh0216.springstudy.initializingbean; import org.springframework.beans.factory.DisposableBean; import javax.annotation.PreDestroy; public class MyService{ private static final String SERVICE_NAME = &quot;MY_SERVICE&quot;; private MyRepository myRepository; public MyService(){ System.out.println(&quot;MyService Constructor Called&quot;); } @PreDestroy public void destroy(){ System.out.println(&quot;destroy Called&quot;); } public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } Application이 종료되기 전에 “destroy Called” 메시지가 발생하는 것을 볼 수 있다. @PreDestory vs destroy() 그렇다면 @PostConstruct와 afterPropertiesSet() 과 같이 우선순위가 존재할까? 아래와 같이 코드를 작성한 후 실행해보았다. package com.leeyh0216.springstudy.initializingbean; import org.springframework.beans.factory.DisposableBean; import javax.annotation.PreDestroy; public class MyService implements DisposableBean{ private static final String SERVICE_NAME = &quot;MY_SERVICE&quot;; private MyRepository myRepository; public MyService(){ System.out.println(&quot;MyService Constructor Called&quot;); } @Override public void destroy(){ System.out.println(&quot;destroy Called&quot;); } @PreDestroy public void preDestory(){ System.out.println(&quot;preDestroy Called&quot;); } public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } 호출 결과 아래와 같은 로그가 발생하였다. preDestory Called destroy Called 즉, @PreDestory 어노테이션이 destroy() 메서드보다 높은 우선순위를 갖는 것을 볼 수 있다. 결론적으로 Lifecycle 메서드들은 인터페이스보다 어노테이션 붙은 메서드의 호출 우선순위가 더 높은 것을 확인할 수 있었다." />
<meta property="og:description" content="The IoC Container Introduction to the Spring IoC Container and Beans Bean Dependencies Application에 Service Layer 역할을 하는 MyService와 Persistent Layer 역할을 하는 MyRepository 클래스가 있다고 가정해보자. MyService 클래스가 동작하기 위해서는 MyRepository 객체가 필요하다.(즉, MyService 클래스가 MyRepository 클래스에 의존적이다) 이러한 경우 아래와 같은 코드를 작성해야 할까? package com.leeyh0216.springstudy.beandependencies; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class AppConfig { @Bean public MyService getMyService(){ return new MyService(new MyRepository()); } } getMyService 함수에서 MyService 객체 초기화 시, MyRepository 객체 또한 같이 초기화하여 생성자로 전달하고 있다. 이러한 방식을 사용할 경우, MyService의 의존 객체가 많을 경우 getMyService 함수 또한 비대해진다. ApplicationContext는 모든 Bean을 관리하고, @Bean 어노테이션이 붙은 함수의 인자와 일치하는 Bean을 찾아 주입시켜주는 기능을 가지고 있다. 즉, 아래와 같이 MyRepository Bean을 초기화하는 @Bean 어노테이션이 붙은 메소드를 만들고, getMyService 함수의 인자로는 MyService를 초기화하는데 필요한 MyRepository를 선언한다. 그러면 Spring의 ApplicationContext는 MyRepository Bean을 먼저 getMyRepository 함수를 호출하여 초기화하고, MyService Bean 초기화 함수인 getMyService의 인수로 이미 Bean으로 생성되어 있는 MyRepository 객체를 주입시켜준다. package com.leeyh0216.springstudy.beandependencies; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class AppConfig { @Bean public MyRepository getMyRepository(){ return new MyRepository(); } @Bean public MyService getMyService(MyRepository myRepository){ return new MyService(myRepository); } } Receiving Lifecycle Callbacks @Bean 어노테이션으로 초기화되는 객체들은 JSR-250 스펙에 정의된 @PostConstruct와 @PreDestory 어노테이션을 통한 Lifecycle Callback을 호출받을 수 있다. 또한 Spring Framework의 InitializingBean, DisposableBean, Lifecycle을 상속받으면 Container에 의해 Lifecycle을 관리받을 수 있다. InitializingBean을 상속하는 방법 InitializingBean는 Bean이 BeanFactory에 의해 생성되고, 모든 의존성이 주입되어졌을 때 한번 호출되는 함수를 필요로 할 때 구현하는 인터페이스이다. 그렇다면 생성자와 다른 점은 무엇인가? 객체는 생성자 호출 시 필요한 의존 객체를 주입받을 수도 있지만, 생성된 이후에도 Setter를 통해 의존 객체를 주입받을 수 있다. InitializingBean은 이렇게 객체 생성 이후에 Setter를 통해 의존 객체를 주입받는 경우 구현해야하는 인터페이스이다. InitializingBean 인터페이스를 상속받은 클래스는 void afterPropertiesSet() 메서드를 구현해야 한다. 이 함수는 Bean의 의존 객체가 모두 설정된 후 호출된다. 다루지는 않았었지만 @Autowired 어노테이션을 Bean으로 만들 클래스의 Setter에 설정해주면, Bean 생성 시 Setter의 인자와 동일한 객체가 있는 경우 BeanFactory가 주입해준다. 아래와 같은 MyService 클래스가 있다고 생각해보자. package com.leeyh0216.springstudy.initializingbean; import org.springframework.beans.factory.InitializingBean; import org.springframework.beans.factory.annotation.Autowired; public class MyService implements InitializingBean { private static final String SERVICE_NAME = &quot;MY_SERVICE&quot;; private MyRepository myRepository; public MyService(){ System.out.println(&quot;MyService Constructor Called&quot;); } @Autowired public void setMyRepository(MyRepository myRepository){ System.out.println(&quot;setMyRepository Called&quot;); this.myRepository = myRepository; } @Override public void afterPropertiesSet() throws Exception { System.out.println(&quot;afterPropertiesSet Called&quot;); } public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } Spring Application을 호출하면 위 객체의 메서드(혹은 생성자)가 아래와 같은 순서로 호출된다. MyService 클래스의 생성자 setMyRepository 메서드 afterPropertiesSet 메서드 즉, InitializingBean 인터페이스의 afterPropertiesSet() 함수는 생성자 뿐만 아니라, Bean의 의존 객체를 BeanFactory가 모두 Injection 해준 후 호출되는 함수이다. @PostConstruct 어노테이션을 붙인 메서드를 만드는 방법 Bean 클래스 내에 @PostConstruct 어노테이션을 붙인 메서드를 만드는 경우, BeanFactory가 Bean을 생성한 후 해당 함수를 호출하게 된다. package com.leeyh0216.springstudy.initializingbean; import org.springframework.beans.factory.InitializingBean; import org.springframework.beans.factory.annotation.Autowired; import javax.annotation.PostConstruct; public class MyService { private static final String SERVICE_NAME = &quot;MY_SERVICE&quot;; private MyRepository myRepository; public MyService(){ System.out.println(&quot;MyService Constructor Called&quot;); } @Autowired public void setMyRepository(MyRepository myRepository){ System.out.println(&quot;setMyRepository Called&quot;); this.myRepository = myRepository; } @PostConstruct public void postConstruct(){ System.out.println(&quot;postConstruct Called&quot;); } public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } 위와 같이 @PostConstruct 어노테이션을 함수 위에 붙이는 경우, 아래와 같은 순서로 호출이 진행된다. MyService 클래스의 생성자 setMyRepository 메서드 postConstruct 메서드 그렇다면 @PostConstruct 어노테이션이 붙은 메서드에 인자를 추가할 수 있을까? 아래와 같이 @PostConstruct 어노테이션이 붙은 메서드에 인자를 추가해보았다. @PostConstruct public void postConstruct(String author){ System.out.println(&quot;postConstruct Called&quot;); } 호출해보면 아래와 같은 오류가 발생한다. Exception in thread &quot;main&quot; org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;getMyService&#39; defined in com.leeyh0216.springstudy.initializingbean.AppConfig: Post-processing of merged bean definition failed; nested exception is java.lang.IllegalStateException: Lifecycle method annotation requires a no-arg method: public void com.leeyh0216.springstudy.initializingbean.MyService.postConstruct(java.lang.String) Lifecycle method annotation requires a no-arg method. 즉, Lifecycle 관련 Annotation이 붙은 메서드는 Argument를 가질 수 없다는 의미이다. @PostConstruct vs afterPropertiesSet 그렇다면 @PostConstruct와 afterPropertiesSet 둘 모두를 구현하는 경우 어떻게 동작할까? 아래와 같이 MyService 클래스를 만든 후, Application을 동작시켜보았다. package com.leeyh0216.springstudy.initializingbean; import org.springframework.beans.factory.InitializingBean; import org.springframework.beans.factory.annotation.Autowired; import javax.annotation.PostConstruct; public class MyService implements InitializingBean { private static final String SERVICE_NAME = &quot;MY_SERVICE&quot;; private MyRepository myRepository; public MyService(){ System.out.println(&quot;MyService Constructor Called&quot;); } @Autowired public void setMyRepository(MyRepository myRepository){ System.out.println(&quot;setMyRepository Called&quot;); this.myRepository = myRepository; } @Override public void afterPropertiesSet() throws Exception { System.out.println(&quot;afterPropertiesSet Called&quot;); } @PostConstruct public void postConstruct(){ System.out.println(&quot;postConstruct Called&quot;); } public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } 호출 결과 아래와 같은 로그가 발생하였다. MyService Constructor Called setMyRepository Called postConstruct Called afterPropertiesSet Called 즉, @PostConstruct 어노테이션이 붙은 메서드가 afterPropertiesSet 메서드보다 우선순위가 높은 것을 확인할 수 있다. DisposableBean 인터페이스를 상속하는 방법 Bean이 파괴될 때(대부분 Application이 종료될 때) 호출되는 메소드를 구현할 수 있는 인터페이스이다. void destroy() 메소드를 구현해야 한다. 아래와 같이 DisposableBean 인터페이스를 구현한 MyService 클래스를 구현해보았다. package com.leeyh0216.springstudy.initializingbean; import org.springframework.beans.factory.DisposableBean; public class MyService implements DisposableBean { private static final String SERVICE_NAME = &quot;MY_SERVICE&quot;; private MyRepository myRepository; public MyService(){ System.out.println(&quot;MyService Constructor Called&quot;); } @Override public void destroy() throws Exception { System.out.println(&quot;destroy Called&quot;); } public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } 이대로 실행시켜보면 “destroyCalled” 라는 메시지가 남지 않고 Application이 종료되는 것을 확인할 수 있다. ApplicationContext가 종료될 때 Bean들의 destroy 메소드를 호출하는데, ApplicationContext가 종료되는 시점을 인지시키기 위해서는, AbstractApplicationContext의 registerShutdownHook() 메서드를 호출해주어야 한다. 즉, 변경된 Application 클래스 코드는 아래와 같다. package com.leeyh0216.springstudy.initializingbean; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; import org.springframework.context.support.AbstractApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext= new AnnotationConfigApplicationContext(AppConfig.class); MyService myService = applicationContext.getBean(MyService.class); myService.printServiceName(); ((AbstractApplicationContext)applicationContext).registerShutdownHook(); } } 위와 같이 코드를 변경하면 destroy 메서드가 정상적으로 호출되는 것을 확인할 수 있다. @PreDestroy 어노테이션을 붙인 메서드를 만드는 방법 Bean 클래스 내에 @PreDestroy 어노테이션을 붙인 메서드를 만드는 경우, BeanFactory가 객체를 파괴하기 전에(혹은 객체가 파괴되기 전에) @PreDestory 어노테이션을 붙인 함수를 호출하게 된다. 아래와 같이 MyService에 @PreDestory 어노테이션이 붙은 메서드를 구현해보자. package com.leeyh0216.springstudy.initializingbean; import org.springframework.beans.factory.DisposableBean; import javax.annotation.PreDestroy; public class MyService{ private static final String SERVICE_NAME = &quot;MY_SERVICE&quot;; private MyRepository myRepository; public MyService(){ System.out.println(&quot;MyService Constructor Called&quot;); } @PreDestroy public void destroy(){ System.out.println(&quot;destroy Called&quot;); } public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } Application이 종료되기 전에 “destroy Called” 메시지가 발생하는 것을 볼 수 있다. @PreDestory vs destroy() 그렇다면 @PostConstruct와 afterPropertiesSet() 과 같이 우선순위가 존재할까? 아래와 같이 코드를 작성한 후 실행해보았다. package com.leeyh0216.springstudy.initializingbean; import org.springframework.beans.factory.DisposableBean; import javax.annotation.PreDestroy; public class MyService implements DisposableBean{ private static final String SERVICE_NAME = &quot;MY_SERVICE&quot;; private MyRepository myRepository; public MyService(){ System.out.println(&quot;MyService Constructor Called&quot;); } @Override public void destroy(){ System.out.println(&quot;destroy Called&quot;); } @PreDestroy public void preDestory(){ System.out.println(&quot;preDestroy Called&quot;); } public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } 호출 결과 아래와 같은 로그가 발생하였다. preDestory Called destroy Called 즉, @PreDestory 어노테이션이 destroy() 메서드보다 높은 우선순위를 갖는 것을 볼 수 있다. 결론적으로 Lifecycle 메서드들은 인터페이스보다 어노테이션 붙은 메서드의 호출 우선순위가 더 높은 것을 확인할 수 있었다." />
<link rel="canonical" href="http://localhost:4000/2018-12-03/spring-core-3" />
<meta property="og:url" content="http://localhost:4000/2018-12-03/spring-core-3" />
<meta property="og:site_name" content="DevLog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-12-03T10:00:00+09:00" />
<script type="application/ld+json">
{"author":{"@type":"Person","name":"leeyh0216"},"url":"http://localhost:4000/2018-12-03/spring-core-3","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2018-12-03/spring-core-3"},"headline":"Spring Core Technologies - The IoC Container(3)","dateModified":"2018-12-03T10:00:00+09:00","datePublished":"2018-12-03T10:00:00+09:00","description":"The IoC Container Introduction to the Spring IoC Container and Beans Bean Dependencies Application에 Service Layer 역할을 하는 MyService와 Persistent Layer 역할을 하는 MyRepository 클래스가 있다고 가정해보자. MyService 클래스가 동작하기 위해서는 MyRepository 객체가 필요하다.(즉, MyService 클래스가 MyRepository 클래스에 의존적이다) 이러한 경우 아래와 같은 코드를 작성해야 할까? package com.leeyh0216.springstudy.beandependencies; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class AppConfig { @Bean public MyService getMyService(){ return new MyService(new MyRepository()); } } getMyService 함수에서 MyService 객체 초기화 시, MyRepository 객체 또한 같이 초기화하여 생성자로 전달하고 있다. 이러한 방식을 사용할 경우, MyService의 의존 객체가 많을 경우 getMyService 함수 또한 비대해진다. ApplicationContext는 모든 Bean을 관리하고, @Bean 어노테이션이 붙은 함수의 인자와 일치하는 Bean을 찾아 주입시켜주는 기능을 가지고 있다. 즉, 아래와 같이 MyRepository Bean을 초기화하는 @Bean 어노테이션이 붙은 메소드를 만들고, getMyService 함수의 인자로는 MyService를 초기화하는데 필요한 MyRepository를 선언한다. 그러면 Spring의 ApplicationContext는 MyRepository Bean을 먼저 getMyRepository 함수를 호출하여 초기화하고, MyService Bean 초기화 함수인 getMyService의 인수로 이미 Bean으로 생성되어 있는 MyRepository 객체를 주입시켜준다. package com.leeyh0216.springstudy.beandependencies; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class AppConfig { @Bean public MyRepository getMyRepository(){ return new MyRepository(); } @Bean public MyService getMyService(MyRepository myRepository){ return new MyService(myRepository); } } Receiving Lifecycle Callbacks @Bean 어노테이션으로 초기화되는 객체들은 JSR-250 스펙에 정의된 @PostConstruct와 @PreDestory 어노테이션을 통한 Lifecycle Callback을 호출받을 수 있다. 또한 Spring Framework의 InitializingBean, DisposableBean, Lifecycle을 상속받으면 Container에 의해 Lifecycle을 관리받을 수 있다. InitializingBean을 상속하는 방법 InitializingBean는 Bean이 BeanFactory에 의해 생성되고, 모든 의존성이 주입되어졌을 때 한번 호출되는 함수를 필요로 할 때 구현하는 인터페이스이다. 그렇다면 생성자와 다른 점은 무엇인가? 객체는 생성자 호출 시 필요한 의존 객체를 주입받을 수도 있지만, 생성된 이후에도 Setter를 통해 의존 객체를 주입받을 수 있다. InitializingBean은 이렇게 객체 생성 이후에 Setter를 통해 의존 객체를 주입받는 경우 구현해야하는 인터페이스이다. InitializingBean 인터페이스를 상속받은 클래스는 void afterPropertiesSet() 메서드를 구현해야 한다. 이 함수는 Bean의 의존 객체가 모두 설정된 후 호출된다. 다루지는 않았었지만 @Autowired 어노테이션을 Bean으로 만들 클래스의 Setter에 설정해주면, Bean 생성 시 Setter의 인자와 동일한 객체가 있는 경우 BeanFactory가 주입해준다. 아래와 같은 MyService 클래스가 있다고 생각해보자. package com.leeyh0216.springstudy.initializingbean; import org.springframework.beans.factory.InitializingBean; import org.springframework.beans.factory.annotation.Autowired; public class MyService implements InitializingBean { private static final String SERVICE_NAME = &quot;MY_SERVICE&quot;; private MyRepository myRepository; public MyService(){ System.out.println(&quot;MyService Constructor Called&quot;); } @Autowired public void setMyRepository(MyRepository myRepository){ System.out.println(&quot;setMyRepository Called&quot;); this.myRepository = myRepository; } @Override public void afterPropertiesSet() throws Exception { System.out.println(&quot;afterPropertiesSet Called&quot;); } public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } Spring Application을 호출하면 위 객체의 메서드(혹은 생성자)가 아래와 같은 순서로 호출된다. MyService 클래스의 생성자 setMyRepository 메서드 afterPropertiesSet 메서드 즉, InitializingBean 인터페이스의 afterPropertiesSet() 함수는 생성자 뿐만 아니라, Bean의 의존 객체를 BeanFactory가 모두 Injection 해준 후 호출되는 함수이다. @PostConstruct 어노테이션을 붙인 메서드를 만드는 방법 Bean 클래스 내에 @PostConstruct 어노테이션을 붙인 메서드를 만드는 경우, BeanFactory가 Bean을 생성한 후 해당 함수를 호출하게 된다. package com.leeyh0216.springstudy.initializingbean; import org.springframework.beans.factory.InitializingBean; import org.springframework.beans.factory.annotation.Autowired; import javax.annotation.PostConstruct; public class MyService { private static final String SERVICE_NAME = &quot;MY_SERVICE&quot;; private MyRepository myRepository; public MyService(){ System.out.println(&quot;MyService Constructor Called&quot;); } @Autowired public void setMyRepository(MyRepository myRepository){ System.out.println(&quot;setMyRepository Called&quot;); this.myRepository = myRepository; } @PostConstruct public void postConstruct(){ System.out.println(&quot;postConstruct Called&quot;); } public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } 위와 같이 @PostConstruct 어노테이션을 함수 위에 붙이는 경우, 아래와 같은 순서로 호출이 진행된다. MyService 클래스의 생성자 setMyRepository 메서드 postConstruct 메서드 그렇다면 @PostConstruct 어노테이션이 붙은 메서드에 인자를 추가할 수 있을까? 아래와 같이 @PostConstruct 어노테이션이 붙은 메서드에 인자를 추가해보았다. @PostConstruct public void postConstruct(String author){ System.out.println(&quot;postConstruct Called&quot;); } 호출해보면 아래와 같은 오류가 발생한다. Exception in thread &quot;main&quot; org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;getMyService&#39; defined in com.leeyh0216.springstudy.initializingbean.AppConfig: Post-processing of merged bean definition failed; nested exception is java.lang.IllegalStateException: Lifecycle method annotation requires a no-arg method: public void com.leeyh0216.springstudy.initializingbean.MyService.postConstruct(java.lang.String) Lifecycle method annotation requires a no-arg method. 즉, Lifecycle 관련 Annotation이 붙은 메서드는 Argument를 가질 수 없다는 의미이다. @PostConstruct vs afterPropertiesSet 그렇다면 @PostConstruct와 afterPropertiesSet 둘 모두를 구현하는 경우 어떻게 동작할까? 아래와 같이 MyService 클래스를 만든 후, Application을 동작시켜보았다. package com.leeyh0216.springstudy.initializingbean; import org.springframework.beans.factory.InitializingBean; import org.springframework.beans.factory.annotation.Autowired; import javax.annotation.PostConstruct; public class MyService implements InitializingBean { private static final String SERVICE_NAME = &quot;MY_SERVICE&quot;; private MyRepository myRepository; public MyService(){ System.out.println(&quot;MyService Constructor Called&quot;); } @Autowired public void setMyRepository(MyRepository myRepository){ System.out.println(&quot;setMyRepository Called&quot;); this.myRepository = myRepository; } @Override public void afterPropertiesSet() throws Exception { System.out.println(&quot;afterPropertiesSet Called&quot;); } @PostConstruct public void postConstruct(){ System.out.println(&quot;postConstruct Called&quot;); } public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } 호출 결과 아래와 같은 로그가 발생하였다. MyService Constructor Called setMyRepository Called postConstruct Called afterPropertiesSet Called 즉, @PostConstruct 어노테이션이 붙은 메서드가 afterPropertiesSet 메서드보다 우선순위가 높은 것을 확인할 수 있다. DisposableBean 인터페이스를 상속하는 방법 Bean이 파괴될 때(대부분 Application이 종료될 때) 호출되는 메소드를 구현할 수 있는 인터페이스이다. void destroy() 메소드를 구현해야 한다. 아래와 같이 DisposableBean 인터페이스를 구현한 MyService 클래스를 구현해보았다. package com.leeyh0216.springstudy.initializingbean; import org.springframework.beans.factory.DisposableBean; public class MyService implements DisposableBean { private static final String SERVICE_NAME = &quot;MY_SERVICE&quot;; private MyRepository myRepository; public MyService(){ System.out.println(&quot;MyService Constructor Called&quot;); } @Override public void destroy() throws Exception { System.out.println(&quot;destroy Called&quot;); } public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } 이대로 실행시켜보면 “destroyCalled” 라는 메시지가 남지 않고 Application이 종료되는 것을 확인할 수 있다. ApplicationContext가 종료될 때 Bean들의 destroy 메소드를 호출하는데, ApplicationContext가 종료되는 시점을 인지시키기 위해서는, AbstractApplicationContext의 registerShutdownHook() 메서드를 호출해주어야 한다. 즉, 변경된 Application 클래스 코드는 아래와 같다. package com.leeyh0216.springstudy.initializingbean; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; import org.springframework.context.support.AbstractApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext= new AnnotationConfigApplicationContext(AppConfig.class); MyService myService = applicationContext.getBean(MyService.class); myService.printServiceName(); ((AbstractApplicationContext)applicationContext).registerShutdownHook(); } } 위와 같이 코드를 변경하면 destroy 메서드가 정상적으로 호출되는 것을 확인할 수 있다. @PreDestroy 어노테이션을 붙인 메서드를 만드는 방법 Bean 클래스 내에 @PreDestroy 어노테이션을 붙인 메서드를 만드는 경우, BeanFactory가 객체를 파괴하기 전에(혹은 객체가 파괴되기 전에) @PreDestory 어노테이션을 붙인 함수를 호출하게 된다. 아래와 같이 MyService에 @PreDestory 어노테이션이 붙은 메서드를 구현해보자. package com.leeyh0216.springstudy.initializingbean; import org.springframework.beans.factory.DisposableBean; import javax.annotation.PreDestroy; public class MyService{ private static final String SERVICE_NAME = &quot;MY_SERVICE&quot;; private MyRepository myRepository; public MyService(){ System.out.println(&quot;MyService Constructor Called&quot;); } @PreDestroy public void destroy(){ System.out.println(&quot;destroy Called&quot;); } public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } Application이 종료되기 전에 “destroy Called” 메시지가 발생하는 것을 볼 수 있다. @PreDestory vs destroy() 그렇다면 @PostConstruct와 afterPropertiesSet() 과 같이 우선순위가 존재할까? 아래와 같이 코드를 작성한 후 실행해보았다. package com.leeyh0216.springstudy.initializingbean; import org.springframework.beans.factory.DisposableBean; import javax.annotation.PreDestroy; public class MyService implements DisposableBean{ private static final String SERVICE_NAME = &quot;MY_SERVICE&quot;; private MyRepository myRepository; public MyService(){ System.out.println(&quot;MyService Constructor Called&quot;); } @Override public void destroy(){ System.out.println(&quot;destroy Called&quot;); } @PreDestroy public void preDestory(){ System.out.println(&quot;preDestroy Called&quot;); } public void printServiceName(){ System.out.println(&quot;My Service: &quot; + SERVICE_NAME); } } 호출 결과 아래와 같은 로그가 발생하였다. preDestory Called destroy Called 즉, @PreDestory 어노테이션이 destroy() 메서드보다 높은 우선순위를 갖는 것을 볼 수 있다. 결론적으로 Lifecycle 메서드들은 인터페이스보다 어노테이션 붙은 메서드의 호출 우선순위가 더 높은 것을 확인할 수 있었다.","@type":"BlogPosting","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


  <!-- CSS -->
  <link rel="stylesheet" href="/assets/main.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">

  <!-- Favicon -->
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png">

  <!-- RSS -->
  <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="DevLog" />

  <!-- Google Analytics-->
  <script data-ad-client="ca-pub-8829030678254956" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
</head>


  <body>

    <nav class="nav">
  <div class="nav-container">
    <a href="/">
      <h2 class="nav-title">DevLog</h2>
    </a>
    <ul>
      <li><a href="/about">About</a></li>
      <li><a href="/">Posts</a></li>
      <li><a href="/tags">Tags</a></li>
    </ul>
  </div>
</nav>


    <main>
      <div class="post">
  <div class="post-info">
    <span>Written by</span>
    
        leeyh0216
    

    
      <br>
      <span>on&nbsp;</span><time datetime="2018-12-03 10:00:00 +0900">December 03, 2018</time>
    
    
    
      <br>
      <span>
      
      </span>
    
  </span>
  </div>

  <h1 class="post-title">Spring Core Technologies - The IoC Container(3)</h1>
  <div class="post-line"></div>

  <h1 id="the-ioc-container">The IoC Container</h1>

<h2 id="introduction-to-the-spring-ioc-container-and-beans">Introduction to the Spring IoC Container and Beans</h2>

<h3 id="bean-dependencies">Bean Dependencies</h3>

<p>Application에 Service Layer 역할을 하는 MyService와 Persistent Layer 역할을 하는 MyRepository 클래스가 있다고 가정해보자.</p>

<p>MyService 클래스가 동작하기 위해서는 MyRepository 객체가 필요하다.(즉, MyService 클래스가 MyRepository 클래스에 의존적이다)</p>

<p>이러한 경우 아래와 같은 코드를 작성해야 할까?</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leeyh0216</span><span class="o">.</span><span class="na">springstudy</span><span class="o">.</span><span class="na">beandependencies</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Bean</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Configuration</span><span class="o">;</span>

<span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">MyService</span> <span class="nf">getMyService</span><span class="o">(){</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">MyService</span><span class="o">(</span><span class="k">new</span> <span class="nc">MyRepository</span><span class="o">());</span>
    <span class="o">}</span>

<span class="o">}</span></code></pre></figure>

<p><code class="highlighter-rouge">getMyService</code> 함수에서 MyService 객체 초기화 시, MyRepository 객체 또한 같이 초기화하여 생성자로 전달하고 있다. 이러한 방식을 사용할 경우, MyService의 의존 객체가 많을 경우 <code class="highlighter-rouge">getMyService</code> 함수 또한 비대해진다.</p>

<p>ApplicationContext는 모든 Bean을 관리하고, @Bean 어노테이션이 붙은 함수의 인자와 일치하는 Bean을 찾아 주입시켜주는 기능을 가지고 있다.</p>

<p>즉, 아래와 같이 MyRepository Bean을 초기화하는 @Bean 어노테이션이 붙은 메소드를 만들고, <code class="highlighter-rouge">getMyService</code> 함수의 인자로는 MyService를 초기화하는데 필요한 MyRepository를 선언한다. 그러면 Spring의 ApplicationContext는 <code class="highlighter-rouge">MyRepository</code> Bean을 먼저 getMyRepository 함수를 호출하여 초기화하고, <code class="highlighter-rouge">MyService</code> Bean 초기화 함수인 <code class="highlighter-rouge">getMyService</code>의 인수로 이미 Bean으로 생성되어 있는 <code class="highlighter-rouge">MyRepository</code> 객체를 주입시켜준다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leeyh0216</span><span class="o">.</span><span class="na">springstudy</span><span class="o">.</span><span class="na">beandependencies</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Bean</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Configuration</span><span class="o">;</span>

<span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">MyRepository</span> <span class="nf">getMyRepository</span><span class="o">(){</span> <span class="k">return</span> <span class="k">new</span> <span class="nc">MyRepository</span><span class="o">();</span> <span class="o">}</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">MyService</span> <span class="nf">getMyService</span><span class="o">(</span><span class="nc">MyRepository</span> <span class="n">myRepository</span><span class="o">){</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">MyService</span><span class="o">(</span><span class="n">myRepository</span><span class="o">);</span>
    <span class="o">}</span>

<span class="o">}</span></code></pre></figure>

<h3 id="receiving-lifecycle-callbacks">Receiving Lifecycle Callbacks</h3>

<p>@Bean 어노테이션으로 초기화되는 객체들은 JSR-250 스펙에 정의된 @PostConstruct와 @PreDestory 어노테이션을 통한 Lifecycle Callback을 호출받을 수 있다.</p>

<p>또한 Spring Framework의 <code class="highlighter-rouge">InitializingBean</code>, <code class="highlighter-rouge">DisposableBean</code>, <code class="highlighter-rouge">Lifecycle</code>을 상속받으면 Container에 의해 Lifecycle을 관리받을 수 있다.</p>

<h4 id="initializingbean을-상속하는-방법">InitializingBean을 상속하는 방법</h4>

<p><code class="highlighter-rouge">InitializingBean</code>는 Bean이 <code class="highlighter-rouge">BeanFactory</code>에 의해 생성되고, 모든 의존성이 주입되어졌을 때 한번 호출되는 함수를 필요로 할 때 구현하는 인터페이스이다.</p>

<p>그렇다면 생성자와 다른 점은 무엇인가?</p>

<p>객체는 생성자 호출 시 필요한 의존 객체를 주입받을 수도 있지만, 생성된 이후에도 Setter를 통해 의존 객체를 주입받을 수 있다. <code class="highlighter-rouge">InitializingBean</code>은 이렇게 객체 생성 이후에 Setter를 통해 의존 객체를 주입받는 경우 구현해야하는 인터페이스이다.</p>

<p><code class="highlighter-rouge">InitializingBean</code> 인터페이스를 상속받은 클래스는 <code class="highlighter-rouge">void afterPropertiesSet()</code> 메서드를 구현해야 한다. 이 함수는 Bean의 의존 객체가 모두 설정된 후 호출된다.</p>

<p>다루지는 않았었지만 <code class="highlighter-rouge">@Autowired</code> 어노테이션을 Bean으로 만들 클래스의 Setter에 설정해주면, Bean 생성 시 Setter의 인자와 동일한 객체가 있는 경우 BeanFactory가 주입해준다.</p>

<p>아래와 같은 MyService 클래스가 있다고 생각해보자.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leeyh0216</span><span class="o">.</span><span class="na">springstudy</span><span class="o">.</span><span class="na">initializingbean</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.InitializingBean</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.annotation.Autowired</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyService</span> <span class="kd">implements</span> <span class="nc">InitializingBean</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">SERVICE_NAME</span> <span class="o">=</span> <span class="s">"MY_SERVICE"</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">MyRepository</span> <span class="n">myRepository</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MyService</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"MyService Constructor Called"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Autowired</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setMyRepository</span><span class="o">(</span><span class="nc">MyRepository</span> <span class="n">myRepository</span><span class="o">){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"setMyRepository Called"</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">myRepository</span> <span class="o">=</span> <span class="n">myRepository</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">afterPropertiesSet</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"afterPropertiesSet Called"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printServiceName</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"My Service: "</span> <span class="o">+</span> <span class="no">SERVICE_NAME</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>Spring Application을 호출하면 위 객체의 메서드(혹은 생성자)가 아래와 같은 순서로 호출된다.</p>

<ol>
  <li><code class="highlighter-rouge">MyService</code> 클래스의 생성자</li>
  <li><code class="highlighter-rouge">setMyRepository</code> 메서드</li>
  <li><code class="highlighter-rouge">afterPropertiesSet</code> 메서드</li>
</ol>

<p>즉, <code class="highlighter-rouge">InitializingBean</code> 인터페이스의 <code class="highlighter-rouge">afterPropertiesSet()</code> 함수는 생성자 뿐만 아니라, Bean의 의존 객체를 BeanFactory가 모두 Injection 해준 후 호출되는 함수이다.</p>

<h4 id="postconstruct-어노테이션을-붙인-메서드를-만드는-방법"><code class="highlighter-rouge">@PostConstruct</code> 어노테이션을 붙인 메서드를 만드는 방법</h4>

<p>Bean 클래스 내에 @PostConstruct 어노테이션을 붙인 메서드를 만드는 경우, BeanFactory가 Bean을 생성한 후 해당 함수를 호출하게 된다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leeyh0216</span><span class="o">.</span><span class="na">springstudy</span><span class="o">.</span><span class="na">initializingbean</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.InitializingBean</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.annotation.Autowired</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.annotation.PostConstruct</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyService</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">SERVICE_NAME</span> <span class="o">=</span> <span class="s">"MY_SERVICE"</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">MyRepository</span> <span class="n">myRepository</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MyService</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"MyService Constructor Called"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Autowired</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setMyRepository</span><span class="o">(</span><span class="nc">MyRepository</span> <span class="n">myRepository</span><span class="o">){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"setMyRepository Called"</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">myRepository</span> <span class="o">=</span> <span class="n">myRepository</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@PostConstruct</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">postConstruct</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"postConstruct Called"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printServiceName</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"My Service: "</span> <span class="o">+</span> <span class="no">SERVICE_NAME</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>위와 같이 <code class="highlighter-rouge">@PostConstruct</code> 어노테이션을 함수 위에 붙이는 경우, 아래와 같은 순서로 호출이 진행된다.</p>

<ol>
  <li><code class="highlighter-rouge">MyService</code> 클래스의 생성자</li>
  <li><code class="highlighter-rouge">setMyRepository</code> 메서드</li>
  <li><code class="highlighter-rouge">postConstruct</code> 메서드</li>
</ol>

<p>그렇다면 <code class="highlighter-rouge">@PostConstruct</code> 어노테이션이 붙은 메서드에 인자를 추가할 수 있을까? 아래와 같이 <code class="highlighter-rouge">@PostConstruct</code> 어노테이션이 붙은 메서드에 인자를 추가해보았다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nd">@PostConstruct</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">postConstruct</span><span class="o">(</span><span class="nc">String</span> <span class="n">author</span><span class="o">){</span>
    <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"postConstruct Called"</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>호출해보면 아래와 같은 오류가 발생한다.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">Exception in thread "main" org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'getMyService' defined in com.leeyh0216.springstudy.initializingbean.AppConfig: Post-processing of merged bean definition failed; nested exception is java.lang.IllegalStateException: Lifecycle method annotation requires a no-arg method: public void com.leeyh0216.springstudy.initializingbean.MyService.postConstruct(java.lang.String)</code></pre></figure>

<p><em>Lifecycle method annotation requires a no-arg method</em>. 즉, Lifecycle 관련 Annotation이 붙은 메서드는 Argument를 가질 수 없다는 의미이다.</p>

<h4 id="postconstruct-vs-afterpropertiesset"><code class="highlighter-rouge">@PostConstruct</code> vs <code class="highlighter-rouge">afterPropertiesSet</code></h4>

<p>그렇다면 <code class="highlighter-rouge">@PostConstruct</code>와 <code class="highlighter-rouge">afterPropertiesSet</code> 둘 모두를 구현하는 경우 어떻게 동작할까?</p>

<p>아래와 같이 MyService 클래스를 만든 후, Application을 동작시켜보았다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leeyh0216</span><span class="o">.</span><span class="na">springstudy</span><span class="o">.</span><span class="na">initializingbean</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.InitializingBean</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.annotation.Autowired</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.annotation.PostConstruct</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyService</span> <span class="kd">implements</span> <span class="nc">InitializingBean</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">SERVICE_NAME</span> <span class="o">=</span> <span class="s">"MY_SERVICE"</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">MyRepository</span> <span class="n">myRepository</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MyService</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"MyService Constructor Called"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Autowired</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setMyRepository</span><span class="o">(</span><span class="nc">MyRepository</span> <span class="n">myRepository</span><span class="o">){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"setMyRepository Called"</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">myRepository</span> <span class="o">=</span> <span class="n">myRepository</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">afterPropertiesSet</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"afterPropertiesSet Called"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@PostConstruct</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">postConstruct</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"postConstruct Called"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printServiceName</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"My Service: "</span> <span class="o">+</span> <span class="no">SERVICE_NAME</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>호출 결과 아래와 같은 로그가 발생하였다.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">MyService Constructor Called
setMyRepository Called
postConstruct Called
afterPropertiesSet Called</code></pre></figure>

<p>즉, <code class="highlighter-rouge">@PostConstruct</code> 어노테이션이 붙은 메서드가 <code class="highlighter-rouge">afterPropertiesSet</code> 메서드보다 우선순위가 높은 것을 확인할 수 있다.</p>

<h4 id="disposablebean-인터페이스를-상속하는-방법"><code class="highlighter-rouge">DisposableBean</code> 인터페이스를 상속하는 방법</h4>

<p>Bean이 파괴될 때(대부분 Application이 종료될 때) 호출되는 메소드를 구현할 수 있는 인터페이스이다. <code class="highlighter-rouge">void destroy()</code> 메소드를 구현해야 한다.</p>

<p>아래와 같이 <code class="highlighter-rouge">DisposableBean</code> 인터페이스를 구현한 MyService 클래스를 구현해보았다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leeyh0216</span><span class="o">.</span><span class="na">springstudy</span><span class="o">.</span><span class="na">initializingbean</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.DisposableBean</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyService</span> <span class="kd">implements</span> <span class="nc">DisposableBean</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">SERVICE_NAME</span> <span class="o">=</span> <span class="s">"MY_SERVICE"</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">MyRepository</span> <span class="n">myRepository</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MyService</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"MyService Constructor Called"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">destroy</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"destroy Called"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printServiceName</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"My Service: "</span> <span class="o">+</span> <span class="no">SERVICE_NAME</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>이대로 실행시켜보면 “destroyCalled” 라는 메시지가 남지 않고 Application이 종료되는 것을 확인할 수 있다.</p>

<p>ApplicationContext가 종료될 때 Bean들의 destroy 메소드를 호출하는데, ApplicationContext가 종료되는 시점을 인지시키기 위해서는, AbstractApplicationContext의 <code class="highlighter-rouge">registerShutdownHook()</code> 메서드를 호출해주어야 한다.</p>

<p>즉, 변경된 Application 클래스 코드는 아래와 같다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leeyh0216</span><span class="o">.</span><span class="na">springstudy</span><span class="o">.</span><span class="na">initializingbean</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.context.ApplicationContext</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.AnnotationConfigApplicationContext</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.support.AbstractApplicationContext</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Application</span> <span class="o">{</span>


    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">ApplicationContext</span> <span class="n">applicationContext</span><span class="o">=</span> <span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">AppConfig</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">MyService</span> <span class="n">myService</span> <span class="o">=</span> <span class="n">applicationContext</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">MyService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">myService</span><span class="o">.</span><span class="na">printServiceName</span><span class="o">();</span>

        <span class="o">((</span><span class="nc">AbstractApplicationContext</span><span class="o">)</span><span class="n">applicationContext</span><span class="o">).</span><span class="na">registerShutdownHook</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>위와 같이 코드를 변경하면 destroy 메서드가 정상적으로 호출되는 것을 확인할 수 있다.</p>

<h4 id="predestroy-어노테이션을-붙인-메서드를-만드는-방법"><code class="highlighter-rouge">@PreDestroy</code> 어노테이션을 붙인 메서드를 만드는 방법</h4>

<p>Bean 클래스 내에 <code class="highlighter-rouge">@PreDestroy</code> 어노테이션을 붙인 메서드를 만드는 경우, BeanFactory가 객체를 파괴하기 전에(혹은 객체가 파괴되기 전에) <code class="highlighter-rouge">@PreDestory</code> 어노테이션을 붙인 함수를 호출하게 된다.</p>

<p>아래와 같이 MyService에 <code class="highlighter-rouge">@PreDestory</code> 어노테이션이 붙은 메서드를 구현해보자.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leeyh0216</span><span class="o">.</span><span class="na">springstudy</span><span class="o">.</span><span class="na">initializingbean</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.DisposableBean</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.annotation.PreDestroy</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyService</span><span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">SERVICE_NAME</span> <span class="o">=</span> <span class="s">"MY_SERVICE"</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">MyRepository</span> <span class="n">myRepository</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MyService</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"MyService Constructor Called"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@PreDestroy</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">destroy</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"destroy Called"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printServiceName</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"My Service: "</span> <span class="o">+</span> <span class="no">SERVICE_NAME</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>Application이 종료되기 전에 “destroy Called” 메시지가 발생하는 것을 볼 수 있다.</p>

<h4 id="predestory-vs-destroy"><code class="highlighter-rouge">@PreDestory</code> vs <code class="highlighter-rouge">destroy()</code></h4>

<p>그렇다면 <code class="highlighter-rouge">@PostConstruct</code>와 <code class="highlighter-rouge">afterPropertiesSet()</code> 과 같이 우선순위가 존재할까? 아래와 같이 코드를 작성한 후 실행해보았다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leeyh0216</span><span class="o">.</span><span class="na">springstudy</span><span class="o">.</span><span class="na">initializingbean</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.beans.factory.DisposableBean</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.annotation.PreDestroy</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyService</span> <span class="kd">implements</span> <span class="nc">DisposableBean</span><span class="o">{</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">String</span> <span class="no">SERVICE_NAME</span> <span class="o">=</span> <span class="s">"MY_SERVICE"</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">MyRepository</span> <span class="n">myRepository</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">MyService</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"MyService Constructor Called"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">destroy</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"destroy Called"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@PreDestroy</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">preDestory</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"preDestroy Called"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">printServiceName</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"My Service: "</span> <span class="o">+</span> <span class="no">SERVICE_NAME</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>호출 결과 아래와 같은 로그가 발생하였다.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">preDestory Called
destroy Called</code></pre></figure>

<p>즉, <code class="highlighter-rouge">@PreDestory</code> 어노테이션이 <code class="highlighter-rouge">destroy()</code> 메서드보다 높은 우선순위를 갖는 것을 볼 수 있다.</p>

<p><strong>결론적으로 Lifecycle 메서드들은 인터페이스보다 어노테이션 붙은 메서드의 호출 우선순위가 더 높은 것을 확인할 수 있었다.</strong></p>


</div>

<div class="pagination">
  
    <a href="/2018-12-19/ioc_and_di_pattern" class="left arrow">&#8592;</a>
  
  
    <a href="/2018-11-29/spring-core-2" class="right arrow">&#8594;</a>
  

  <a href="#" class="top">Top</a>
</div>

    </main>

    <footer>
  <span>
    &copy; <time datetime="2019-11-05 21:14:23 +0900">2019</time> leeyh0216. Made with Jekyll using the <a href="https://github.com/chesterhow/tale/">Tale</a> theme.
  </span>
</footer>

  </body>
</html>
