<!DOCTYPE html>
<html lang="en">

  <head>
  
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Spring + MongoDB + Docker 조합 사용 테스트 | DevLog</title>
<meta name="generator" content="Jekyll v3.8.6" />
<meta property="og:title" content="Spring + MongoDB + Docker 조합 사용 테스트" />
<meta name="author" content="leeyh0216" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="프로젝트 초기화 git 초기화 Git 페이지에서 spring_mongodb_docker Repository를 초기화한다. git pull https://github.com/leeyh0216/spring_mongodb_docker.git 명령어를 통해 로컬로 Clone 한다. gitignore.io 페이지에서 gradle, java, intellij로 초기화한 .gitignore을 디렉토리에 추가한다. Spring Project 초기화 최상위 디렉토리 아래에 spring-boot-test 라는 이름으로 디렉토리를 생성한다. spring-boot-test에서 gradle init 명령어로 gradle 프로젝트를 초기화한다. build.gradle을 아래와 같이 작성한다.Spring Boot Guide 페이지 참고 buildscript { repositories { mavenCentral() } dependencies { classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:2.0.5.RELEASE&quot;) } } apply plugin: &#39;java&#39; apply plugin: &#39;idea&#39; apply plugin: &#39;org.springframework.boot&#39; apply plugin: &#39;io.spring.dependency-management&#39; repositories { mavenCentral() } sourceCompatibility = 1.8 targetCompatibility = 1.8 dependencies { compile(&quot;org.springframework.boot:spring-boot-starter-web&quot;) testCompile(&quot;junit:junit&quot;) } Spring Application 코드 작성 Hello World! 간단하게 http://localhost:8080/hello로 접속하면 Hello World!를 출력하는 프로그램을 작성하였다. package com.leeyh0216.test; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @SpringBootApplication @RestController public class SampleServer { public static void main(String[] args) throws Exception { SpringApplication.run(SampleServer.class, args); } @GetMapping(&quot;/hello&quot;) public String hello(){ return &quot;Hello World&quot;; } } 별다른 설정 없이 띄웠으므로 http://localhost:8080/hello로 접속 시 브라우저에 Hello World가 출력되는 것을 볼 수 있다. Spring Boot Data MongoDB Starter Dependency 추가 Maven Repository에서 Spring Boot Data MongoDB Starter Dependency를 추가한다. Maven Repository: Spring Boot Data MongoDB Starter 페이지에서 사용하는 Spring에 맞는 버전을 적절히 골라 build.gradle의 dependencies에 추가한다. CRUD Service, Controller, Entitry 객체 클래스 구현 아래와 같이 간단한 CRUD 서비스를 구현한다. Person.java package com.leeyh0216.test.crud; public class Person { private String id = &quot;&quot;; public String name = &quot;&quot;; public int age = 20; //Getter, Setter 생략 } CRUDService.java package com.leeyh0216.test.crud; import org.springframework.data.mongodb.core.MongoTemplate; import org.springframework.stereotype.Service; import java.util.List; @Service public class CRUDService { private MongoTemplate mongoTemplate; public CRUDService(MongoTemplate mongoTemplate){ this.mongoTemplate = mongoTemplate; } public Person createPerson(Person person){ mongoTemplate.insert(person); return person; } public List&lt;Person&gt; getPeople(){ return mongoTemplate.findAll(Person.class); } } CRUDController.java package com.leeyh0216.test.crud; import org.springframework.web.bind.annotation.*; import java.util.List; @RestController @RequestMapping(&quot;/person&quot;) public class CRUDController { private CRUDService crudService; public CRUDController(CRUDService crudService) { this.crudService = crudService; } @PostMapping(&quot;&quot;) public Person createPerson(@RequestBody Person person){ return crudService.createPerson(person); } @GetMapping(&quot;&quot;) public List&lt;Person&gt; getPeoples(){ return crudService.getPeople(); } } Dockerfile 작성 프로젝트 빌드 후 build/libs 하위에 spring-boot-test.jar이 생성되기 때문에, JDK 8 이미지에서 해당 JAR 파일을 실행시키는 형태로 작성하였다. FROM openjdk:8-jre-alpine RUN mkdir -p /data/spring-boot-test COPY ./build/libs/spring-boot-test.jar /data/spring-boot-test/ ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;/data/spring-boot-test/spring-boot-test.jar&quot;] EXPOSE 8080 Docker 이미지 빌드 및 실행 Spring 프로젝트 디렉토리에서 docker build --tag spring-boot-test:0.1 . 명령어를 통해 Dockerfile을 빌드하여 이미지를 생성해냈다. 이후 docker run -d --name spring-boot-test -p 8080:8080 spring-boot-test:0.1 명령어를 이용하여 이미지를 컨테이너로 만들어 실행시켰다. http://localhost:8080/hello로 접속 시 정상적으로 동작하는 것을 확인할 수 있었다. Docker Swarm 의 서비스로 실행하기 spring-boot-test를 단일 Docker Container가 아닌 Docker Swarm의 서비스로 만들어보자. 사실상 위의 명령어와 별다를게 없다. docker run -d 명령어만 docker service create 명령어로 바꾸어주면 된다. docker service create --name spring-boot-test -p 8080:8080 spring-boot-test:0.1 명령어를 이용하여 서비스로 실행시켰으며, 아래와 같이 정상적으로 서비스 등록이 된 것을 볼 수 있었다. image spring-boot-test:0.1 could not be accessed on a registry to record its digest. Each node will access spring-boot-test:0.1 independently, possibly leading to different nodes running different versions of the image. cri8td3bfy6d3z8u342dr3ju3 overall progress: 1 out of 1 tasks 1/1: running [==================================================&gt;] verify: Service converged docker service ls 명령어를 이용하여 확인했을 때도 아래와 같이 서비스 기동 현황을 확인할 수 있었다. ID NAME MODE REPLICAS IMAGE PORTS i78wqngny6hp apacheserver replicated 1/1 apache2:0.1 *:81-&gt;80/tcp cri8td3bfy6d spring-boot-test replicated 1/1 spring-boot-test:0.1 *:8080-&gt;8080/tcp MongoDB Service 위에서 실행한 서버의 EndPoint를 호출해보면, /hello 경로는 정상적으로 호출되는 것을 확인할 수 있으나, /person 경로는 아래와 같이 오류가 발생하는 것을 확인할 수 있다. {&quot;timestamp&quot;:&quot;2019-05-06T04:24:20.077+0000&quot;,&quot;status&quot;:500,&quot;error&quot;:&quot;Internal Server Error&quot;,&quot;message&quot;:&quot;Timed out after 30000 ms while waiting to connect. Client view of cluster state is {type=UNKNOWN, servers=[{address=mongodb:27017, type=UNKNOWN, state=CONNECTING, exception={com.mongodb.MongoSocketException: mongodb: Name does not resolve}, caused by {java.net.UnknownHostException: mongodb: Name does not resolve}}]; nested exception is com.mongodb.MongoTimeoutException: Timed out after 30000 ms while waiting to connect. Client view of cluster state is {type=UNKNOWN, servers=[{address=mongodb:27017, type=UNKNOWN, state=CONNECTING, exception={com.mongodb.MongoSocketException: mongodb: Name does not resolve}, caused by {java.net.UnknownHostException: mongodb: Name does not resolve}}]&quot;,&quot;path&quot;:&quot;/person&quot;} 이는 위의 Spring 서버에서 참조하는 MongoDB 인스턴스가 존재하지 않기 때문이다. Mongodb Instance를 Docker Service로 실행 DockerHub: Mongo 페이지를 참고하여 Docker Image를 Pull 한다. 3.6 Image를 받을 예정이며, 아래 명령어를 사용하면 된다. docker pull 3.6 아래와 같이 Image가 Pull 되는 것을 확인할 수 있다. 3.6: Pulling from library/mongo 7e6591854262: Pull complete 089d60cb4e0a: Pull complete 9c461696bc09: Pull complete 45085432511a: Pull complete e5182dfcfa20: Pull complete ccb099326ee3: Pull complete 75804f28c4b1: Pull complete 765a10b214be: Pull complete 36cbec4a23a5: Pull complete 8d7c112fee50: Pull complete 22a72bf1a592: Pull complete 7c24e128abe6: Pull complete 44337c6f0bee: Pull complete Digest: sha256:cb57ecfa6ebbefd8ffc7f75c0f00e57a7fa739578a429b6f72a0df19315deadc Status: Downloaded newer image for mongo:3.6 위의 이미지를 Docker Service로 실행시킨다. docker service create --name mongodb -p 27017:27017 mongo:3.6 아래와 같이 정상적으로 MongoDB Service가 실행된 것을 확인할 수 있다. xnrho4emt1cwem3fsyiadd3yb overall progress: 1 out of 1 tasks 1/1: running [==================================================&gt;] verify: Service converged telnet을 이용하여 27017 포트에 접속되는지를 확인해보았다. Trying 127.0.0.1... Connected to localhost. Escape character is &#39;^]&#39;. 그러나 docker service log spring-boot-test 명령어를 실행해보면 아직 MongoDB Instance를 찾을 수 없다는 오류가 발생하고 있는 것을 확인할 수 있다. spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | 2019-05-06 04:31:10.649 INFO 1 --- [}-mongodb:27017] org.mongodb.driver.cluster : Exception in monitor thread while connecting to server mongodb:27017 spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | com.mongodb.MongoSocketException: mongodb spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at com.mongodb.ServerAddress.getSocketAddress(ServerAddress.java:188) ~[mongodb-driver-core-3.6.4.jar!/:na] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at com.mongodb.connection.SocketStreamHelper.initialize(SocketStreamHelper.java:59) ~[mongodb-driver-core-3.6.4.jar!/:na] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at com.mongodb.connection.SocketStream.open(SocketStream.java:57) ~[mongodb-driver-core-3.6.4.jar!/:na] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at com.mongodb.connection.InternalStreamConnection.open(InternalStreamConnection.java:126) ~[mongodb-driver-core-3.6.4.jar!/:na] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at com.mongodb.connection.DefaultServerMonitor$ServerMonitorRunnable.run(DefaultServerMonitor.java:114) ~[mongodb-driver-core-3.6.4.jar!/:na] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at java.lang.Thread.run(Thread.java:748) [na:1.8.0_201] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | Caused by: java.net.UnknownHostException: mongodb spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at java.net.InetAddress.getAllByName0(InetAddress.java:1281) ~[na:1.8.0_201] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at java.net.InetAddress.getAllByName(InetAddress.java:1193) ~[na:1.8.0_201] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at java.net.InetAddress.getAllByName(InetAddress.java:1127) ~[na:1.8.0_201] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at java.net.InetAddress.getByName(InetAddress.java:1077) ~[na:1.8.0_201] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at com.mongodb.ServerAddress.getSocketAddress(ServerAddress.java:186) ~[mongodb-driver-core-3.6.4.jar!/:na] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | ... 5 common frames omitted Docker Overlay Network 구성 위에서 spring-boot-test 서버가 MongoDB Instance를 찾을 수 없는 이유는 간단하다. mongodb라는 Host가 어디에도 등록되어 있지 않기 때문이다. 이를 찾을 수 있는 방법은 2가지가 있다. spring-boot-test의 application.properties 파일에 있는 MongoDB Host를 IP로 설정하거나, host 파일에 등록하는 방법 Docker의 Overlay Network를 이용하는 방법 여기서는 Docker의 Overlay Network를 이용해 보도록 한다. Overlay Network 생성 아래 명령어를 이용하여 backend라는 이름의 Docker Overlay Network를 생성한다. docker network create --attachable --driver overlay backend 아래 명령어를 통해 정상적으로 네트워크가 생성되었는지 확인한다. docker network ls NETWORK ID NAME DRIVER SCOPE 7p056vdum6up backend overlay swarm df830a7a0306 bridge bridge local 054011e7ede2 docker_gwbridge bridge local c2fb0615051d host host local j39apemc19b0 ingress overlay swarm 1d10ebc33b36 none null local 위와 같이 NAME이 backend인 Overlay Network가 생성된 것을 확인할 수 있다. Service를 Overlay Network에 연결 일단 위에 실행했던 spring-boot-test와 mongodb 서비스를 모두 삭제한다. docker service rm spring-boot-test docker service rm mongodb 새롭게 spring-boot-test와 mongodb 서비스를 실행할 때는 --network backend 옵션을 주고 실행한다. docker service create --name spring-boot-test -p 8080:8080 --network backend spring-boot-test:0.1 image spring-boot-test:0.1 could not be accessed on a registry to record its digest. Each node will access spring-boot-test:0.1 independently, possibly leading to different nodes running different versions of the image. olcbruuu5jutlqg6vofqpzslz overall progress: 1 out of 1 tasks 1/1: running [==================================================&gt;] verify: Service converged docker service create --name mongodb -p 27017:27017 --network backend mongodb:3.6 z5z3crpdcy416mco2bpawwnbr overall progress: 1 out of 1 tasks 1/1: running [==================================================&gt;] verify: Service converged 테스트 spring-boot-test 서버를 통해 person을 생성하고 조회해보도록 하자. 일단 http://localhost:8080/person 을 조회해보자. curl http://localhost:8080/person [] 위와 같이 빈 JSON Array가 반환되는 것을 알 수 있다. 이제 person을 생성해보도록 한다. curl -XPOST -H &quot;Content-Type: application/json&quot; -d &#39;{&quot;name&quot;:&quot;leeyh0216&quot;,&quot;age&quot;:28}&#39; http://localhost:8080/person {&quot;id&quot;:&quot;&quot;,&quot;name&quot;:&quot;leeyh0216&quot;,&quot;age&quot;:28} 생성된 Person이 반환되는 것을 확인할 수 있다. 이제 person 목록을 조회해보도록 한다. curl http://localhost:8080 [{&quot;id&quot;:&quot;&quot;,&quot;name&quot;:&quot;leeyh0216&quot;,&quot;age&quot;:28}] JSON Array에 우리가 만든 leeyh0216 이름을 가진 Person 객체가 반환되는 것을 확인할 수 있다. 결론 Docker Swarm은 생각보다 사용하기 쉽게 만들어진 것을 알 수 있었다. 물론 아직 Dockerfile 을 최적화해서 만든다거나, Docker Swarm의 Network 구성 등을 좀 더 알아봐야 할 필요가 있지만, 현재의 Dedicated 된 서버보다 훨씬 효율적으로 운영이 가능할 것으로 보인다." />
<meta property="og:description" content="프로젝트 초기화 git 초기화 Git 페이지에서 spring_mongodb_docker Repository를 초기화한다. git pull https://github.com/leeyh0216/spring_mongodb_docker.git 명령어를 통해 로컬로 Clone 한다. gitignore.io 페이지에서 gradle, java, intellij로 초기화한 .gitignore을 디렉토리에 추가한다. Spring Project 초기화 최상위 디렉토리 아래에 spring-boot-test 라는 이름으로 디렉토리를 생성한다. spring-boot-test에서 gradle init 명령어로 gradle 프로젝트를 초기화한다. build.gradle을 아래와 같이 작성한다.Spring Boot Guide 페이지 참고 buildscript { repositories { mavenCentral() } dependencies { classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:2.0.5.RELEASE&quot;) } } apply plugin: &#39;java&#39; apply plugin: &#39;idea&#39; apply plugin: &#39;org.springframework.boot&#39; apply plugin: &#39;io.spring.dependency-management&#39; repositories { mavenCentral() } sourceCompatibility = 1.8 targetCompatibility = 1.8 dependencies { compile(&quot;org.springframework.boot:spring-boot-starter-web&quot;) testCompile(&quot;junit:junit&quot;) } Spring Application 코드 작성 Hello World! 간단하게 http://localhost:8080/hello로 접속하면 Hello World!를 출력하는 프로그램을 작성하였다. package com.leeyh0216.test; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @SpringBootApplication @RestController public class SampleServer { public static void main(String[] args) throws Exception { SpringApplication.run(SampleServer.class, args); } @GetMapping(&quot;/hello&quot;) public String hello(){ return &quot;Hello World&quot;; } } 별다른 설정 없이 띄웠으므로 http://localhost:8080/hello로 접속 시 브라우저에 Hello World가 출력되는 것을 볼 수 있다. Spring Boot Data MongoDB Starter Dependency 추가 Maven Repository에서 Spring Boot Data MongoDB Starter Dependency를 추가한다. Maven Repository: Spring Boot Data MongoDB Starter 페이지에서 사용하는 Spring에 맞는 버전을 적절히 골라 build.gradle의 dependencies에 추가한다. CRUD Service, Controller, Entitry 객체 클래스 구현 아래와 같이 간단한 CRUD 서비스를 구현한다. Person.java package com.leeyh0216.test.crud; public class Person { private String id = &quot;&quot;; public String name = &quot;&quot;; public int age = 20; //Getter, Setter 생략 } CRUDService.java package com.leeyh0216.test.crud; import org.springframework.data.mongodb.core.MongoTemplate; import org.springframework.stereotype.Service; import java.util.List; @Service public class CRUDService { private MongoTemplate mongoTemplate; public CRUDService(MongoTemplate mongoTemplate){ this.mongoTemplate = mongoTemplate; } public Person createPerson(Person person){ mongoTemplate.insert(person); return person; } public List&lt;Person&gt; getPeople(){ return mongoTemplate.findAll(Person.class); } } CRUDController.java package com.leeyh0216.test.crud; import org.springframework.web.bind.annotation.*; import java.util.List; @RestController @RequestMapping(&quot;/person&quot;) public class CRUDController { private CRUDService crudService; public CRUDController(CRUDService crudService) { this.crudService = crudService; } @PostMapping(&quot;&quot;) public Person createPerson(@RequestBody Person person){ return crudService.createPerson(person); } @GetMapping(&quot;&quot;) public List&lt;Person&gt; getPeoples(){ return crudService.getPeople(); } } Dockerfile 작성 프로젝트 빌드 후 build/libs 하위에 spring-boot-test.jar이 생성되기 때문에, JDK 8 이미지에서 해당 JAR 파일을 실행시키는 형태로 작성하였다. FROM openjdk:8-jre-alpine RUN mkdir -p /data/spring-boot-test COPY ./build/libs/spring-boot-test.jar /data/spring-boot-test/ ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;/data/spring-boot-test/spring-boot-test.jar&quot;] EXPOSE 8080 Docker 이미지 빌드 및 실행 Spring 프로젝트 디렉토리에서 docker build --tag spring-boot-test:0.1 . 명령어를 통해 Dockerfile을 빌드하여 이미지를 생성해냈다. 이후 docker run -d --name spring-boot-test -p 8080:8080 spring-boot-test:0.1 명령어를 이용하여 이미지를 컨테이너로 만들어 실행시켰다. http://localhost:8080/hello로 접속 시 정상적으로 동작하는 것을 확인할 수 있었다. Docker Swarm 의 서비스로 실행하기 spring-boot-test를 단일 Docker Container가 아닌 Docker Swarm의 서비스로 만들어보자. 사실상 위의 명령어와 별다를게 없다. docker run -d 명령어만 docker service create 명령어로 바꾸어주면 된다. docker service create --name spring-boot-test -p 8080:8080 spring-boot-test:0.1 명령어를 이용하여 서비스로 실행시켰으며, 아래와 같이 정상적으로 서비스 등록이 된 것을 볼 수 있었다. image spring-boot-test:0.1 could not be accessed on a registry to record its digest. Each node will access spring-boot-test:0.1 independently, possibly leading to different nodes running different versions of the image. cri8td3bfy6d3z8u342dr3ju3 overall progress: 1 out of 1 tasks 1/1: running [==================================================&gt;] verify: Service converged docker service ls 명령어를 이용하여 확인했을 때도 아래와 같이 서비스 기동 현황을 확인할 수 있었다. ID NAME MODE REPLICAS IMAGE PORTS i78wqngny6hp apacheserver replicated 1/1 apache2:0.1 *:81-&gt;80/tcp cri8td3bfy6d spring-boot-test replicated 1/1 spring-boot-test:0.1 *:8080-&gt;8080/tcp MongoDB Service 위에서 실행한 서버의 EndPoint를 호출해보면, /hello 경로는 정상적으로 호출되는 것을 확인할 수 있으나, /person 경로는 아래와 같이 오류가 발생하는 것을 확인할 수 있다. {&quot;timestamp&quot;:&quot;2019-05-06T04:24:20.077+0000&quot;,&quot;status&quot;:500,&quot;error&quot;:&quot;Internal Server Error&quot;,&quot;message&quot;:&quot;Timed out after 30000 ms while waiting to connect. Client view of cluster state is {type=UNKNOWN, servers=[{address=mongodb:27017, type=UNKNOWN, state=CONNECTING, exception={com.mongodb.MongoSocketException: mongodb: Name does not resolve}, caused by {java.net.UnknownHostException: mongodb: Name does not resolve}}]; nested exception is com.mongodb.MongoTimeoutException: Timed out after 30000 ms while waiting to connect. Client view of cluster state is {type=UNKNOWN, servers=[{address=mongodb:27017, type=UNKNOWN, state=CONNECTING, exception={com.mongodb.MongoSocketException: mongodb: Name does not resolve}, caused by {java.net.UnknownHostException: mongodb: Name does not resolve}}]&quot;,&quot;path&quot;:&quot;/person&quot;} 이는 위의 Spring 서버에서 참조하는 MongoDB 인스턴스가 존재하지 않기 때문이다. Mongodb Instance를 Docker Service로 실행 DockerHub: Mongo 페이지를 참고하여 Docker Image를 Pull 한다. 3.6 Image를 받을 예정이며, 아래 명령어를 사용하면 된다. docker pull 3.6 아래와 같이 Image가 Pull 되는 것을 확인할 수 있다. 3.6: Pulling from library/mongo 7e6591854262: Pull complete 089d60cb4e0a: Pull complete 9c461696bc09: Pull complete 45085432511a: Pull complete e5182dfcfa20: Pull complete ccb099326ee3: Pull complete 75804f28c4b1: Pull complete 765a10b214be: Pull complete 36cbec4a23a5: Pull complete 8d7c112fee50: Pull complete 22a72bf1a592: Pull complete 7c24e128abe6: Pull complete 44337c6f0bee: Pull complete Digest: sha256:cb57ecfa6ebbefd8ffc7f75c0f00e57a7fa739578a429b6f72a0df19315deadc Status: Downloaded newer image for mongo:3.6 위의 이미지를 Docker Service로 실행시킨다. docker service create --name mongodb -p 27017:27017 mongo:3.6 아래와 같이 정상적으로 MongoDB Service가 실행된 것을 확인할 수 있다. xnrho4emt1cwem3fsyiadd3yb overall progress: 1 out of 1 tasks 1/1: running [==================================================&gt;] verify: Service converged telnet을 이용하여 27017 포트에 접속되는지를 확인해보았다. Trying 127.0.0.1... Connected to localhost. Escape character is &#39;^]&#39;. 그러나 docker service log spring-boot-test 명령어를 실행해보면 아직 MongoDB Instance를 찾을 수 없다는 오류가 발생하고 있는 것을 확인할 수 있다. spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | 2019-05-06 04:31:10.649 INFO 1 --- [}-mongodb:27017] org.mongodb.driver.cluster : Exception in monitor thread while connecting to server mongodb:27017 spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | com.mongodb.MongoSocketException: mongodb spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at com.mongodb.ServerAddress.getSocketAddress(ServerAddress.java:188) ~[mongodb-driver-core-3.6.4.jar!/:na] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at com.mongodb.connection.SocketStreamHelper.initialize(SocketStreamHelper.java:59) ~[mongodb-driver-core-3.6.4.jar!/:na] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at com.mongodb.connection.SocketStream.open(SocketStream.java:57) ~[mongodb-driver-core-3.6.4.jar!/:na] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at com.mongodb.connection.InternalStreamConnection.open(InternalStreamConnection.java:126) ~[mongodb-driver-core-3.6.4.jar!/:na] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at com.mongodb.connection.DefaultServerMonitor$ServerMonitorRunnable.run(DefaultServerMonitor.java:114) ~[mongodb-driver-core-3.6.4.jar!/:na] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at java.lang.Thread.run(Thread.java:748) [na:1.8.0_201] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | Caused by: java.net.UnknownHostException: mongodb spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at java.net.InetAddress.getAllByName0(InetAddress.java:1281) ~[na:1.8.0_201] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at java.net.InetAddress.getAllByName(InetAddress.java:1193) ~[na:1.8.0_201] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at java.net.InetAddress.getAllByName(InetAddress.java:1127) ~[na:1.8.0_201] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at java.net.InetAddress.getByName(InetAddress.java:1077) ~[na:1.8.0_201] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at com.mongodb.ServerAddress.getSocketAddress(ServerAddress.java:186) ~[mongodb-driver-core-3.6.4.jar!/:na] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | ... 5 common frames omitted Docker Overlay Network 구성 위에서 spring-boot-test 서버가 MongoDB Instance를 찾을 수 없는 이유는 간단하다. mongodb라는 Host가 어디에도 등록되어 있지 않기 때문이다. 이를 찾을 수 있는 방법은 2가지가 있다. spring-boot-test의 application.properties 파일에 있는 MongoDB Host를 IP로 설정하거나, host 파일에 등록하는 방법 Docker의 Overlay Network를 이용하는 방법 여기서는 Docker의 Overlay Network를 이용해 보도록 한다. Overlay Network 생성 아래 명령어를 이용하여 backend라는 이름의 Docker Overlay Network를 생성한다. docker network create --attachable --driver overlay backend 아래 명령어를 통해 정상적으로 네트워크가 생성되었는지 확인한다. docker network ls NETWORK ID NAME DRIVER SCOPE 7p056vdum6up backend overlay swarm df830a7a0306 bridge bridge local 054011e7ede2 docker_gwbridge bridge local c2fb0615051d host host local j39apemc19b0 ingress overlay swarm 1d10ebc33b36 none null local 위와 같이 NAME이 backend인 Overlay Network가 생성된 것을 확인할 수 있다. Service를 Overlay Network에 연결 일단 위에 실행했던 spring-boot-test와 mongodb 서비스를 모두 삭제한다. docker service rm spring-boot-test docker service rm mongodb 새롭게 spring-boot-test와 mongodb 서비스를 실행할 때는 --network backend 옵션을 주고 실행한다. docker service create --name spring-boot-test -p 8080:8080 --network backend spring-boot-test:0.1 image spring-boot-test:0.1 could not be accessed on a registry to record its digest. Each node will access spring-boot-test:0.1 independently, possibly leading to different nodes running different versions of the image. olcbruuu5jutlqg6vofqpzslz overall progress: 1 out of 1 tasks 1/1: running [==================================================&gt;] verify: Service converged docker service create --name mongodb -p 27017:27017 --network backend mongodb:3.6 z5z3crpdcy416mco2bpawwnbr overall progress: 1 out of 1 tasks 1/1: running [==================================================&gt;] verify: Service converged 테스트 spring-boot-test 서버를 통해 person을 생성하고 조회해보도록 하자. 일단 http://localhost:8080/person 을 조회해보자. curl http://localhost:8080/person [] 위와 같이 빈 JSON Array가 반환되는 것을 알 수 있다. 이제 person을 생성해보도록 한다. curl -XPOST -H &quot;Content-Type: application/json&quot; -d &#39;{&quot;name&quot;:&quot;leeyh0216&quot;,&quot;age&quot;:28}&#39; http://localhost:8080/person {&quot;id&quot;:&quot;&quot;,&quot;name&quot;:&quot;leeyh0216&quot;,&quot;age&quot;:28} 생성된 Person이 반환되는 것을 확인할 수 있다. 이제 person 목록을 조회해보도록 한다. curl http://localhost:8080 [{&quot;id&quot;:&quot;&quot;,&quot;name&quot;:&quot;leeyh0216&quot;,&quot;age&quot;:28}] JSON Array에 우리가 만든 leeyh0216 이름을 가진 Person 객체가 반환되는 것을 확인할 수 있다. 결론 Docker Swarm은 생각보다 사용하기 쉽게 만들어진 것을 알 수 있었다. 물론 아직 Dockerfile 을 최적화해서 만든다거나, Docker Swarm의 Network 구성 등을 좀 더 알아봐야 할 필요가 있지만, 현재의 Dedicated 된 서버보다 훨씬 효율적으로 운영이 가능할 것으로 보인다." />
<link rel="canonical" href="http://localhost:4000/2019-05-06/spring-with-docker-1" />
<meta property="og:url" content="http://localhost:4000/2019-05-06/spring-with-docker-1" />
<meta property="og:site_name" content="DevLog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-05-06T10:00:00+09:00" />
<script type="application/ld+json">
{"author":{"@type":"Person","name":"leeyh0216"},"url":"http://localhost:4000/2019-05-06/spring-with-docker-1","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2019-05-06/spring-with-docker-1"},"headline":"Spring + MongoDB + Docker 조합 사용 테스트","dateModified":"2019-05-06T10:00:00+09:00","datePublished":"2019-05-06T10:00:00+09:00","description":"프로젝트 초기화 git 초기화 Git 페이지에서 spring_mongodb_docker Repository를 초기화한다. git pull https://github.com/leeyh0216/spring_mongodb_docker.git 명령어를 통해 로컬로 Clone 한다. gitignore.io 페이지에서 gradle, java, intellij로 초기화한 .gitignore을 디렉토리에 추가한다. Spring Project 초기화 최상위 디렉토리 아래에 spring-boot-test 라는 이름으로 디렉토리를 생성한다. spring-boot-test에서 gradle init 명령어로 gradle 프로젝트를 초기화한다. build.gradle을 아래와 같이 작성한다.Spring Boot Guide 페이지 참고 buildscript { repositories { mavenCentral() } dependencies { classpath(&quot;org.springframework.boot:spring-boot-gradle-plugin:2.0.5.RELEASE&quot;) } } apply plugin: &#39;java&#39; apply plugin: &#39;idea&#39; apply plugin: &#39;org.springframework.boot&#39; apply plugin: &#39;io.spring.dependency-management&#39; repositories { mavenCentral() } sourceCompatibility = 1.8 targetCompatibility = 1.8 dependencies { compile(&quot;org.springframework.boot:spring-boot-starter-web&quot;) testCompile(&quot;junit:junit&quot;) } Spring Application 코드 작성 Hello World! 간단하게 http://localhost:8080/hello로 접속하면 Hello World!를 출력하는 프로그램을 작성하였다. package com.leeyh0216.test; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @SpringBootApplication @RestController public class SampleServer { public static void main(String[] args) throws Exception { SpringApplication.run(SampleServer.class, args); } @GetMapping(&quot;/hello&quot;) public String hello(){ return &quot;Hello World&quot;; } } 별다른 설정 없이 띄웠으므로 http://localhost:8080/hello로 접속 시 브라우저에 Hello World가 출력되는 것을 볼 수 있다. Spring Boot Data MongoDB Starter Dependency 추가 Maven Repository에서 Spring Boot Data MongoDB Starter Dependency를 추가한다. Maven Repository: Spring Boot Data MongoDB Starter 페이지에서 사용하는 Spring에 맞는 버전을 적절히 골라 build.gradle의 dependencies에 추가한다. CRUD Service, Controller, Entitry 객체 클래스 구현 아래와 같이 간단한 CRUD 서비스를 구현한다. Person.java package com.leeyh0216.test.crud; public class Person { private String id = &quot;&quot;; public String name = &quot;&quot;; public int age = 20; //Getter, Setter 생략 } CRUDService.java package com.leeyh0216.test.crud; import org.springframework.data.mongodb.core.MongoTemplate; import org.springframework.stereotype.Service; import java.util.List; @Service public class CRUDService { private MongoTemplate mongoTemplate; public CRUDService(MongoTemplate mongoTemplate){ this.mongoTemplate = mongoTemplate; } public Person createPerson(Person person){ mongoTemplate.insert(person); return person; } public List&lt;Person&gt; getPeople(){ return mongoTemplate.findAll(Person.class); } } CRUDController.java package com.leeyh0216.test.crud; import org.springframework.web.bind.annotation.*; import java.util.List; @RestController @RequestMapping(&quot;/person&quot;) public class CRUDController { private CRUDService crudService; public CRUDController(CRUDService crudService) { this.crudService = crudService; } @PostMapping(&quot;&quot;) public Person createPerson(@RequestBody Person person){ return crudService.createPerson(person); } @GetMapping(&quot;&quot;) public List&lt;Person&gt; getPeoples(){ return crudService.getPeople(); } } Dockerfile 작성 프로젝트 빌드 후 build/libs 하위에 spring-boot-test.jar이 생성되기 때문에, JDK 8 이미지에서 해당 JAR 파일을 실행시키는 형태로 작성하였다. FROM openjdk:8-jre-alpine RUN mkdir -p /data/spring-boot-test COPY ./build/libs/spring-boot-test.jar /data/spring-boot-test/ ENTRYPOINT [&quot;java&quot;, &quot;-jar&quot;, &quot;/data/spring-boot-test/spring-boot-test.jar&quot;] EXPOSE 8080 Docker 이미지 빌드 및 실행 Spring 프로젝트 디렉토리에서 docker build --tag spring-boot-test:0.1 . 명령어를 통해 Dockerfile을 빌드하여 이미지를 생성해냈다. 이후 docker run -d --name spring-boot-test -p 8080:8080 spring-boot-test:0.1 명령어를 이용하여 이미지를 컨테이너로 만들어 실행시켰다. http://localhost:8080/hello로 접속 시 정상적으로 동작하는 것을 확인할 수 있었다. Docker Swarm 의 서비스로 실행하기 spring-boot-test를 단일 Docker Container가 아닌 Docker Swarm의 서비스로 만들어보자. 사실상 위의 명령어와 별다를게 없다. docker run -d 명령어만 docker service create 명령어로 바꾸어주면 된다. docker service create --name spring-boot-test -p 8080:8080 spring-boot-test:0.1 명령어를 이용하여 서비스로 실행시켰으며, 아래와 같이 정상적으로 서비스 등록이 된 것을 볼 수 있었다. image spring-boot-test:0.1 could not be accessed on a registry to record its digest. Each node will access spring-boot-test:0.1 independently, possibly leading to different nodes running different versions of the image. cri8td3bfy6d3z8u342dr3ju3 overall progress: 1 out of 1 tasks 1/1: running [==================================================&gt;] verify: Service converged docker service ls 명령어를 이용하여 확인했을 때도 아래와 같이 서비스 기동 현황을 확인할 수 있었다. ID NAME MODE REPLICAS IMAGE PORTS i78wqngny6hp apacheserver replicated 1/1 apache2:0.1 *:81-&gt;80/tcp cri8td3bfy6d spring-boot-test replicated 1/1 spring-boot-test:0.1 *:8080-&gt;8080/tcp MongoDB Service 위에서 실행한 서버의 EndPoint를 호출해보면, /hello 경로는 정상적으로 호출되는 것을 확인할 수 있으나, /person 경로는 아래와 같이 오류가 발생하는 것을 확인할 수 있다. {&quot;timestamp&quot;:&quot;2019-05-06T04:24:20.077+0000&quot;,&quot;status&quot;:500,&quot;error&quot;:&quot;Internal Server Error&quot;,&quot;message&quot;:&quot;Timed out after 30000 ms while waiting to connect. Client view of cluster state is {type=UNKNOWN, servers=[{address=mongodb:27017, type=UNKNOWN, state=CONNECTING, exception={com.mongodb.MongoSocketException: mongodb: Name does not resolve}, caused by {java.net.UnknownHostException: mongodb: Name does not resolve}}]; nested exception is com.mongodb.MongoTimeoutException: Timed out after 30000 ms while waiting to connect. Client view of cluster state is {type=UNKNOWN, servers=[{address=mongodb:27017, type=UNKNOWN, state=CONNECTING, exception={com.mongodb.MongoSocketException: mongodb: Name does not resolve}, caused by {java.net.UnknownHostException: mongodb: Name does not resolve}}]&quot;,&quot;path&quot;:&quot;/person&quot;} 이는 위의 Spring 서버에서 참조하는 MongoDB 인스턴스가 존재하지 않기 때문이다. Mongodb Instance를 Docker Service로 실행 DockerHub: Mongo 페이지를 참고하여 Docker Image를 Pull 한다. 3.6 Image를 받을 예정이며, 아래 명령어를 사용하면 된다. docker pull 3.6 아래와 같이 Image가 Pull 되는 것을 확인할 수 있다. 3.6: Pulling from library/mongo 7e6591854262: Pull complete 089d60cb4e0a: Pull complete 9c461696bc09: Pull complete 45085432511a: Pull complete e5182dfcfa20: Pull complete ccb099326ee3: Pull complete 75804f28c4b1: Pull complete 765a10b214be: Pull complete 36cbec4a23a5: Pull complete 8d7c112fee50: Pull complete 22a72bf1a592: Pull complete 7c24e128abe6: Pull complete 44337c6f0bee: Pull complete Digest: sha256:cb57ecfa6ebbefd8ffc7f75c0f00e57a7fa739578a429b6f72a0df19315deadc Status: Downloaded newer image for mongo:3.6 위의 이미지를 Docker Service로 실행시킨다. docker service create --name mongodb -p 27017:27017 mongo:3.6 아래와 같이 정상적으로 MongoDB Service가 실행된 것을 확인할 수 있다. xnrho4emt1cwem3fsyiadd3yb overall progress: 1 out of 1 tasks 1/1: running [==================================================&gt;] verify: Service converged telnet을 이용하여 27017 포트에 접속되는지를 확인해보았다. Trying 127.0.0.1... Connected to localhost. Escape character is &#39;^]&#39;. 그러나 docker service log spring-boot-test 명령어를 실행해보면 아직 MongoDB Instance를 찾을 수 없다는 오류가 발생하고 있는 것을 확인할 수 있다. spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | 2019-05-06 04:31:10.649 INFO 1 --- [}-mongodb:27017] org.mongodb.driver.cluster : Exception in monitor thread while connecting to server mongodb:27017 spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | com.mongodb.MongoSocketException: mongodb spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at com.mongodb.ServerAddress.getSocketAddress(ServerAddress.java:188) ~[mongodb-driver-core-3.6.4.jar!/:na] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at com.mongodb.connection.SocketStreamHelper.initialize(SocketStreamHelper.java:59) ~[mongodb-driver-core-3.6.4.jar!/:na] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at com.mongodb.connection.SocketStream.open(SocketStream.java:57) ~[mongodb-driver-core-3.6.4.jar!/:na] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at com.mongodb.connection.InternalStreamConnection.open(InternalStreamConnection.java:126) ~[mongodb-driver-core-3.6.4.jar!/:na] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at com.mongodb.connection.DefaultServerMonitor$ServerMonitorRunnable.run(DefaultServerMonitor.java:114) ~[mongodb-driver-core-3.6.4.jar!/:na] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at java.lang.Thread.run(Thread.java:748) [na:1.8.0_201] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | Caused by: java.net.UnknownHostException: mongodb spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at java.net.InetAddress.getAllByName0(InetAddress.java:1281) ~[na:1.8.0_201] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at java.net.InetAddress.getAllByName(InetAddress.java:1193) ~[na:1.8.0_201] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at java.net.InetAddress.getAllByName(InetAddress.java:1127) ~[na:1.8.0_201] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at java.net.InetAddress.getByName(InetAddress.java:1077) ~[na:1.8.0_201] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | at com.mongodb.ServerAddress.getSocketAddress(ServerAddress.java:186) ~[mongodb-driver-core-3.6.4.jar!/:na] spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100 | ... 5 common frames omitted Docker Overlay Network 구성 위에서 spring-boot-test 서버가 MongoDB Instance를 찾을 수 없는 이유는 간단하다. mongodb라는 Host가 어디에도 등록되어 있지 않기 때문이다. 이를 찾을 수 있는 방법은 2가지가 있다. spring-boot-test의 application.properties 파일에 있는 MongoDB Host를 IP로 설정하거나, host 파일에 등록하는 방법 Docker의 Overlay Network를 이용하는 방법 여기서는 Docker의 Overlay Network를 이용해 보도록 한다. Overlay Network 생성 아래 명령어를 이용하여 backend라는 이름의 Docker Overlay Network를 생성한다. docker network create --attachable --driver overlay backend 아래 명령어를 통해 정상적으로 네트워크가 생성되었는지 확인한다. docker network ls NETWORK ID NAME DRIVER SCOPE 7p056vdum6up backend overlay swarm df830a7a0306 bridge bridge local 054011e7ede2 docker_gwbridge bridge local c2fb0615051d host host local j39apemc19b0 ingress overlay swarm 1d10ebc33b36 none null local 위와 같이 NAME이 backend인 Overlay Network가 생성된 것을 확인할 수 있다. Service를 Overlay Network에 연결 일단 위에 실행했던 spring-boot-test와 mongodb 서비스를 모두 삭제한다. docker service rm spring-boot-test docker service rm mongodb 새롭게 spring-boot-test와 mongodb 서비스를 실행할 때는 --network backend 옵션을 주고 실행한다. docker service create --name spring-boot-test -p 8080:8080 --network backend spring-boot-test:0.1 image spring-boot-test:0.1 could not be accessed on a registry to record its digest. Each node will access spring-boot-test:0.1 independently, possibly leading to different nodes running different versions of the image. olcbruuu5jutlqg6vofqpzslz overall progress: 1 out of 1 tasks 1/1: running [==================================================&gt;] verify: Service converged docker service create --name mongodb -p 27017:27017 --network backend mongodb:3.6 z5z3crpdcy416mco2bpawwnbr overall progress: 1 out of 1 tasks 1/1: running [==================================================&gt;] verify: Service converged 테스트 spring-boot-test 서버를 통해 person을 생성하고 조회해보도록 하자. 일단 http://localhost:8080/person 을 조회해보자. curl http://localhost:8080/person [] 위와 같이 빈 JSON Array가 반환되는 것을 알 수 있다. 이제 person을 생성해보도록 한다. curl -XPOST -H &quot;Content-Type: application/json&quot; -d &#39;{&quot;name&quot;:&quot;leeyh0216&quot;,&quot;age&quot;:28}&#39; http://localhost:8080/person {&quot;id&quot;:&quot;&quot;,&quot;name&quot;:&quot;leeyh0216&quot;,&quot;age&quot;:28} 생성된 Person이 반환되는 것을 확인할 수 있다. 이제 person 목록을 조회해보도록 한다. curl http://localhost:8080 [{&quot;id&quot;:&quot;&quot;,&quot;name&quot;:&quot;leeyh0216&quot;,&quot;age&quot;:28}] JSON Array에 우리가 만든 leeyh0216 이름을 가진 Person 객체가 반환되는 것을 확인할 수 있다. 결론 Docker Swarm은 생각보다 사용하기 쉽게 만들어진 것을 알 수 있었다. 물론 아직 Dockerfile 을 최적화해서 만든다거나, Docker Swarm의 Network 구성 등을 좀 더 알아봐야 할 필요가 있지만, 현재의 Dedicated 된 서버보다 훨씬 효율적으로 운영이 가능할 것으로 보인다.","@type":"BlogPosting","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


  <!-- CSS -->
  <link rel="stylesheet" href="/assets/main.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">

  <!-- Favicon -->
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png">

  <!-- RSS -->
  <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="DevLog" />

  <!-- Google Analytics-->
  <script data-ad-client="ca-pub-8829030678254956" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
</head>


  <body>

    <nav class="nav">
  <div class="nav-container">
    <a href="/">
      <h2 class="nav-title">DevLog</h2>
    </a>
    <ul>
      <li><a href="/about">About</a></li>
      <li><a href="/">Posts</a></li>
      <li><a href="/tags">Tags</a></li>
    </ul>
  </div>
</nav>


    <main>
      <div class="post">
  <div class="post-info">
    <span>Written by</span>
    
        leeyh0216
    

    
      <br>
      <span>on&nbsp;</span><time datetime="2019-05-06 10:00:00 +0900">May 06, 2019</time>
    
    
    
      <br>
      <span>
      
        
        <a style="text-decoration: none;" href="/tag/docker"><code class="highligher-rouge"><nobr>docker</nobr></code>&nbsp;</a>
      
        
        <a style="text-decoration: none;" href="/tag/spring"><code class="highligher-rouge"><nobr>spring</nobr></code>&nbsp;</a>
      
      </span>
    
  </span>
  </div>

  <h1 class="post-title">Spring + MongoDB + Docker 조합 사용 테스트</h1>
  <div class="post-line"></div>

  <h1 id="프로젝트-초기화">프로젝트 초기화</h1>

<h2 id="git-초기화">git 초기화</h2>

<ol>
  <li>
    <p>Git 페이지에서 <a href="https://github.com/leeyh0216/spring_mongodb_docker">spring_mongodb_docker</a> Repository를 초기화한다.</p>
  </li>
  <li>
    <p><code class="highlighter-rouge">git pull https://github.com/leeyh0216/spring_mongodb_docker.git</code> 명령어를 통해 로컬로 Clone 한다.</p>
  </li>
  <li>
    <p><a href="https://gitignore.io">gitignore.io</a> 페이지에서 gradle, java, intellij로 초기화한 <code class="highlighter-rouge">.gitignore</code>을 디렉토리에 추가한다.</p>
  </li>
</ol>

<h2 id="spring-project-초기화">Spring Project 초기화</h2>

<ol>
  <li>
    <p>최상위 디렉토리 아래에 spring-boot-test 라는 이름으로 디렉토리를 생성한다.</p>
  </li>
  <li>
    <p>spring-boot-test에서 <code class="highlighter-rouge">gradle init</code> 명령어로 gradle 프로젝트를 초기화한다.</p>
  </li>
  <li>
    <p>build.gradle을 아래와 같이 작성한다.<a href="https://spring.io/guides/gs/spring-boot/">Spring Boot Guide 페이지 참고</a></p>
  </li>
</ol>

<figure class="highlight"><pre><code class="language-groovy" data-lang="groovy"><span class="n">buildscript</span> <span class="o">{</span>
    <span class="n">repositories</span> <span class="o">{</span>
        <span class="n">mavenCentral</span><span class="o">()</span>
    <span class="o">}</span>
    <span class="n">dependencies</span> <span class="o">{</span>
        <span class="n">classpath</span><span class="o">(</span><span class="s2">"org.springframework.boot:spring-boot-gradle-plugin:2.0.5.RELEASE"</span><span class="o">)</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="n">apply</span> <span class="nl">plugin:</span> <span class="s1">'java'</span>
<span class="n">apply</span> <span class="nl">plugin:</span> <span class="s1">'idea'</span>
<span class="n">apply</span> <span class="nl">plugin:</span> <span class="s1">'org.springframework.boot'</span>
<span class="n">apply</span> <span class="nl">plugin:</span> <span class="s1">'io.spring.dependency-management'</span>

<span class="n">repositories</span> <span class="o">{</span>
    <span class="n">mavenCentral</span><span class="o">()</span>
<span class="o">}</span>

<span class="n">sourceCompatibility</span> <span class="o">=</span> <span class="mf">1.8</span>
<span class="n">targetCompatibility</span> <span class="o">=</span> <span class="mf">1.8</span>

<span class="n">dependencies</span> <span class="o">{</span>
    <span class="n">compile</span><span class="o">(</span><span class="s2">"org.springframework.boot:spring-boot-starter-web"</span><span class="o">)</span>
    <span class="n">testCompile</span><span class="o">(</span><span class="s2">"junit:junit"</span><span class="o">)</span>
<span class="o">}</span></code></pre></figure>

<h1 id="spring-application-코드-작성">Spring Application 코드 작성</h1>

<h2 id="hello-world">Hello World!</h2>

<p>간단하게 http://localhost:8080/hello로 접속하면 Hello World!를 출력하는 프로그램을 작성하였다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leeyh0216</span><span class="o">.</span><span class="na">test</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.boot.SpringApplication</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.boot.autoconfigure.SpringBootApplication</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.bind.annotation.GetMapping</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.web.bind.annotation.RestController</span><span class="o">;</span>

<span class="nd">@SpringBootApplication</span>
<span class="nd">@RestController</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SampleServer</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">SpringApplication</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="nc">SampleServer</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">"/hello"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">hello</span><span class="o">(){</span>
        <span class="k">return</span> <span class="s">"Hello World"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>별다른 설정 없이 띄웠으므로 http://localhost:8080/hello로 접속 시 브라우저에 Hello World가 출력되는 것을 볼 수 있다.</p>

<h2 id="spring-boot-data-mongodb-starter-dependency-추가">Spring Boot Data MongoDB Starter Dependency 추가</h2>

<p>Maven Repository에서 Spring Boot Data MongoDB Starter Dependency를 추가한다.</p>

<p><a href="https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-mongodb">Maven Repository: Spring Boot Data MongoDB Starter</a> 페이지에서 사용하는 Spring에 맞는 버전을 적절히 골라 build.gradle의 dependencies에 추가한다.</p>

<h2 id="crud-service-controller-entitry-객체-클래스-구현">CRUD Service, Controller, Entitry 객체 클래스 구현</h2>

<p>아래와 같이 간단한 CRUD 서비스를 구현한다.</p>

<h3 id="personjava">Person.java</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leeyh0216</span><span class="o">.</span><span class="na">test</span><span class="o">.</span><span class="na">crud</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Person</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">id</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="n">name</span> <span class="o">=</span> <span class="s">""</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">20</span><span class="o">;</span>

    <span class="c1">//Getter, Setter 생략
</span>
<span class="o">}</span></code></pre></figure>

<h3 id="crudservicejava">CRUDService.java</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leeyh0216</span><span class="o">.</span><span class="na">test</span><span class="o">.</span><span class="na">crud</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.data.mongodb.core.MongoTemplate</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.stereotype.Service</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CRUDService</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">MongoTemplate</span> <span class="n">mongoTemplate</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">CRUDService</span><span class="o">(</span><span class="nc">MongoTemplate</span> <span class="n">mongoTemplate</span><span class="o">){</span>
        <span class="k">this</span><span class="o">.</span><span class="na">mongoTemplate</span> <span class="o">=</span> <span class="n">mongoTemplate</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">Person</span> <span class="nf">createPerson</span><span class="o">(</span><span class="nc">Person</span> <span class="n">person</span><span class="o">){</span>
        <span class="n">mongoTemplate</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">person</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">person</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Person</span><span class="o">&gt;</span> <span class="nf">getPeople</span><span class="o">(){</span>
        <span class="k">return</span> <span class="n">mongoTemplate</span><span class="o">.</span><span class="na">findAll</span><span class="o">(</span><span class="nc">Person</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<h3 id="crudcontrollerjava">CRUDController.java</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leeyh0216</span><span class="o">.</span><span class="na">test</span><span class="o">.</span><span class="na">crud</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.web.bind.annotation.*</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>

<span class="nd">@RestController</span>
<span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/person"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CRUDController</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">CRUDService</span> <span class="n">crudService</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">CRUDController</span><span class="o">(</span><span class="nc">CRUDService</span> <span class="n">crudService</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">crudService</span> <span class="o">=</span> <span class="n">crudService</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@PostMapping</span><span class="o">(</span><span class="s">""</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">Person</span> <span class="nf">createPerson</span><span class="o">(</span><span class="nd">@RequestBody</span> <span class="nc">Person</span> <span class="n">person</span><span class="o">){</span>
        <span class="k">return</span> <span class="n">crudService</span><span class="o">.</span><span class="na">createPerson</span><span class="o">(</span><span class="n">person</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">""</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Person</span><span class="o">&gt;</span> <span class="nf">getPeoples</span><span class="o">(){</span>
        <span class="k">return</span> <span class="n">crudService</span><span class="o">.</span><span class="na">getPeople</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<h2 id="dockerfile-작성">Dockerfile 작성</h2>

<p>프로젝트 빌드 후 build/libs 하위에 spring-boot-test.jar이 생성되기 때문에, JDK 8 이미지에서 해당 JAR 파일을 실행시키는 형태로 작성하였다.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">FROM openjdk:8-jre-alpine

RUN <span class="nb">mkdir</span> <span class="nt">-p</span> /data/spring-boot-test
COPY ./build/libs/spring-boot-test.jar /data/spring-boot-test/

ENTRYPOINT <span class="o">[</span><span class="s2">"java"</span>, <span class="s2">"-jar"</span>, <span class="s2">"/data/spring-boot-test/spring-boot-test.jar"</span><span class="o">]</span>
EXPOSE 8080</code></pre></figure>

<h2 id="docker-이미지-빌드-및-실행">Docker 이미지 빌드 및 실행</h2>

<p>Spring 프로젝트 디렉토리에서 <code class="highlighter-rouge">docker build --tag spring-boot-test:0.1 .</code> 명령어를 통해 Dockerfile을 빌드하여 이미지를 생성해냈다.</p>

<p>이후 <code class="highlighter-rouge">docker run -d --name spring-boot-test -p 8080:8080 spring-boot-test:0.1</code> 명령어를 이용하여 이미지를 컨테이너로 만들어 실행시켰다.</p>

<p>http://localhost:8080/hello로 접속 시 정상적으로 동작하는 것을 확인할 수 있었다.</p>

<h2 id="docker-swarm-의-서비스로-실행하기">Docker Swarm 의 서비스로 실행하기</h2>

<p>spring-boot-test를 단일 Docker Container가 아닌 Docker Swarm의 서비스로 만들어보자.</p>

<p>사실상 위의 명령어와 별다를게 없다. <code class="highlighter-rouge">docker run -d</code> 명령어만 <code class="highlighter-rouge">docker service create</code> 명령어로 바꾸어주면 된다.</p>

<p><code class="highlighter-rouge">docker service create --name spring-boot-test -p 8080:8080 spring-boot-test:0.1</code> 명령어를 이용하여 서비스로 실행시켰으며, 아래와 같이 정상적으로 서비스 등록이 된 것을 볼 수 있었다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>image spring-boot-test:0.1 could not be accessed on a registry to record
its digest. Each node will access spring-boot-test:0.1 independently,
possibly leading to different nodes running different
versions of the image.

cri8td3bfy6d3z8u342dr3ju3
overall progress: 1 out of 1 tasks
1/1: running   [==================================================&gt;]
verify: Service converged
</code></pre></div></div>

<p><code class="highlighter-rouge">docker service ls</code> 명령어를 이용하여 확인했을 때도 아래와 같이 서비스 기동 현황을 확인할 수 있었다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ID                  NAME                MODE                REPLICAS            IMAGE                  PORTS
i78wqngny6hp        apacheserver        replicated          1/1                 apache2:0.1            *:81-&gt;80/tcp
cri8td3bfy6d        spring-boot-test    replicated          1/1                 spring-boot-test:0.1   *:8080-&gt;8080/tcp
</code></pre></div></div>

<h1 id="mongodb-service">MongoDB Service</h1>

<p>위에서 실행한 서버의 EndPoint를 호출해보면, /hello 경로는 정상적으로 호출되는 것을 확인할 수 있으나, /person 경로는 아래와 같이 오류가 발생하는 것을 확인할 수 있다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{"timestamp":"2019-05-06T04:24:20.077+0000","status":500,"error":"Internal Server Error","message":"Timed out after 30000 ms while waiting to connect. Client view of cluster state is {type=UNKNOWN, servers=[{address=mongodb:27017, type=UNKNOWN, state=CONNECTING, exception={com.mongodb.MongoSocketException: mongodb: Name does not resolve}, caused by {java.net.UnknownHostException: mongodb: Name does not resolve}}]; nested exception is com.mongodb.MongoTimeoutException: Timed out after 30000 ms while waiting to connect. Client view of cluster state is {type=UNKNOWN, servers=[{address=mongodb:27017, type=UNKNOWN, state=CONNECTING, exception={com.mongodb.MongoSocketException: mongodb: Name does not resolve}, caused by {java.net.UnknownHostException: mongodb: Name does not resolve}}]","path":"/person"}
</code></pre></div></div>

<p>이는 위의 Spring 서버에서 참조하는 MongoDB 인스턴스가 존재하지 않기 때문이다.</p>

<h2 id="mongodb-instance를-docker-service로-실행">Mongodb Instance를 Docker Service로 실행</h2>

<p><a href="https://hub.docker.com/_/mongo">DockerHub: Mongo</a> 페이지를 참고하여 Docker Image를 Pull 한다.</p>

<p>3.6 Image를 받을 예정이며, 아래 명령어를 사용하면 된다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker pull 3.6
</code></pre></div></div>

<p>아래와 같이 Image가 Pull 되는 것을 확인할 수 있다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3.6: Pulling from library/mongo
7e6591854262: Pull complete
089d60cb4e0a: Pull complete
9c461696bc09: Pull complete
45085432511a: Pull complete
e5182dfcfa20: Pull complete
ccb099326ee3: Pull complete
75804f28c4b1: Pull complete
765a10b214be: Pull complete
36cbec4a23a5: Pull complete
8d7c112fee50: Pull complete
22a72bf1a592: Pull complete
7c24e128abe6: Pull complete
44337c6f0bee: Pull complete
Digest: sha256:cb57ecfa6ebbefd8ffc7f75c0f00e57a7fa739578a429b6f72a0df19315deadc
Status: Downloaded newer image for mongo:3.6
</code></pre></div></div>

<p>위의 이미지를 Docker Service로 실행시킨다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker service create --name mongodb -p 27017:27017 mongo:3.6
</code></pre></div></div>

<p>아래와 같이 정상적으로 MongoDB Service가 실행된 것을 확인할 수 있다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>xnrho4emt1cwem3fsyiadd3yb
overall progress: 1 out of 1 tasks
1/1: running   [==================================================&gt;]
verify: Service converged
</code></pre></div></div>

<p>telnet을 이용하여 27017 포트에 접속되는지를 확인해보았다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
</code></pre></div></div>

<p>그러나 <code class="highlighter-rouge">docker service log spring-boot-test</code> 명령어를 실행해보면 아직 MongoDB Instance를 찾을 수 없다는 오류가 발생하고 있는 것을 확인할 수 있다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100    | 2019-05-06 04:31:10.649  INFO 1 --- [}-mongodb:27017] org.mongodb.driver.cluster               : Exception in monitor thread while connecting to server mongodb:27017
spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100    |
spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100    | com.mongodb.MongoSocketException: mongodb
spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100    |      at com.mongodb.ServerAddress.getSocketAddress(ServerAddress.java:188) ~[mongodb-driver-core-3.6.4.jar!/:na]
spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100    |      at com.mongodb.connection.SocketStreamHelper.initialize(SocketStreamHelper.java:59) ~[mongodb-driver-core-3.6.4.jar!/:na]
spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100    |      at com.mongodb.connection.SocketStream.open(SocketStream.java:57) ~[mongodb-driver-core-3.6.4.jar!/:na]
spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100    |      at com.mongodb.connection.InternalStreamConnection.open(InternalStreamConnection.java:126) ~[mongodb-driver-core-3.6.4.jar!/:na]
spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100    |      at com.mongodb.connection.DefaultServerMonitor$ServerMonitorRunnable.run(DefaultServerMonitor.java:114) ~[mongodb-driver-core-3.6.4.jar!/:na]
spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100    |      at java.lang.Thread.run(Thread.java:748) [na:1.8.0_201]
spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100    | Caused by: java.net.UnknownHostException: mongodb
spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100    |      at java.net.InetAddress.getAllByName0(InetAddress.java:1281) ~[na:1.8.0_201]
spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100    |      at java.net.InetAddress.getAllByName(InetAddress.java:1193) ~[na:1.8.0_201]
spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100    |      at java.net.InetAddress.getAllByName(InetAddress.java:1127) ~[na:1.8.0_201]
spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100    |      at java.net.InetAddress.getByName(InetAddress.java:1077) ~[na:1.8.0_201]
spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100    |      at com.mongodb.ServerAddress.getSocketAddress(ServerAddress.java:186) ~[mongodb-driver-core-3.6.4.jar!/:na]
spring-boot-test.1.rqxbxzydhp3z@linuxkit-00155d249100    |      ... 5 common frames omitted
</code></pre></div></div>

<h1 id="docker-overlay-network-구성">Docker Overlay Network 구성</h1>

<p>위에서 spring-boot-test 서버가 MongoDB Instance를 찾을 수 없는 이유는 간단하다. mongodb라는 Host가 어디에도 등록되어 있지 않기 때문이다.</p>

<p>이를 찾을 수 있는 방법은 2가지가 있다.</p>

<ol>
  <li>
    <p>spring-boot-test의 <code class="highlighter-rouge">application.properties</code> 파일에 있는 MongoDB Host를 IP로 설정하거나, host 파일에 등록하는 방법</p>
  </li>
  <li>
    <p>Docker의 Overlay Network를 이용하는 방법</p>
  </li>
</ol>

<p>여기서는 Docker의 Overlay Network를 이용해 보도록 한다.</p>

<h2 id="overlay-network-생성">Overlay Network 생성</h2>

<p>아래 명령어를 이용하여 <code class="highlighter-rouge">backend</code>라는 이름의 Docker Overlay Network를 생성한다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker network create --attachable --driver overlay backend
</code></pre></div></div>

<p>아래 명령어를 통해 정상적으로 네트워크가 생성되었는지 확인한다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker network ls
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NETWORK ID          NAME                DRIVER              SCOPE
7p056vdum6up        backend             overlay             swarm
df830a7a0306        bridge              bridge              local
054011e7ede2        docker_gwbridge     bridge              local
c2fb0615051d        host                host                local
j39apemc19b0        ingress             overlay             swarm
1d10ebc33b36        none                null                local
</code></pre></div></div>

<p>위와 같이 NAME이 backend인 Overlay Network가 생성된 것을 확인할 수 있다.</p>

<h2 id="service를-overlay-network에-연결">Service를 Overlay Network에 연결</h2>

<p>일단 위에 실행했던 spring-boot-test와 mongodb 서비스를 모두 삭제한다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker service rm spring-boot-test
docker service rm mongodb
</code></pre></div></div>

<p>새롭게 spring-boot-test와 mongodb 서비스를 실행할 때는 <code class="highlighter-rouge">--network backend</code> 옵션을 주고 실행한다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker service create --name spring-boot-test -p 8080:8080 --network backend spring-boot-test:0.1
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>image spring-boot-test:0.1 could not be accessed on a registry to record
its digest. Each node will access spring-boot-test:0.1 independently,
possibly leading to different nodes running different
versions of the image.

olcbruuu5jutlqg6vofqpzslz
overall progress: 1 out of 1 tasks
1/1: running   [==================================================&gt;]
verify: Service converged
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker service create --name mongodb -p 27017:27017 --network backend mongodb:3.6
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>z5z3crpdcy416mco2bpawwnbr
overall progress: 1 out of 1 tasks
1/1: running   [==================================================&gt;]
verify: Service converged
</code></pre></div></div>

<h2 id="테스트">테스트</h2>

<p>spring-boot-test 서버를 통해 person을 생성하고 조회해보도록 하자.</p>

<p>일단 http://localhost:8080/person 을 조회해보자.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl http://localhost:8080/person
[]
</code></pre></div></div>

<p>위와 같이 빈 JSON Array가 반환되는 것을 알 수 있다.</p>

<p>이제 person을 생성해보도록 한다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl -XPOST -H "Content-Type: application/json" -d '{"name":"leeyh0216","age":28}' http://localhost:8080/person

{"id":"","name":"leeyh0216","age":28}
</code></pre></div></div>

<p>생성된 Person이 반환되는 것을 확인할 수 있다.</p>

<p>이제 person 목록을 조회해보도록 한다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl http://localhost:8080
[{"id":"","name":"leeyh0216","age":28}]
</code></pre></div></div>

<p>JSON Array에 우리가 만든 leeyh0216 이름을 가진 Person 객체가 반환되는 것을 확인할 수 있다.</p>

<h1 id="결론">결론</h1>

<p>Docker Swarm은 생각보다 사용하기 쉽게 만들어진 것을 알 수 있었다.</p>

<p>물론 아직 Dockerfile 을 최적화해서 만든다거나, Docker Swarm의 Network 구성 등을 좀 더 알아봐야 할 필요가 있지만, 현재의 Dedicated 된 서버보다 훨씬 효율적으로 운영이 가능할 것으로 보인다.</p>


</div>

<div class="pagination">
  
    <a href="/2019-05-18/spring-core-1" class="left arrow">&#8592;</a>
  
  
    <a href="/2019-01-28/annotation-based-container-configuration" class="right arrow">&#8594;</a>
  

  <a href="#" class="top">Top</a>
</div>

    </main>

    <footer>
  <span>
    &copy; <time datetime="2019-11-05 21:14:23 +0900">2019</time> leeyh0216. Made with Jekyll using the <a href="https://github.com/chesterhow/tale/">Tale</a> theme.
  </span>
</footer>

  </body>
</html>
