<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Spring Core Technologies - Bean Scopes | leeyh0216’s devlog</title>
<meta name="generator" content="Jekyll v3.8.6" />
<meta property="og:title" content="Spring Core Technologies - Bean Scopes" />
<meta name="author" content="leeyh0216" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Bean Scopes Bean Definition을 만든다는 것은, Bean으로 생성할 클래스를 통해 어떻게 객체를 만들어 내는지에 대한 방법(Recipe)을 만들어 내는 것이다. Bean Definition에는 생성할 Bean의 의존성(Dependency) 설정값(Configuration values) Scope 이 포함된다. 설정을 통해 객체의 Scope을 지정하는 방식은 자바의 클래스 레벨에서 Scope을 제어하는 것보다 강력하고 유연하다. Spring에서는 7개의 Scope을 지원하며, Non Web Application에서는 이 중 2개만 사용이 가능하다. Singleton Scope Spring의 기본 Scope. Spring IoC Container 당 1개의 객체를 유지한다. Spring의 Singleton Bean의 개념은 GoF 패턴에서 나오는 Singleton Pattern과 차이가 있다. GoF 패턴에서 나오는 Singleton Pattern이 적용된 클래스는 Java ClassLoader에 단 1개의 객체밖에 존재할 수 없지만, Spring에서의 Singleton Bean은 Spring IoC Container에서만 1개의 객체를 유지한다. 즉, 임의로 Singleton Bean을 만들어낼 수 있다. 일반적인 Singleton Pattern package com.leeyh0216.others; //Final 클래스로 만들어 상속이 불가하게 함 public final class SingletonExample { //JVM 내에서 1개만 유지되는 SingletonExample 객체 private static SingletonExample instance = null; //synchronized 키워드를 통해 Thread-Safe 보장 private static synchronized SingletonExample getInstance(){ if(instance == null) instance = new SingletonExample(); return instance; } private SingletonExample(){ //Do something } public static void main(String[] args) throws Exception { SingletonExample s1 = SingletonExample.getInstance(); SingletonExample s2 = SingletonExample.getInstance(); System.out.println(s1 == s2); } } 위와 같이 생성자를 private으로 선언하여 new를 통한 객체 생성을 막고, getInstance 함수를 통해서만 객체를 생성/참조할 수 있도록 하여 JVM 내에 1개의 객체만을 유지할 수 있도록 한다. Reflection을 사용하지 않고서는 일반적인 방법으로 해당 클래스의 객체를 2개 유지하는 것은 불가능하다. 위 프로그램의 결과는 true가 나오게 된다. Spring에서의 Singleton Scope 테스트를 위해 3개의 파일을 작성한다. Program Entry Point 역할을 담당하는 Application 클래스 Configuration 역할을 담당하는 AppConfig 클래스 테스트 클래스인 MyService MyService.java package com.leeyh0216.springstudy.singletonscope; public class MyService{ public MyService() { //Do something } } 아무 기능도 없이 기본 생성자만 존재하는 클래스이다. AppConfig.java package com.leeyh0216.springstudy.singletonscope; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; @Configuration @ComponentScan(&quot;com.leeyh0216.springstudy.singletonscope&quot;) public class AppConfig { @Bean public MyService getMyService(){ return new MyService(); } } MyService 타입의 Bean을 반환하는 getMyService 함수가 정의된 Configuration 클래스이다. Application.java package com.leeyh0216.springstudy.singletonscope; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); MyService m1 = applicationContext.getBean(MyService.class); MyService m2 = applicationContext.getBean(MyService.class); MyService m3 = new MyService(); System.out.println(m1 == m2); System.out.println(m2 == m3); System.out.println(m1 == m3); } } 메인 함수가 들어 있는 Application 클래스이다. 위 프로그램의 출력은 아래와 같다. true false false 위의 m1과 m2 객체는 Spring IoC Container에서 관리하는 Bean 객체이다. Spring에서의 기본 Scope은 Singleton이라 했기 때문에 m1과 m2 객체는 완전히 같은 객체이다. 그렇기 때문에 첫번째 출력은 true가 된다. 그런데 m3 객체는 MyService의 생성자를 직접 호출하여 생성한 객체이다. 즉, 이 객체는 Spring의 IoC Container의 관리를 받지 않는 객체이며, 기존에 생성된 m1, m2 객체와는 완전히 다른 객체이다. 그렇기 때문에 2,3번째 출력은 false가 되는 것이다. Prototype Scope Prototype Bean은 Bean을 참조하는 요청(getBean과 같은 함수를 호출할 때)을 할 때마다 새로운 객체가 생성된다. Prototype Scope을 가진 Bean은 Stateful한 Bean이 필요할 때 사용하고, Singleton Scope을 가진 Bean은 Stateless한 Bean이 필요할 때 사용하면 된다. 다른 Scope과 다르게 Prototype Scope을 가진 Bean의 Life Cycle은 일부만 관리된다. Spring은 Prototype Bean을 생성하여 Client에게 넘겨주지만, 해당 객체를 기록(Record라고 나와 있는데, Container가 별도로 해당 Bean에 대한 참조를 가지고 있지 않다는 것을 의미하는 것 같다.)하고 있지 않다. Prototype Scope을 가진 Bean의 initialization 관련 Callback들은 모두 호출되지만, Destruction 관련 Callback은 호출되지 않기 때문에, 해당 Bean이 비싼 자원(ex. socket, file)을 가지고 있다면 클라이언트 코드에서 별도로 해당 자원을 소멸시켜야 한다. Prototype Scope 테스트 코드 위의 Spring Singleton 과 동일한 코드이지만, AppConfig 클래스의 getMyService 메서드에 @Scope(&quot;prototype&quot;) 어노테이션이 추가된 점만 다르다. AppConfig.java package com.leeyh0216.springstudy.prototypescope; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Scope; @Configuration @ComponentScan(&quot;com.leeyh0216.springstudy.prototypescope&quot;) public class AppConfig { @Bean @Scope(&quot;prototype&quot;) public MyService getMyService(){ return new MyService(); } } 위에서는 명시적으로 @Scope 어노테이션을 통해 prototype Scope을 지정하였으나, 별도로 명시하지 않는 경우 @Scope(&quot;singleton&quot;)과 동일한 효과를 가지게 된다. 위 코드를 기준으로 Application을 실행하였을 때 아래와 같은 결과가 발생한다. false false false Singleton과 다르게 Spring IoC Container에서 getBean 함수를 호출할 때마다 MyService의 객체를 새로 생성하여 반환하기 때문에, 모든 객체가 다를 수밖에 없다. Lifecycle Callback 비교하기(Singleton vs Prototype) Singleton에서는 모든 Lifecycle Callback이 동작하고 Prototype에서는 Initialization 관련 Callback만 동작한다고 나와 있다. 아래와 같이 테스트를 수행해보았다. SingletonService.java package com.leeyh0216.springstudy.singletonvsprototype; import javax.annotation.PostConstruct; import javax.annotation.PreDestroy; public class SingletonService { public SingletonService() { //Do something } @PostConstruct public void onCreate(){ System.out.println(&quot;Singleton has created&quot;); } @PreDestroy public void onDestroy(){ System.out.println(&quot;Singleton is destroying&quot;); } } PrototypeService.java package com.leeyh0216.springstudy.singletonvsprototype; import javax.annotation.PostConstruct; import javax.annotation.PreDestroy; public class PrototypeService { public PrototypeService() { //Do something } @PostConstruct public void onCreate(){ System.out.println(&quot;Prototype has created&quot;); } @PreDestroy public void onDestroy(){ System.out.println(&quot;Prototype is destroying&quot;); } } AppConfig.java package com.leeyh0216.springstudy.singletonvsprototype; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Scope; @Configuration @ComponentScan(&quot;com.leeyh0216.springstudy.singletonvsprototype&quot;) public class AppConfig { @Bean @Scope(&quot;singleton&quot;) public SingletonService getSingletonService(){ return new SingletonService(); } @Bean @Scope(&quot;prototype&quot;) public PrototypeService getPrototypeService() { return new PrototypeService(); } } Application.java package com.leeyh0216.springstudy.singletonvsprototype; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); SingletonService singletonService = applicationContext.getBean(SingletonService.class); PrototypeService prototypeService1 = applicationContext.getBean(PrototypeService.class); PrototypeService prototypeService2 = applicationContext.getBean(PrototypeService.class); ((AnnotationConfigApplicationContext) applicationContext).registerShutdownHook(); } } 위 프로그램의 출력은 아래와 같다. Singleton has created Prototype has created Prototype has created Singleton is destroying 위와 같이 Prototype Bean에 대해서는 “Prototype is destroying”이라는 문구가 출력되지 않은 것을 볼 수 있다." />
<meta property="og:description" content="Bean Scopes Bean Definition을 만든다는 것은, Bean으로 생성할 클래스를 통해 어떻게 객체를 만들어 내는지에 대한 방법(Recipe)을 만들어 내는 것이다. Bean Definition에는 생성할 Bean의 의존성(Dependency) 설정값(Configuration values) Scope 이 포함된다. 설정을 통해 객체의 Scope을 지정하는 방식은 자바의 클래스 레벨에서 Scope을 제어하는 것보다 강력하고 유연하다. Spring에서는 7개의 Scope을 지원하며, Non Web Application에서는 이 중 2개만 사용이 가능하다. Singleton Scope Spring의 기본 Scope. Spring IoC Container 당 1개의 객체를 유지한다. Spring의 Singleton Bean의 개념은 GoF 패턴에서 나오는 Singleton Pattern과 차이가 있다. GoF 패턴에서 나오는 Singleton Pattern이 적용된 클래스는 Java ClassLoader에 단 1개의 객체밖에 존재할 수 없지만, Spring에서의 Singleton Bean은 Spring IoC Container에서만 1개의 객체를 유지한다. 즉, 임의로 Singleton Bean을 만들어낼 수 있다. 일반적인 Singleton Pattern package com.leeyh0216.others; //Final 클래스로 만들어 상속이 불가하게 함 public final class SingletonExample { //JVM 내에서 1개만 유지되는 SingletonExample 객체 private static SingletonExample instance = null; //synchronized 키워드를 통해 Thread-Safe 보장 private static synchronized SingletonExample getInstance(){ if(instance == null) instance = new SingletonExample(); return instance; } private SingletonExample(){ //Do something } public static void main(String[] args) throws Exception { SingletonExample s1 = SingletonExample.getInstance(); SingletonExample s2 = SingletonExample.getInstance(); System.out.println(s1 == s2); } } 위와 같이 생성자를 private으로 선언하여 new를 통한 객체 생성을 막고, getInstance 함수를 통해서만 객체를 생성/참조할 수 있도록 하여 JVM 내에 1개의 객체만을 유지할 수 있도록 한다. Reflection을 사용하지 않고서는 일반적인 방법으로 해당 클래스의 객체를 2개 유지하는 것은 불가능하다. 위 프로그램의 결과는 true가 나오게 된다. Spring에서의 Singleton Scope 테스트를 위해 3개의 파일을 작성한다. Program Entry Point 역할을 담당하는 Application 클래스 Configuration 역할을 담당하는 AppConfig 클래스 테스트 클래스인 MyService MyService.java package com.leeyh0216.springstudy.singletonscope; public class MyService{ public MyService() { //Do something } } 아무 기능도 없이 기본 생성자만 존재하는 클래스이다. AppConfig.java package com.leeyh0216.springstudy.singletonscope; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; @Configuration @ComponentScan(&quot;com.leeyh0216.springstudy.singletonscope&quot;) public class AppConfig { @Bean public MyService getMyService(){ return new MyService(); } } MyService 타입의 Bean을 반환하는 getMyService 함수가 정의된 Configuration 클래스이다. Application.java package com.leeyh0216.springstudy.singletonscope; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); MyService m1 = applicationContext.getBean(MyService.class); MyService m2 = applicationContext.getBean(MyService.class); MyService m3 = new MyService(); System.out.println(m1 == m2); System.out.println(m2 == m3); System.out.println(m1 == m3); } } 메인 함수가 들어 있는 Application 클래스이다. 위 프로그램의 출력은 아래와 같다. true false false 위의 m1과 m2 객체는 Spring IoC Container에서 관리하는 Bean 객체이다. Spring에서의 기본 Scope은 Singleton이라 했기 때문에 m1과 m2 객체는 완전히 같은 객체이다. 그렇기 때문에 첫번째 출력은 true가 된다. 그런데 m3 객체는 MyService의 생성자를 직접 호출하여 생성한 객체이다. 즉, 이 객체는 Spring의 IoC Container의 관리를 받지 않는 객체이며, 기존에 생성된 m1, m2 객체와는 완전히 다른 객체이다. 그렇기 때문에 2,3번째 출력은 false가 되는 것이다. Prototype Scope Prototype Bean은 Bean을 참조하는 요청(getBean과 같은 함수를 호출할 때)을 할 때마다 새로운 객체가 생성된다. Prototype Scope을 가진 Bean은 Stateful한 Bean이 필요할 때 사용하고, Singleton Scope을 가진 Bean은 Stateless한 Bean이 필요할 때 사용하면 된다. 다른 Scope과 다르게 Prototype Scope을 가진 Bean의 Life Cycle은 일부만 관리된다. Spring은 Prototype Bean을 생성하여 Client에게 넘겨주지만, 해당 객체를 기록(Record라고 나와 있는데, Container가 별도로 해당 Bean에 대한 참조를 가지고 있지 않다는 것을 의미하는 것 같다.)하고 있지 않다. Prototype Scope을 가진 Bean의 initialization 관련 Callback들은 모두 호출되지만, Destruction 관련 Callback은 호출되지 않기 때문에, 해당 Bean이 비싼 자원(ex. socket, file)을 가지고 있다면 클라이언트 코드에서 별도로 해당 자원을 소멸시켜야 한다. Prototype Scope 테스트 코드 위의 Spring Singleton 과 동일한 코드이지만, AppConfig 클래스의 getMyService 메서드에 @Scope(&quot;prototype&quot;) 어노테이션이 추가된 점만 다르다. AppConfig.java package com.leeyh0216.springstudy.prototypescope; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Scope; @Configuration @ComponentScan(&quot;com.leeyh0216.springstudy.prototypescope&quot;) public class AppConfig { @Bean @Scope(&quot;prototype&quot;) public MyService getMyService(){ return new MyService(); } } 위에서는 명시적으로 @Scope 어노테이션을 통해 prototype Scope을 지정하였으나, 별도로 명시하지 않는 경우 @Scope(&quot;singleton&quot;)과 동일한 효과를 가지게 된다. 위 코드를 기준으로 Application을 실행하였을 때 아래와 같은 결과가 발생한다. false false false Singleton과 다르게 Spring IoC Container에서 getBean 함수를 호출할 때마다 MyService의 객체를 새로 생성하여 반환하기 때문에, 모든 객체가 다를 수밖에 없다. Lifecycle Callback 비교하기(Singleton vs Prototype) Singleton에서는 모든 Lifecycle Callback이 동작하고 Prototype에서는 Initialization 관련 Callback만 동작한다고 나와 있다. 아래와 같이 테스트를 수행해보았다. SingletonService.java package com.leeyh0216.springstudy.singletonvsprototype; import javax.annotation.PostConstruct; import javax.annotation.PreDestroy; public class SingletonService { public SingletonService() { //Do something } @PostConstruct public void onCreate(){ System.out.println(&quot;Singleton has created&quot;); } @PreDestroy public void onDestroy(){ System.out.println(&quot;Singleton is destroying&quot;); } } PrototypeService.java package com.leeyh0216.springstudy.singletonvsprototype; import javax.annotation.PostConstruct; import javax.annotation.PreDestroy; public class PrototypeService { public PrototypeService() { //Do something } @PostConstruct public void onCreate(){ System.out.println(&quot;Prototype has created&quot;); } @PreDestroy public void onDestroy(){ System.out.println(&quot;Prototype is destroying&quot;); } } AppConfig.java package com.leeyh0216.springstudy.singletonvsprototype; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Scope; @Configuration @ComponentScan(&quot;com.leeyh0216.springstudy.singletonvsprototype&quot;) public class AppConfig { @Bean @Scope(&quot;singleton&quot;) public SingletonService getSingletonService(){ return new SingletonService(); } @Bean @Scope(&quot;prototype&quot;) public PrototypeService getPrototypeService() { return new PrototypeService(); } } Application.java package com.leeyh0216.springstudy.singletonvsprototype; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); SingletonService singletonService = applicationContext.getBean(SingletonService.class); PrototypeService prototypeService1 = applicationContext.getBean(PrototypeService.class); PrototypeService prototypeService2 = applicationContext.getBean(PrototypeService.class); ((AnnotationConfigApplicationContext) applicationContext).registerShutdownHook(); } } 위 프로그램의 출력은 아래와 같다. Singleton has created Prototype has created Prototype has created Singleton is destroying 위와 같이 Prototype Bean에 대해서는 “Prototype is destroying”이라는 문구가 출력되지 않은 것을 볼 수 있다." />
<link rel="canonical" href="http://localhost:4000/2019-01-22/spring-bean-scopes" />
<meta property="og:url" content="http://localhost:4000/2019-01-22/spring-bean-scopes" />
<meta property="og:site_name" content="leeyh0216’s devlog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-01-22T10:00:00+09:00" />
<script type="application/ld+json">
{"headline":"Spring Core Technologies - Bean Scopes","dateModified":"2019-01-22T10:00:00+09:00","datePublished":"2019-01-22T10:00:00+09:00","url":"http://localhost:4000/2019-01-22/spring-bean-scopes","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2019-01-22/spring-bean-scopes"},"author":{"@type":"Person","name":"leeyh0216"},"description":"Bean Scopes Bean Definition을 만든다는 것은, Bean으로 생성할 클래스를 통해 어떻게 객체를 만들어 내는지에 대한 방법(Recipe)을 만들어 내는 것이다. Bean Definition에는 생성할 Bean의 의존성(Dependency) 설정값(Configuration values) Scope 이 포함된다. 설정을 통해 객체의 Scope을 지정하는 방식은 자바의 클래스 레벨에서 Scope을 제어하는 것보다 강력하고 유연하다. Spring에서는 7개의 Scope을 지원하며, Non Web Application에서는 이 중 2개만 사용이 가능하다. Singleton Scope Spring의 기본 Scope. Spring IoC Container 당 1개의 객체를 유지한다. Spring의 Singleton Bean의 개념은 GoF 패턴에서 나오는 Singleton Pattern과 차이가 있다. GoF 패턴에서 나오는 Singleton Pattern이 적용된 클래스는 Java ClassLoader에 단 1개의 객체밖에 존재할 수 없지만, Spring에서의 Singleton Bean은 Spring IoC Container에서만 1개의 객체를 유지한다. 즉, 임의로 Singleton Bean을 만들어낼 수 있다. 일반적인 Singleton Pattern package com.leeyh0216.others; //Final 클래스로 만들어 상속이 불가하게 함 public final class SingletonExample { //JVM 내에서 1개만 유지되는 SingletonExample 객체 private static SingletonExample instance = null; //synchronized 키워드를 통해 Thread-Safe 보장 private static synchronized SingletonExample getInstance(){ if(instance == null) instance = new SingletonExample(); return instance; } private SingletonExample(){ //Do something } public static void main(String[] args) throws Exception { SingletonExample s1 = SingletonExample.getInstance(); SingletonExample s2 = SingletonExample.getInstance(); System.out.println(s1 == s2); } } 위와 같이 생성자를 private으로 선언하여 new를 통한 객체 생성을 막고, getInstance 함수를 통해서만 객체를 생성/참조할 수 있도록 하여 JVM 내에 1개의 객체만을 유지할 수 있도록 한다. Reflection을 사용하지 않고서는 일반적인 방법으로 해당 클래스의 객체를 2개 유지하는 것은 불가능하다. 위 프로그램의 결과는 true가 나오게 된다. Spring에서의 Singleton Scope 테스트를 위해 3개의 파일을 작성한다. Program Entry Point 역할을 담당하는 Application 클래스 Configuration 역할을 담당하는 AppConfig 클래스 테스트 클래스인 MyService MyService.java package com.leeyh0216.springstudy.singletonscope; public class MyService{ public MyService() { //Do something } } 아무 기능도 없이 기본 생성자만 존재하는 클래스이다. AppConfig.java package com.leeyh0216.springstudy.singletonscope; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; @Configuration @ComponentScan(&quot;com.leeyh0216.springstudy.singletonscope&quot;) public class AppConfig { @Bean public MyService getMyService(){ return new MyService(); } } MyService 타입의 Bean을 반환하는 getMyService 함수가 정의된 Configuration 클래스이다. Application.java package com.leeyh0216.springstudy.singletonscope; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); MyService m1 = applicationContext.getBean(MyService.class); MyService m2 = applicationContext.getBean(MyService.class); MyService m3 = new MyService(); System.out.println(m1 == m2); System.out.println(m2 == m3); System.out.println(m1 == m3); } } 메인 함수가 들어 있는 Application 클래스이다. 위 프로그램의 출력은 아래와 같다. true false false 위의 m1과 m2 객체는 Spring IoC Container에서 관리하는 Bean 객체이다. Spring에서의 기본 Scope은 Singleton이라 했기 때문에 m1과 m2 객체는 완전히 같은 객체이다. 그렇기 때문에 첫번째 출력은 true가 된다. 그런데 m3 객체는 MyService의 생성자를 직접 호출하여 생성한 객체이다. 즉, 이 객체는 Spring의 IoC Container의 관리를 받지 않는 객체이며, 기존에 생성된 m1, m2 객체와는 완전히 다른 객체이다. 그렇기 때문에 2,3번째 출력은 false가 되는 것이다. Prototype Scope Prototype Bean은 Bean을 참조하는 요청(getBean과 같은 함수를 호출할 때)을 할 때마다 새로운 객체가 생성된다. Prototype Scope을 가진 Bean은 Stateful한 Bean이 필요할 때 사용하고, Singleton Scope을 가진 Bean은 Stateless한 Bean이 필요할 때 사용하면 된다. 다른 Scope과 다르게 Prototype Scope을 가진 Bean의 Life Cycle은 일부만 관리된다. Spring은 Prototype Bean을 생성하여 Client에게 넘겨주지만, 해당 객체를 기록(Record라고 나와 있는데, Container가 별도로 해당 Bean에 대한 참조를 가지고 있지 않다는 것을 의미하는 것 같다.)하고 있지 않다. Prototype Scope을 가진 Bean의 initialization 관련 Callback들은 모두 호출되지만, Destruction 관련 Callback은 호출되지 않기 때문에, 해당 Bean이 비싼 자원(ex. socket, file)을 가지고 있다면 클라이언트 코드에서 별도로 해당 자원을 소멸시켜야 한다. Prototype Scope 테스트 코드 위의 Spring Singleton 과 동일한 코드이지만, AppConfig 클래스의 getMyService 메서드에 @Scope(&quot;prototype&quot;) 어노테이션이 추가된 점만 다르다. AppConfig.java package com.leeyh0216.springstudy.prototypescope; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Scope; @Configuration @ComponentScan(&quot;com.leeyh0216.springstudy.prototypescope&quot;) public class AppConfig { @Bean @Scope(&quot;prototype&quot;) public MyService getMyService(){ return new MyService(); } } 위에서는 명시적으로 @Scope 어노테이션을 통해 prototype Scope을 지정하였으나, 별도로 명시하지 않는 경우 @Scope(&quot;singleton&quot;)과 동일한 효과를 가지게 된다. 위 코드를 기준으로 Application을 실행하였을 때 아래와 같은 결과가 발생한다. false false false Singleton과 다르게 Spring IoC Container에서 getBean 함수를 호출할 때마다 MyService의 객체를 새로 생성하여 반환하기 때문에, 모든 객체가 다를 수밖에 없다. Lifecycle Callback 비교하기(Singleton vs Prototype) Singleton에서는 모든 Lifecycle Callback이 동작하고 Prototype에서는 Initialization 관련 Callback만 동작한다고 나와 있다. 아래와 같이 테스트를 수행해보았다. SingletonService.java package com.leeyh0216.springstudy.singletonvsprototype; import javax.annotation.PostConstruct; import javax.annotation.PreDestroy; public class SingletonService { public SingletonService() { //Do something } @PostConstruct public void onCreate(){ System.out.println(&quot;Singleton has created&quot;); } @PreDestroy public void onDestroy(){ System.out.println(&quot;Singleton is destroying&quot;); } } PrototypeService.java package com.leeyh0216.springstudy.singletonvsprototype; import javax.annotation.PostConstruct; import javax.annotation.PreDestroy; public class PrototypeService { public PrototypeService() { //Do something } @PostConstruct public void onCreate(){ System.out.println(&quot;Prototype has created&quot;); } @PreDestroy public void onDestroy(){ System.out.println(&quot;Prototype is destroying&quot;); } } AppConfig.java package com.leeyh0216.springstudy.singletonvsprototype; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Scope; @Configuration @ComponentScan(&quot;com.leeyh0216.springstudy.singletonvsprototype&quot;) public class AppConfig { @Bean @Scope(&quot;singleton&quot;) public SingletonService getSingletonService(){ return new SingletonService(); } @Bean @Scope(&quot;prototype&quot;) public PrototypeService getPrototypeService() { return new PrototypeService(); } } Application.java package com.leeyh0216.springstudy.singletonvsprototype; import org.springframework.context.ApplicationContext; import org.springframework.context.annotation.AnnotationConfigApplicationContext; public class Application { public static void main(String[] args) throws Exception { ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); SingletonService singletonService = applicationContext.getBean(SingletonService.class); PrototypeService prototypeService1 = applicationContext.getBean(PrototypeService.class); PrototypeService prototypeService2 = applicationContext.getBean(PrototypeService.class); ((AnnotationConfigApplicationContext) applicationContext).registerShutdownHook(); } } 위 프로그램의 출력은 아래와 같다. Singleton has created Prototype has created Prototype has created Singleton is destroying 위와 같이 Prototype Bean에 대해서는 “Prototype is destroying”이라는 문구가 출력되지 않은 것을 볼 수 있다.","@type":"BlogPosting","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


  <!-- CSS -->
  <link rel="stylesheet" href="/assets/main.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">

  <!-- Favicon -->
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png">

  <!-- RSS -->
  <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="leeyh0216's devlog" />

  <!-- Google Analytics-->
  
</head>


  <body>

    <nav class="nav">
  <div class="nav-container">
    <a href="/">
      <h2 class="nav-title">leeyh0216's devlog</h2>
    </a>
    <ul>
      <li><a href="/about">About</a></li>
      <li><a href="/">Posts</a></li>
    </ul>
  </div>
</nav>


    <main>
      <div class="post">
  <div class="post-info">
    <span>Written by</span>
    
        leeyh0216
    

    
      <br>
      <span>on&nbsp;</span><time datetime="2019-01-22 10:00:00 +0900">January 22, 2019</time>
    
  </div>

  <h1 class="post-title">Spring Core Technologies - Bean Scopes</h1>
  <div class="post-line"></div>

  <h1 id="bean-scopes">Bean Scopes</h1>

<p>Bean Definition을 만든다는 것은, Bean으로 생성할 클래스를 통해 어떻게 객체를 만들어 내는지에 대한 방법(Recipe)을 만들어 내는 것이다.</p>

<p>Bean Definition에는 생성할 Bean의</p>

<ul>
  <li>의존성(Dependency)</li>
  <li>설정값(Configuration values)</li>
  <li><strong>Scope</strong></li>
</ul>

<p>이 포함된다.</p>

<p>설정을 통해 객체의 Scope을 지정하는 방식은 자바의 클래스 레벨에서 Scope을 제어하는 것보다 강력하고 유연하다.</p>

<p>Spring에서는 7개의 Scope을 지원하며, Non Web Application에서는 이 중 2개만 사용이 가능하다.</p>

<h2 id="singleton-scope">Singleton Scope</h2>

<p>Spring의 기본 Scope. Spring IoC Container 당 1개의 객체를 유지한다.</p>

<p><img src="/assets/spring/singletonscope.jpg" alt="Singleton Scope" /></p>

<p>Spring의 Singleton Bean의 개념은 GoF 패턴에서 나오는 Singleton Pattern과 차이가 있다.</p>

<p>GoF 패턴에서 나오는 Singleton Pattern이 적용된 클래스는 Java ClassLoader에 단 1개의 객체밖에 존재할 수 없지만, Spring에서의 Singleton Bean은 Spring IoC Container에서만 1개의 객체를 유지한다. 즉, 임의로 Singleton Bean을 만들어낼 수 있다.</p>

<h3 id="일반적인-singleton-pattern">일반적인 Singleton Pattern</h3>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leeyh0216</span><span class="o">.</span><span class="na">others</span><span class="o">;</span>

<span class="c1">//Final 클래스로 만들어 상속이 불가하게 함
</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">SingletonExample</span> <span class="o">{</span>

    <span class="c1">//JVM 내에서 1개만 유지되는 SingletonExample 객체
</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">SingletonExample</span> <span class="n">instance</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

    <span class="c1">//synchronized 키워드를 통해 Thread-Safe 보장
</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">synchronized</span> <span class="nc">SingletonExample</span> <span class="nf">getInstance</span><span class="o">(){</span>
        <span class="k">if</span><span class="o">(</span><span class="n">instance</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span>
            <span class="n">instance</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SingletonExample</span><span class="o">();</span>
        <span class="k">return</span> <span class="n">instance</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nf">SingletonExample</span><span class="o">(){</span>
        <span class="c1">//Do something
</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">SingletonExample</span> <span class="n">s1</span> <span class="o">=</span> <span class="nc">SingletonExample</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>
        <span class="nc">SingletonExample</span> <span class="n">s2</span> <span class="o">=</span> <span class="nc">SingletonExample</span><span class="o">.</span><span class="na">getInstance</span><span class="o">();</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">s1</span> <span class="o">==</span> <span class="n">s2</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>위와 같이 생성자를 <code class="highlighter-rouge">private</code>으로 선언하여 <code class="highlighter-rouge">new</code>를 통한 객체 생성을 막고, <code class="highlighter-rouge">getInstance</code> 함수를 통해서만 객체를 생성/참조할 수 있도록 하여 JVM 내에 1개의 객체만을 유지할 수 있도록 한다.</p>

<p>Reflection을 사용하지 않고서는 일반적인 방법으로 해당 클래스의 객체를 2개 유지하는 것은 불가능하다.</p>

<p>위 프로그램의 결과는 <code class="highlighter-rouge">true</code>가 나오게 된다.</p>

<h3 id="spring에서의-singleton-scope">Spring에서의 Singleton Scope</h3>

<p>테스트를 위해 3개의 파일을 작성한다.</p>

<ul>
  <li>Program Entry Point 역할을 담당하는 Application 클래스</li>
  <li>Configuration 역할을 담당하는 AppConfig 클래스</li>
  <li>테스트 클래스인 MyService</li>
</ul>

<h4 id="myservicejava">MyService.java</h4>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leeyh0216</span><span class="o">.</span><span class="na">springstudy</span><span class="o">.</span><span class="na">singletonscope</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MyService</span><span class="o">{</span>

    <span class="kd">public</span> <span class="nf">MyService</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">//Do something
</span>
    <span class="o">}</span>

<span class="o">}</span></code></pre></figure>

<p>아무 기능도 없이 기본 생성자만 존재하는 클래스이다.</p>

<h4 id="appconfigjava">AppConfig.java</h4>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leeyh0216</span><span class="o">.</span><span class="na">springstudy</span><span class="o">.</span><span class="na">singletonscope</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Bean</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.ComponentScan</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Configuration</span><span class="o">;</span>

<span class="nd">@Configuration</span>
<span class="nd">@ComponentScan</span><span class="o">(</span><span class="s">"com.leeyh0216.springstudy.singletonscope"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">MyService</span> <span class="nf">getMyService</span><span class="o">(){</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">MyService</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>MyService 타입의 Bean을 반환하는 <code class="highlighter-rouge">getMyService</code> 함수가 정의된 Configuration 클래스이다.</p>

<h4 id="applicationjava">Application.java</h4>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leeyh0216</span><span class="o">.</span><span class="na">springstudy</span><span class="o">.</span><span class="na">singletonscope</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.context.ApplicationContext</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.AnnotationConfigApplicationContext</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Application</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">ApplicationContext</span> <span class="n">applicationContext</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">AppConfig</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">MyService</span> <span class="n">m1</span> <span class="o">=</span> <span class="n">applicationContext</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">MyService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">MyService</span> <span class="n">m2</span> <span class="o">=</span> <span class="n">applicationContext</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">MyService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">MyService</span> <span class="n">m3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MyService</span><span class="o">();</span>

        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">m1</span> <span class="o">==</span> <span class="n">m2</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">m2</span> <span class="o">==</span> <span class="n">m3</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">m1</span> <span class="o">==</span> <span class="n">m3</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>메인 함수가 들어 있는 Application 클래스이다.</p>

<p>위 프로그램의 출력은 아래와 같다.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">true
false
false</span></code></pre></figure>

<p>위의 <code class="highlighter-rouge">m1</code>과 <code class="highlighter-rouge">m2</code> 객체는 Spring IoC Container에서 관리하는 Bean 객체이다. Spring에서의 기본 Scope은 Singleton이라 했기 때문에 <code class="highlighter-rouge">m1</code>과 <code class="highlighter-rouge">m2</code> 객체는 완전히 같은 객체이다. 그렇기 때문에 첫번째 출력은 <code class="highlighter-rouge">true</code>가 된다.</p>

<p>그런데 <code class="highlighter-rouge">m3</code> 객체는 MyService의 생성자를 직접 호출하여 생성한 객체이다. 즉, 이 객체는 Spring의 IoC Container의 관리를 받지 않는 객체이며, 기존에 생성된 <code class="highlighter-rouge">m1</code>, <code class="highlighter-rouge">m2</code> 객체와는 완전히 다른 객체이다. 그렇기 때문에 2,3번째 출력은 <code class="highlighter-rouge">false</code>가 되는 것이다.</p>

<h2 id="prototype-scope">Prototype Scope</h2>

<p>Prototype Bean은 Bean을 참조하는 요청(<code class="highlighter-rouge">getBean</code>과 같은 함수를 호출할 때)을 할 때마다 새로운 객체가 생성된다.</p>

<p>Prototype Scope을 가진 Bean은 Stateful한 Bean이 필요할 때 사용하고, Singleton Scope을 가진 Bean은 Stateless한 Bean이 필요할 때 사용하면 된다.</p>

<p><img src="/assets/spring/prototypescope.jpg" alt="Prototype Scope" /></p>

<p>다른 Scope과 다르게 Prototype Scope을 가진 Bean의 Life Cycle은 일부만 관리된다. Spring은 Prototype Bean을 생성하여 Client에게 넘겨주지만, 해당 객체를 기록(Record라고 나와 있는데, Container가 별도로 해당 Bean에 대한 참조를 가지고 있지 않다는 것을 의미하는 것 같다.)하고 있지 않다. Prototype Scope을 가진 Bean의 initialization 관련 Callback들은 모두 호출되지만, Destruction 관련 Callback은 호출되지 않기 때문에, 해당 Bean이 비싼 자원(ex. socket, file)을 가지고 있다면 클라이언트 코드에서 별도로 해당 자원을 소멸시켜야 한다.</p>

<h3 id="prototype-scope-테스트-코드">Prototype Scope 테스트 코드</h3>

<p>위의 Spring Singleton 과 동일한 코드이지만, AppConfig 클래스의 <code class="highlighter-rouge">getMyService</code> 메서드에 <code class="highlighter-rouge">@Scope("prototype")</code> 어노테이션이 추가된 점만 다르다.</p>

<h4 id="appconfigjava-1">AppConfig.java</h4>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leeyh0216</span><span class="o">.</span><span class="na">springstudy</span><span class="o">.</span><span class="na">prototypescope</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Bean</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.ComponentScan</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Configuration</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Scope</span><span class="o">;</span>

<span class="nd">@Configuration</span>
<span class="nd">@ComponentScan</span><span class="o">(</span><span class="s">"com.leeyh0216.springstudy.prototypescope"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
    <span class="nd">@Scope</span><span class="o">(</span><span class="s">"prototype"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">MyService</span> <span class="nf">getMyService</span><span class="o">(){</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">MyService</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>위에서는 명시적으로 <code class="highlighter-rouge">@Scope</code> 어노테이션을 통해 prototype Scope을 지정하였으나, 별도로 명시하지 않는 경우 <code class="highlighter-rouge">@Scope("singleton")</code>과 동일한 효과를 가지게 된다.</p>

<p>위 코드를 기준으로 Application을 실행하였을 때 아래와 같은 결과가 발생한다.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">false
false
false</span></code></pre></figure>

<p>Singleton과 다르게 Spring IoC Container에서 <code class="highlighter-rouge">getBean</code> 함수를 호출할 때마다 MyService의 객체를 새로 생성하여 반환하기 때문에, 모든 객체가 다를 수밖에 없다.</p>

<h3 id="lifecycle-callback-비교하기singleton-vs-prototype">Lifecycle Callback 비교하기(Singleton vs Prototype)</h3>

<p>Singleton에서는 모든 Lifecycle Callback이 동작하고 Prototype에서는 Initialization 관련 Callback만 동작한다고 나와 있다.</p>

<p>아래와 같이 테스트를 수행해보았다.</p>

<h4 id="singletonservicejava">SingletonService.java</h4>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leeyh0216</span><span class="o">.</span><span class="na">springstudy</span><span class="o">.</span><span class="na">singletonvsprototype</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.annotation.PostConstruct</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.annotation.PreDestroy</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SingletonService</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="nf">SingletonService</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">//Do something
</span>
    <span class="o">}</span>

    <span class="nd">@PostConstruct</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Singleton has created"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@PreDestroy</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onDestroy</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Singleton is destroying"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<h4 id="prototypeservicejava">PrototypeService.java</h4>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leeyh0216</span><span class="o">.</span><span class="na">springstudy</span><span class="o">.</span><span class="na">singletonvsprototype</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.annotation.PostConstruct</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.annotation.PreDestroy</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">PrototypeService</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="nf">PrototypeService</span><span class="o">()</span> <span class="o">{</span>
        <span class="c1">//Do something
</span>
    <span class="o">}</span>

    <span class="nd">@PostConstruct</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Prototype has created"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@PreDestroy</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onDestroy</span><span class="o">(){</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Prototype is destroying"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<h4 id="appconfigjava-2">AppConfig.java</h4>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leeyh0216</span><span class="o">.</span><span class="na">springstudy</span><span class="o">.</span><span class="na">singletonvsprototype</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Bean</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.ComponentScan</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Configuration</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.Scope</span><span class="o">;</span>

<span class="nd">@Configuration</span>
<span class="nd">@ComponentScan</span><span class="o">(</span><span class="s">"com.leeyh0216.springstudy.singletonvsprototype"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>

    <span class="nd">@Bean</span>
    <span class="nd">@Scope</span><span class="o">(</span><span class="s">"singleton"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">SingletonService</span> <span class="nf">getSingletonService</span><span class="o">(){</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">SingletonService</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="nd">@Bean</span>
    <span class="nd">@Scope</span><span class="o">(</span><span class="s">"prototype"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">PrototypeService</span> <span class="nf">getPrototypeService</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="k">new</span> <span class="nc">PrototypeService</span><span class="o">();</span> <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<h4 id="applicationjava-1">Application.java</h4>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">leeyh0216</span><span class="o">.</span><span class="na">springstudy</span><span class="o">.</span><span class="na">singletonvsprototype</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">org.springframework.context.ApplicationContext</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.springframework.context.annotation.AnnotationConfigApplicationContext</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Application</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">Exception</span> <span class="o">{</span>
        <span class="nc">ApplicationContext</span> <span class="n">applicationContext</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">AppConfig</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">SingletonService</span> <span class="n">singletonService</span> <span class="o">=</span> <span class="n">applicationContext</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">SingletonService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">PrototypeService</span> <span class="n">prototypeService1</span> <span class="o">=</span> <span class="n">applicationContext</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">PrototypeService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">PrototypeService</span> <span class="n">prototypeService2</span> <span class="o">=</span> <span class="n">applicationContext</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="nc">PrototypeService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="o">((</span><span class="nc">AnnotationConfigApplicationContext</span><span class="o">)</span> <span class="n">applicationContext</span><span class="o">).</span><span class="na">registerShutdownHook</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>위 프로그램의 출력은 아래와 같다.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">Singleton has created
Prototype has created
Prototype has created
Singleton is destroying</code></pre></figure>

<p>위와 같이 Prototype Bean에 대해서는 “Prototype is destroying”이라는 문구가 출력되지 않은 것을 볼 수 있다.</p>


</div>

<div class="pagination">
  
    <a href="/2019-01-23/spring-customizing-the-nature-of-a-bean" class="left arrow">&#8592;</a>
  
  
    <a href="/2018-12-30/spring-rabbitmq-2" class="right arrow">&#8594;</a>
  

  <a href="#" class="top">Top</a>
</div>

    </main>

    <footer>
  <span>
    &copy; <time datetime="2019-10-08 19:35:35 +0900">2019</time> leeyh0216. Made with Jekyll using the <a href="https://github.com/chesterhow/tale/">Tale</a> theme.
  </span>
</footer>

  </body>
</html>
