<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Spark RDD의 count()는 어떻게 동작하는가?(Shuffle이 없는, Driver 편) | leeyh0216’s devlog</title>
<meta name="generator" content="Jekyll v3.8.6" />
<meta property="og:title" content="Spark RDD의 count()는 어떻게 동작하는가?(Shuffle이 없는, Driver 편)" />
<meta name="author" content="leeyh0216" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Spark RDD의 count()는 어떻게 동작하는가?(Shuffle이 없는, Driver 편) Spark RDD의 기본 연산 중 하나인 count()가 어떻게 동작하는지 알아보도록 한다. Shuffle이 들어가면 분석이 너무 어렵기 때문에 Shuffle이 발생하지 않는 코드로만 추적해보았으며, 이번 글에서는 Driver에서 발생하는 과정만을 다룬다. Shuffle이 없는 count() Spark 코드를 확인해보면 Shuffle이 존재하는 연산보다 Shuffle이 존재하지 않는 연산이 훨씬 쉽고, 읽어야 할 코드의 양이 적기 때문에 Shuffle이 존재하지 않는 RDD의 count()부터 알아보기로 한다. 아래와 같이 한 번의 map으로 이루어진 RDD의 count()가 어떻게 동작하는지 알아본다. val parallelizedRDD = sc.parallelize(Seq(1,2,3,4,5,6,7,8,9,10), 2) val transformedRDD = parallelizedRDD.map(_ + &quot;th value&quot;) transformedRDD.count() val parallelizedRDD = sc.parallelize(Seq(1,2,3,4,5,6,7,8,9,10), 2) SparkContext 클래스에 있는 parallelize는 Caller(Driver)에 존재하는 Scala Collection을 RDD로 만드는 함수이다. 반환 타입은 ParallelCollectionRDD이다. def parallelize[T: ClassTag]( seq: Seq[T], numSlices: Int = defaultParallelism): RDD[T] = withScope { assertNotStopped() new ParallelCollectionRDD[T](this, seq, numSlices, Map[Int, Seq[String]]() } ParallelCollectionRDD는 RDD클래스를 상속하는데, 생성자를 눈여겨 보아야 한다. private[spark] class ParallelCollectionRDD[T: ClassTag]( sc: SparkContext, @transient private val data: Seq[T], numSlices: Int, locationPrefs: Map[Int, Seq[String]]) extends RDD[T](sc, Nil) { 위 코드에서 호출하고 있는 부모 클래스 RDD의 생성자 코드는 아래와 같다. abstract class RDD[T: ClassTag]( @transient private var _sc: SparkContext, @transient private var deps: Seq[Dependency[_]] ) extends Serializable with Logging { parallelize 함수를 통해 생성되는 RDD는 부모 RDD가 존재하지 않기 때문에 Dependency가 존재하지 않아 RDD의 Dependency가 null로 만들어진다. 그리고 RDD에서 중요한 요소 중 하나인 Partition이 어떻게 생성되는지 확인해보도록 한다. 아래 코드는 ParallelCollectionRDD 클래스의 getPartitions 함수이다. override def getPartitions: Array[Partition] = { val slices = ParallelCollectionRDD.slice(data, numSlices).toArray slices.indices.map(i =&gt; new ParallelCollectionPartition(id, i, slices(i))).toArray } parallelize 함수의 인자인 data를 numSlices개로 잘라서 ParallelCollectionPartition으로 만든다. 아래 코드를 실행해보면 생성된 파티션의 정보를 확인할 수 있다. val parallelizedRDD = sc.parallelize(Seq(1,2,3,4,5,6,7,8,9,10), 2) parallelizedRDD.partitions.map(_.asInstanceOf[ParallelCollectionPartition[Int]]).foreach(p =&gt; println(s&quot;RDD: ${p.rddId}, Partition: ${p.index}, Values: ${p.values.mkString(&quot;,&quot;)}&quot;)) 출력 결과: RDD: 0, Partition: 0, Values: 1,2,3,4,5 RDD: 0, Partition: 1, Values: 6,7,8,9,10 RDD의 ID RDD의 ID는 RDD 객체 생성 시 SparkContext의 newRddId 함수를 호출하여 생성한다. 즉, RDD의 ID는 SparkContext 내에서 유일한 값이다. RDD 클래스의 id 필드 /** A unique ID for this RDD (within its SparkContext). */ val id: Int = sc.newRddId() SparkContext 클래스의 newRddId 함수 /** Register a new RDD, returning its RDD ID */ private[spark] def newRddId(): Int = nextRddId.getAndIncrement() val transformedRDD = parallelizedRDD.map(_ + “th value”) parallelize 함수를 통해 생성된 RDD에 map 함수를 적용하여 내부 값들을 변환하는 동작이다. map T 타입(원본 RDD의 요소 타입)을 U 타입으로 변환하는 함수를 인자로 받고, MapPartitionsRDD 타입의 객체를 반환하는 함수이다. MapPartitionsRDD 클래스의 생성자는 다음과 같다. private[spark] class MapPartitionsRDD[U: ClassTag, T: ClassTag]( var prev: RDD[T], f: (TaskContext, Int, Iterator[T]) =&gt; Iterator[U], // (TaskContext, partition index, iterator) preservesPartitioning: Boolean = false, isFromBarrier: Boolean = false, isOrderSensitive: Boolean = false) extends RDD[U](prev) { 이 떄 주의깊게 보아야 할 점은 RDD의 생성자에 Caller RDD(예시에서는 ParallelizedRDD)를 넘기고 있다. 해당 생성자의 코드는 아래와 같다. /** Construct an RDD with just a one-to-one dependency on one parent */ def this(@transient oneParent: RDD[_]) = this(oneParent.context, List(new OneToOneDependency(oneParent))) 아까와 달리 Dependency에 null이 아닌 OneToOneDependency를 넣어주고 있다. map은 NarrowDependency, 즉 Shuffle이 발생하지 않는 Transformation 연산이기 때문에 이전 RDD의 파티션과 새로 생성되는 RDD의 파티션이 1:1 관계를 가지게 되어 있다. OneToOneDependency Parent RDD와 Child RDD가 1:1 관계를 가지는 것을 표현하는 클래스이다. /** * :: DeveloperApi :: * Represents a one-to-one dependency between partitions of the parent and child RDDs. */ @DeveloperApi class OneToOneDependency[T](rdd: RDD[T]) extends NarrowDependency[T](rdd) { override def getParents(partitionId: Int): List[Int] = List(partitionId) } parallelizedRDD와 transformedRDD의 관계는 OneToOneDependency를 이용하여 아래와 같이 표현할 수 있다. Parent(parallelizedRDD) &lt;— OneToOneDependency —&gt; Child(transformedRDD) transformedRDD의 Partition 구성 transformedRDD의 파티션은 어떤 형태를 가지고 있을까? transformedRDD의 getPartitions 함수는 다음과 같다. override def getPartitions: Array[Partition] = firstParent[T].partitions 부모 파티션의 Partition을 그대로 반환하게 되어 있다. map 과정에서 Shuffle이 발생하지 않기 때문에 RDD의 관계와 같이 Partition의 관계도 부모와 자식이 1:1로 유지되는 것을 알 수 있다. 코드를 통해 실제로도 동일한 파티션인지 확인해본다. 실제 값을 출력하는 방법과 객체를 비교하는 방법으로 검증해보았다. 실제 값을 출력하는 방법(위의 parallelizedRDD에 대해 호출한 출력값과 동일해야 함) transformedRDD.partitions.map(_.asInstanceOf[ParallelCollectionPartition[Int]]).foreach(p =&gt; println(s&quot;RDD: ${p.rddId}, Partition: ${p.index}, Values: ${p.values.mkString(&quot;,&quot;)}&quot;)) 출력 결과: RDD: 0, Partition: 0, Values: 1,2,3,4,5 RDD: 0, Partition: 1, Values: 6,7,8,9,10 partitions 객체가 동일한지 확인하는 방법 assert(parallelizedRDD.partitions === transformedRDD.partitions) transformedRDD.count() count()은 Action으로써 실제로 작업이 실행되는 함수이다. count의 코드는 아래와 같다. def count(): Long = sc.runJob(this, Utils.getIteratorSize _).sum SparkContext 객체의 runJob 함수를 호출한다. 호출되는 runJob은 내부적으로 다시 오버로딩 된 runJob 함수들을 호출하게 된다. def runJob[T, U: ClassTag](rdd: RDD[T], func: Iterator[T] =&gt; U): Array[U] = { runJob(rdd, func, 0 until rdd.partitions.length) } def runJob[T, U: ClassTag]( rdd: RDD[T], func: Iterator[T] =&gt; U, partitions: Seq[Int]): Array[U] = { val cleanedFunc = clean(func) runJob(rdd, (ctx: TaskContext, it: Iterator[T]) =&gt; cleanedFunc(it), partitions) } def runJob[T, U: ClassTag]( rdd: RDD[T], func: (TaskContext, Iterator[T]) =&gt; U, partitions: Seq[Int]): Array[U] = { val results = new Array[U](partitions.size) runJob[T, U](rdd, func, partitions, (index, res) =&gt; results(index) = res) results } def runJob[T, U: ClassTag]( rdd: RDD[T], func: (TaskContext, Iterator[T]) =&gt; U, partitions: Seq[Int], resultHandler: (Int, U) =&gt; Unit): Unit = { if (stopped.get()) { throw new IllegalStateException(&quot;SparkContext has been shutdown&quot;) } val callSite = getCallSite val cleanedFunc = clean(func) logInfo(&quot;Starting job: &quot; + callSite.shortForm) if (conf.getBoolean(&quot;spark.logLineage&quot;, false)) { logInfo(&quot;RDD&#39;s recursive dependencies:\n&quot; + rdd.toDebugString) } dagScheduler.runJob(rdd, cleanedFunc, partitions, callSite, resultHandler, localProperties.get) progressBar.foreach(_.finishAll()) rdd.doCheckpoint() } 대부분의 runJob의 매개변수의 구성은 아래와 같다. rdd: Action을 호출하는 RDD이다. func: rdd의 각 파티션에 적용할 함수이다. partitions: rdd를 구성하는 Partition의 Sequence 다른 코드(Clousure를 닫아주는 clean 등)들은 부가적인 부분이고 실제 Job을 수행하는 부분은 dagScheduler의 runJob 함수 호출이다. DagScheduler의 동작(1) count(), show(), save() 등과 같은 Action을 호출하게 되면, DagScheduler에서 RDD를 Job으로 변환하여 실제 연산을 수행하게 된다. SparkContext에서 호출한 DagScheduler의 runJob의 코드는 아래와 같다. def runJob[T, U]( rdd: RDD[T], func: (TaskContext, Iterator[T]) =&gt; U, partitions: Seq[Int], callSite: CallSite, resultHandler: (Int, U) =&gt; Unit, properties: Properties): Unit = { val start = System.nanoTime val waiter = submitJob(rdd, func, partitions, callSite, resultHandler, properties) ThreadUtils.awaitReady(waiter.completionFuture, Duration.Inf) waiter.completionFuture.value.get match { case scala.util.Success(_) =&gt; logInfo(&quot;Job %d finished: %s, took %f s&quot;.format (waiter.jobId, callSite.shortForm, (System.nanoTime - start) / 1e9)) case scala.util.Failure(exception) =&gt; logInfo(&quot;Job %d failed: %s, took %f s&quot;.format (waiter.jobId, callSite.shortForm, (System.nanoTime - start) / 1e9)) // SPARK-8644: Include user stack trace in exceptions coming from DAGScheduler. val callerStackTrace = Thread.currentThread().getStackTrace.tail exception.setStackTrace(exception.getStackTrace ++ callerStackTrace) throw exception } } 실제 Job을 submit하고 기다리는 부분은 아래 코드이다. val waiter = submitJob(rdd, func, partitions, callSite, resultHandler, properties) 다시 submitJob 코드를 확인해보면 다음과 같다. def submitJob[T, U]( rdd: RDD[T], func: (TaskContext, Iterator[T]) =&gt; U, partitions: Seq[Int], callSite: CallSite, resultHandler: (Int, U) =&gt; Unit, properties: Properties): JobWaiter[U] = { // Check to make sure we are not launching a task on a partition that does not exist. val maxPartitions = rdd.partitions.length partitions.find(p =&gt; p &gt;= maxPartitions || p &lt; 0).foreach { p =&gt; throw new IllegalArgumentException( &quot;Attempting to access a non-existent partition: &quot; + p + &quot;. &quot; + &quot;Total number of partitions: &quot; + maxPartitions) } val jobId = nextJobId.getAndIncrement() if (partitions.isEmpty) { val time = clock.getTimeMillis() listenerBus.post( SparkListenerJobStart(jobId, time, Seq[StageInfo](), properties)) listenerBus.post( SparkListenerJobEnd(jobId, time, JobSucceeded)) // Return immediately if the job is running 0 tasks return new JobWaiter[U](this, jobId, 0, resultHandler) } assert(partitions.nonEmpty) val func2 = func.asInstanceOf[(TaskContext, Iterator[_]) =&gt; _] val waiter = new JobWaiter[U](this, jobId, partitions.size, resultHandler) eventProcessLoop.post(JobSubmitted( jobId, rdd, func2, partitions.toArray, callSite, waiter, SerializationUtils.clone(properties))) waiter } 코드의 윗부분들은 Partition이 없는 경우 등 특수한 상황을 처리하는 부분이고, 우리가 실제로 눈여겨보아야 할 부분은 아래의 코드이다. val func2 = func.asInstanceOf[(TaskContext, Iterator[_]) =&gt; _] val waiter = new JobWaiter[U](this, jobId, partitions.size, resultHandler) eventProcessLoop.post(JobSubmitted( jobId, rdd, func2, partitions.toArray, callSite, waiter, SerializationUtils.clone(properties))) waiter EventLoop 타입인 eventProcessLoop 객체의 post 함수 호출을 통해 실제 작업을 호출하게 된다. EventLoop와 DAGSchedulerEventProcessLoop EventLoop Job을 수행하는 Action 연산이나 Job을 종료하는 Job Cancel이 호출될 경우 이러한 작업을 처리하는 Thread를 만들어 수행하는 추상 클래스이며, DagSchedulerEventProcessLoop는 EventLoop를 상속한 구체 클래스이다. 위의 DagScheduler에서 post를 호출하게 되면 EventLoop의 eventQueue에 작업을 넣는다. def post(event: E): Unit = { if (!stopped.get) { if (eventThread.isAlive) { eventQueue.put(event) } else { onError(new IllegalStateException(s&quot;$name has already been stopped accidentally.&quot;)) } } } EventLoop는 무한루프를 돌며 EventQueue에서 작업을 꺼내 onReceive 함수를 호출한다. override def run(): Unit = { try { while (!stopped.get) { val event = eventQueue.take() try { onReceive(event) } catch { case NonFatal(e) =&gt; try { onError(e) } catch { case NonFatal(e) =&gt; logError(&quot;Unexpected error in &quot; + name, e) } } } } catch { case ie: InterruptedException =&gt; // exit even if eventQueue is not empty case NonFatal(e) =&gt; logError(&quot;Unexpected error in &quot; + name, e) } } onReceive 함수는 EventLoop 클래스의 구현체인 DagSchedulerEventProcessLoop의 onReceive에 구현되어 있다. override def onReceive(event: DAGSchedulerEvent): Unit = { val timerContext = timer.time() try { doOnReceive(event) } finally { timerContext.stop() } } onReceive의 내부에서는 다시 doOnReceive 함수를 호출하게 된다. doOnReceive 함수에서는 매개변수로 전달받은 Event를 패턴매칭을 통해 걸러내고 DagScheduler의 handle 함수에게 넘기게 된다. private def doOnReceive(event: DAGSchedulerEvent): Unit = event match { case JobSubmitted(jobId, rdd, func, partitions, callSite, listener, properties) =&gt; dagScheduler.handleJobSubmitted(jobId, rdd, func, partitions, callSite, listener, properties) case MapStageSubmitted(jobId, dependency, callSite, listener, properties) =&gt; dagScheduler.handleMapStageSubmitted(jobId, dependency, callSite, listener, properties) case StageCancelled(stageId, reason) =&gt; dagScheduler.handleStageCancellation(stageId, reason) case JobCancelled(jobId, reason) =&gt; dagScheduler.handleJobCancellation(jobId, reason) ...생략 우리가 DagScheduler에서 호출한 submitJob 코드를 보면 아래와 같았다. eventProcessLoop.post(JobSubmitted( jobId, rdd, func2, partitions.toArray, callSite, waiter, SerializationUtils.clone(properties))) JobSumitted 타입의 객체를 전달했기 때문에 case문의 첫번째에 걸려 DagScheduler의 handleJobSubmitted를 호출한다. case JobSubmitted(jobId, rdd, func, partitions, callSite, listener, properties) =&gt; dagScheduler.handleJobSubmitted(jobId, rdd, func, partitions, callSite, listener, properties) handleJobSubmitted 함수가 워낙 길어 필요한 부분만 간추리면 아래와 같이 볼 수 있다. private[scheduler] def handleJobSubmitted(jobId: Int, finalRDD: RDD[_], func: (TaskContext, Iterator[_]) =&gt; _, partitions: Array[Int], callSite: CallSite, listener: JobListener, properties: Properties) { var finalStage: ResultStage = null try { // New stage creation may throw an exception if, for example, jobs are run on a // HadoopRDD whose underlying HDFS files have been deleted. finalStage = createResultStage(finalRDD, func, partitions, jobId, callSite) } catch { ...생략 } // Job submitted, clear internal data. barrierJobIdToNumTasksCheckFailures.remove(jobId) val job = new ActiveJob(jobId, finalStage, callSite, listener, properties) clearCacheLocs() ...생략 jobIdToActiveJob(jobId) = job activeJobs += job finalStage.setActiveJob(job) val stageIds = jobIdToStageIds(jobId).toArray val stageInfos = stageIds.flatMap(id =&gt; stageIdToStage.get(id).map(_.latestInfo)) listenerBus.post( SparkListenerJobStart(job.jobId, jobSubmissionTime, stageInfos, properties)) submitStage(finalStage) } createResultStage 함수를 호출하여 Action 연산을 호출한 RDD를 통해 ResultStage를 생성하고 이를 submitStage 함수를 통해 다시 DagSchedulerEventProcessLoop에게 전달한다. Stage의 정의와 종류 Stage는 동일한 Shuffle Dependency를 가진 Task들의 집합이다(즉, Shuffle이 Stage를 나누는 기준이 된다). Stage를 구성하는 Task들은 Narrow Dependency를 통해 연결되어 있으며, 병렬로 실행될 수 있다. Stage는 ShuffleMapStage와 ResultStage로 나뉘어진다. ShuffleMapStage: Task들의 결과가 다른 Stage의 Input으로 들어가는 Stage ResultStage: Action의 결과를 출력하기 위해 동작하는 Stage 즉, 1개의 Spark Job은 1개 이상의 ShuffleMapStage와 1개의 ResultStage로 구성된다고 볼 수 있다. DagScheduler의 동작(2) createResultStage 함수의 코드는 아래와 같다. private def createResultStage( rdd: RDD[_], func: (TaskContext, Iterator[_]) =&gt; _, partitions: Array[Int], jobId: Int, callSite: CallSite): ResultStage = { checkBarrierStageWithDynamicAllocation(rdd) checkBarrierStageWithNumSlots(rdd) checkBarrierStageWithRDDChainPattern(rdd, partitions.toSet.size) val parents = getOrCreateParentStages(rdd, jobId) val id = nextStageId.getAndIncrement() val stage = new ResultStage(id, rdd, func, partitions, parents, jobId, callSite) stageIdToStage(id) = stage updateJobIdStageIdMaps(jobId, stage) stage } getOrCreateParentStages 라는 함수를 통해 ResultStage 를 생성하는 이전 Stage를 가져온다. 여기서 우리가 처음 호출했던 코드를 다시 확인해보자. val parallelizedRDD = sc.parallelize(Seq(1,2,3,4,5,6,7,8,9,10), 2) val transformedRDD = parallelizedRDD.map(_ + &quot;th value&quot;) transformedRDD.count() parallelize와 map으로만 구성된 RDD이기 때문에 Shuffle이 존재하지 않고, 결과적으로 이 코드는 1개의 Stage로만 이루어져 있다. 따라서 위의 getOrCreateParentStages 함수는 null을 반환하게 된다. 따라서 createResultStage에서는 1개의 ResultStage만 반환하게 된다. 생성된 Stage는 handleJobSubmitted의 submitStage 함수를 통해 처리된다. private[scheduler] def handleJobSubmitted(jobId: Int, finalRDD: RDD[_], func: (TaskContext, Iterator[_]) =&gt; _, partitions: Array[Int], callSite: CallSite, listener: JobListener, properties: Properties) { var finalStage: ResultStage = null try { // New stage creation may throw an exception if, for example, jobs are run on a // HadoopRDD whose underlying HDFS files have been deleted. finalStage = createResultStage(finalRDD, func, partitions, jobId, callSite) } catch { ...생략 } ...생략 submitStage(finalStage) } submitStage의 코드는 아래와 같다. private def submitStage(stage: Stage) { val jobId = activeJobForStage(stage) if (jobId.isDefined) { logDebug(&quot;submitStage(&quot; + stage + &quot;)&quot;) if (!waitingStages(stage) &amp;&amp; !runningStages(stage) &amp;&amp; !failedStages(stage)) { val missing = getMissingParentStages(stage).sortBy(_.id) logDebug(&quot;missing: &quot; + missing) if (missing.isEmpty) { logInfo(&quot;Submitting &quot; + stage + &quot; (&quot; + stage.rdd + &quot;), which has no missing parents&quot;) submitMissingTasks(stage, jobId.get) } else { for (parent &lt;- missing) { submitStage(parent) } waitingStages += stage } } } else { abortStage(stage, &quot;No active job for stage &quot; + stage.id, None) } } 일단 getMissingParentStages 함수를 통해 해당 Stage 이전에 실행되어야 하는 Stage를 찾아내고 실행한다. 이 예제에서는 이전에 실행되어야 하는 Stage가 존재하지 않으므로 submitMissingTasks 함수가 실행된다. submitMissingTasks 함수는 워낙 길어서 필요한 부분만 잘라보았는데, 중요한 부분은 아래와 같다. val tasks: Seq[Task[_]] = try { val serializedTaskMetrics = closureSerializer.serialize(stage.latestInfo.taskMetrics).array() stage match { case stage: ShuffleMapStage =&gt; stage.pendingPartitions.clear() partitionsToCompute.map { id =&gt; val locs = taskIdToLocations(id) val part = partitions(id) stage.pendingPartitions += id new ShuffleMapTask(stage.id, stage.latestInfo.attemptNumber, taskBinary, part, locs, properties, serializedTaskMetrics, Option(jobId), Option(sc.applicationId), sc.applicationAttemptId, stage.rdd.isBarrier()) } case stage: ResultStage =&gt; partitionsToCompute.map { id =&gt; val p: Int = stage.partitions(id) val part = partitions(p) val locs = taskIdToLocations(id) new ResultTask(stage.id, stage.latestInfo.attemptNumber, taskBinary, part, locs, id, properties, serializedTaskMetrics, Option(jobId), Option(sc.applicationId), sc.applicationAttemptId, stage.rdd.isBarrier()) } } } catch { case NonFatal(e) =&gt; abortStage(stage, s&quot;Task creation failed: $e\n${Utils.exceptionString(e)}&quot;, Some(e)) runningStages -= stage return } 위의 코드는 Stage를 Task로 분리하여 TaskSet 형태로 만드는 과정이다. Task는 1개의 Partition을 연산하는 작업을 의미하며, TaskSet은 1개 이상의 Task로 구성된 개념으로 사실상 Stage와 동일하다고 생각하면 될 것 같다. Task는 Stage의 종류에 따라 ShuffleMapStage일 경우 ShuffleMapTask, ResultStage일 경우 ResultTask로 구분되어 생성된다. 이렇게 생성된 TaskSet은 TaskScheduler의 submitTasks 함수에 전달되어 실행된다. taskScheduler.submitTasks(new TaskSet( tasks.toArray, stage.id, stage.latestInfo.attemptNumber, jobId, properties)) TaskScheduler의 구현체인 TaskSchedulerImpl의 submitTasks 에서는 다시 SchedulerBackend의 구현체인 CoarseGrainedSchedulerBackend의 receiveOffers를 호출하게 된다. 사실 이 부분에서 receiveOffers의 인자로 넘기는게 없는데, 실행시킬 수 있다는게 이해가 가지 않는다. 다만 CoarseGrainedSchedulerBackend에서 TaskSchedulerImpl 객체를 내부 변수로 가지고 있기 때문에 TaskScehdulerImpl의 내부 변수를 참조하여 실행시키는 것이 아닌가 하는 추측으로 진행을 했다. SchedulerBackend(CoarseGrainedSchedulerBackend)의 동작 SchedulerBackend의 구현체인 CoarseGrainedSchedulerBackend의 receiveOffer는 다시 DriverEndpoint 객체의 send 함수를 호출하여 실행을 요청한다. DriverEndpoint의 receive 함수에서는 ReceiveOffer 이벤트를 수신하여 makeOffers 함수를 수행한다. case ReviveOffers =&gt; makeOffers() makeOffers 함수에서는 실행할 Task의 정보를 받아와 launchTask 함수를 통해 실제 Task 실행을 수행한다. private def makeOffers() { // Make sure no executor is killed while some task is launching on it val taskDescs = withLock { // Filter out executors under killing val activeExecutors = executorDataMap.filterKeys(executorIsAlive) val workOffers = activeExecutors.map { case (id, executorData) =&gt; new WorkerOffer(id, executorData.executorHost, executorData.freeCores, Some(executorData.executorAddress.hostPort), executorData.resourcesInfo.map { case (rName, rInfo) =&gt; (rName, rInfo.availableAddrs.toBuffer)} ) }.toIndexedSeq scheduler.resourceOffers(workOffers) } if (taskDescs.nonEmpty) { launchTasks(taskDescs) } } 위 함수에서 아마 TaskScheduler에서 만든 TaskSet을 받아 처리하는 것 같은데, 어디서 데이터를 가져오는지는 잘 모르겠다. 아마 executorDataMap일 것 같은데.. 좀 더 살펴봐야 할 것 같다. 대망의 launchTask 함수이다. TaskSet을 구성하는 Task들을 Serialization하여 각 Executor에게 실행을 요청한다. private def launchTasks(tasks: Seq[Seq[TaskDescription]]) { for (task &lt;- tasks.flatten) { val serializedTask = TaskDescription.encode(task) if (serializedTask.limit() &gt;= maxRpcMessageSize) { Option(scheduler.taskIdToTaskSetManager.get(task.taskId)).foreach { taskSetMgr =&gt; try { var msg = &quot;Serialized task %s:%d was %d bytes, which exceeds max allowed: &quot; + s&quot;${RPC_MESSAGE_MAX_SIZE.key} (%d bytes). Consider increasing &quot; + s&quot;${RPC_MESSAGE_MAX_SIZE.key} or using broadcast variables for large values.&quot; msg = msg.format(task.taskId, task.index, serializedTask.limit(), maxRpcMessageSize) taskSetMgr.abort(msg) } catch { case e: Exception =&gt; logError(&quot;Exception in error callback&quot;, e) } } } else { val executorData = executorDataMap(task.executorId) // Do resources allocation here. The allocated resources will get released after the task // finishes. executorData.freeCores -= scheduler.CPUS_PER_TASK task.resources.foreach { case (rName, rInfo) =&gt; assert(executorData.resourcesInfo.contains(rName)) executorData.resourcesInfo(rName).acquire(rInfo.addresses) } logDebug(s&quot;Launching task ${task.taskId} on executor id: ${task.executorId} hostname: &quot; + s&quot;${executorData.executorHost}.&quot;) executorData.executorEndpoint.send(LaunchTask(new SerializableBuffer(serializedTask))) } } } 여기까지가 Driver 단에서 RDD의 Action을 수행한 후 Task의 실행을 Executor에게 Launch하도록 요청하는 과정이다. 3줄짜리 코드를 실행하기 위해 이렇게 많은 구성요소들이 결합하여 동작하는줄 모르고 있었고, 생각보다 실행이 매우 복잡하다는 것을 느낄 수 있었다." />
<meta property="og:description" content="Spark RDD의 count()는 어떻게 동작하는가?(Shuffle이 없는, Driver 편) Spark RDD의 기본 연산 중 하나인 count()가 어떻게 동작하는지 알아보도록 한다. Shuffle이 들어가면 분석이 너무 어렵기 때문에 Shuffle이 발생하지 않는 코드로만 추적해보았으며, 이번 글에서는 Driver에서 발생하는 과정만을 다룬다. Shuffle이 없는 count() Spark 코드를 확인해보면 Shuffle이 존재하는 연산보다 Shuffle이 존재하지 않는 연산이 훨씬 쉽고, 읽어야 할 코드의 양이 적기 때문에 Shuffle이 존재하지 않는 RDD의 count()부터 알아보기로 한다. 아래와 같이 한 번의 map으로 이루어진 RDD의 count()가 어떻게 동작하는지 알아본다. val parallelizedRDD = sc.parallelize(Seq(1,2,3,4,5,6,7,8,9,10), 2) val transformedRDD = parallelizedRDD.map(_ + &quot;th value&quot;) transformedRDD.count() val parallelizedRDD = sc.parallelize(Seq(1,2,3,4,5,6,7,8,9,10), 2) SparkContext 클래스에 있는 parallelize는 Caller(Driver)에 존재하는 Scala Collection을 RDD로 만드는 함수이다. 반환 타입은 ParallelCollectionRDD이다. def parallelize[T: ClassTag]( seq: Seq[T], numSlices: Int = defaultParallelism): RDD[T] = withScope { assertNotStopped() new ParallelCollectionRDD[T](this, seq, numSlices, Map[Int, Seq[String]]() } ParallelCollectionRDD는 RDD클래스를 상속하는데, 생성자를 눈여겨 보아야 한다. private[spark] class ParallelCollectionRDD[T: ClassTag]( sc: SparkContext, @transient private val data: Seq[T], numSlices: Int, locationPrefs: Map[Int, Seq[String]]) extends RDD[T](sc, Nil) { 위 코드에서 호출하고 있는 부모 클래스 RDD의 생성자 코드는 아래와 같다. abstract class RDD[T: ClassTag]( @transient private var _sc: SparkContext, @transient private var deps: Seq[Dependency[_]] ) extends Serializable with Logging { parallelize 함수를 통해 생성되는 RDD는 부모 RDD가 존재하지 않기 때문에 Dependency가 존재하지 않아 RDD의 Dependency가 null로 만들어진다. 그리고 RDD에서 중요한 요소 중 하나인 Partition이 어떻게 생성되는지 확인해보도록 한다. 아래 코드는 ParallelCollectionRDD 클래스의 getPartitions 함수이다. override def getPartitions: Array[Partition] = { val slices = ParallelCollectionRDD.slice(data, numSlices).toArray slices.indices.map(i =&gt; new ParallelCollectionPartition(id, i, slices(i))).toArray } parallelize 함수의 인자인 data를 numSlices개로 잘라서 ParallelCollectionPartition으로 만든다. 아래 코드를 실행해보면 생성된 파티션의 정보를 확인할 수 있다. val parallelizedRDD = sc.parallelize(Seq(1,2,3,4,5,6,7,8,9,10), 2) parallelizedRDD.partitions.map(_.asInstanceOf[ParallelCollectionPartition[Int]]).foreach(p =&gt; println(s&quot;RDD: ${p.rddId}, Partition: ${p.index}, Values: ${p.values.mkString(&quot;,&quot;)}&quot;)) 출력 결과: RDD: 0, Partition: 0, Values: 1,2,3,4,5 RDD: 0, Partition: 1, Values: 6,7,8,9,10 RDD의 ID RDD의 ID는 RDD 객체 생성 시 SparkContext의 newRddId 함수를 호출하여 생성한다. 즉, RDD의 ID는 SparkContext 내에서 유일한 값이다. RDD 클래스의 id 필드 /** A unique ID for this RDD (within its SparkContext). */ val id: Int = sc.newRddId() SparkContext 클래스의 newRddId 함수 /** Register a new RDD, returning its RDD ID */ private[spark] def newRddId(): Int = nextRddId.getAndIncrement() val transformedRDD = parallelizedRDD.map(_ + “th value”) parallelize 함수를 통해 생성된 RDD에 map 함수를 적용하여 내부 값들을 변환하는 동작이다. map T 타입(원본 RDD의 요소 타입)을 U 타입으로 변환하는 함수를 인자로 받고, MapPartitionsRDD 타입의 객체를 반환하는 함수이다. MapPartitionsRDD 클래스의 생성자는 다음과 같다. private[spark] class MapPartitionsRDD[U: ClassTag, T: ClassTag]( var prev: RDD[T], f: (TaskContext, Int, Iterator[T]) =&gt; Iterator[U], // (TaskContext, partition index, iterator) preservesPartitioning: Boolean = false, isFromBarrier: Boolean = false, isOrderSensitive: Boolean = false) extends RDD[U](prev) { 이 떄 주의깊게 보아야 할 점은 RDD의 생성자에 Caller RDD(예시에서는 ParallelizedRDD)를 넘기고 있다. 해당 생성자의 코드는 아래와 같다. /** Construct an RDD with just a one-to-one dependency on one parent */ def this(@transient oneParent: RDD[_]) = this(oneParent.context, List(new OneToOneDependency(oneParent))) 아까와 달리 Dependency에 null이 아닌 OneToOneDependency를 넣어주고 있다. map은 NarrowDependency, 즉 Shuffle이 발생하지 않는 Transformation 연산이기 때문에 이전 RDD의 파티션과 새로 생성되는 RDD의 파티션이 1:1 관계를 가지게 되어 있다. OneToOneDependency Parent RDD와 Child RDD가 1:1 관계를 가지는 것을 표현하는 클래스이다. /** * :: DeveloperApi :: * Represents a one-to-one dependency between partitions of the parent and child RDDs. */ @DeveloperApi class OneToOneDependency[T](rdd: RDD[T]) extends NarrowDependency[T](rdd) { override def getParents(partitionId: Int): List[Int] = List(partitionId) } parallelizedRDD와 transformedRDD의 관계는 OneToOneDependency를 이용하여 아래와 같이 표현할 수 있다. Parent(parallelizedRDD) &lt;— OneToOneDependency —&gt; Child(transformedRDD) transformedRDD의 Partition 구성 transformedRDD의 파티션은 어떤 형태를 가지고 있을까? transformedRDD의 getPartitions 함수는 다음과 같다. override def getPartitions: Array[Partition] = firstParent[T].partitions 부모 파티션의 Partition을 그대로 반환하게 되어 있다. map 과정에서 Shuffle이 발생하지 않기 때문에 RDD의 관계와 같이 Partition의 관계도 부모와 자식이 1:1로 유지되는 것을 알 수 있다. 코드를 통해 실제로도 동일한 파티션인지 확인해본다. 실제 값을 출력하는 방법과 객체를 비교하는 방법으로 검증해보았다. 실제 값을 출력하는 방법(위의 parallelizedRDD에 대해 호출한 출력값과 동일해야 함) transformedRDD.partitions.map(_.asInstanceOf[ParallelCollectionPartition[Int]]).foreach(p =&gt; println(s&quot;RDD: ${p.rddId}, Partition: ${p.index}, Values: ${p.values.mkString(&quot;,&quot;)}&quot;)) 출력 결과: RDD: 0, Partition: 0, Values: 1,2,3,4,5 RDD: 0, Partition: 1, Values: 6,7,8,9,10 partitions 객체가 동일한지 확인하는 방법 assert(parallelizedRDD.partitions === transformedRDD.partitions) transformedRDD.count() count()은 Action으로써 실제로 작업이 실행되는 함수이다. count의 코드는 아래와 같다. def count(): Long = sc.runJob(this, Utils.getIteratorSize _).sum SparkContext 객체의 runJob 함수를 호출한다. 호출되는 runJob은 내부적으로 다시 오버로딩 된 runJob 함수들을 호출하게 된다. def runJob[T, U: ClassTag](rdd: RDD[T], func: Iterator[T] =&gt; U): Array[U] = { runJob(rdd, func, 0 until rdd.partitions.length) } def runJob[T, U: ClassTag]( rdd: RDD[T], func: Iterator[T] =&gt; U, partitions: Seq[Int]): Array[U] = { val cleanedFunc = clean(func) runJob(rdd, (ctx: TaskContext, it: Iterator[T]) =&gt; cleanedFunc(it), partitions) } def runJob[T, U: ClassTag]( rdd: RDD[T], func: (TaskContext, Iterator[T]) =&gt; U, partitions: Seq[Int]): Array[U] = { val results = new Array[U](partitions.size) runJob[T, U](rdd, func, partitions, (index, res) =&gt; results(index) = res) results } def runJob[T, U: ClassTag]( rdd: RDD[T], func: (TaskContext, Iterator[T]) =&gt; U, partitions: Seq[Int], resultHandler: (Int, U) =&gt; Unit): Unit = { if (stopped.get()) { throw new IllegalStateException(&quot;SparkContext has been shutdown&quot;) } val callSite = getCallSite val cleanedFunc = clean(func) logInfo(&quot;Starting job: &quot; + callSite.shortForm) if (conf.getBoolean(&quot;spark.logLineage&quot;, false)) { logInfo(&quot;RDD&#39;s recursive dependencies:\n&quot; + rdd.toDebugString) } dagScheduler.runJob(rdd, cleanedFunc, partitions, callSite, resultHandler, localProperties.get) progressBar.foreach(_.finishAll()) rdd.doCheckpoint() } 대부분의 runJob의 매개변수의 구성은 아래와 같다. rdd: Action을 호출하는 RDD이다. func: rdd의 각 파티션에 적용할 함수이다. partitions: rdd를 구성하는 Partition의 Sequence 다른 코드(Clousure를 닫아주는 clean 등)들은 부가적인 부분이고 실제 Job을 수행하는 부분은 dagScheduler의 runJob 함수 호출이다. DagScheduler의 동작(1) count(), show(), save() 등과 같은 Action을 호출하게 되면, DagScheduler에서 RDD를 Job으로 변환하여 실제 연산을 수행하게 된다. SparkContext에서 호출한 DagScheduler의 runJob의 코드는 아래와 같다. def runJob[T, U]( rdd: RDD[T], func: (TaskContext, Iterator[T]) =&gt; U, partitions: Seq[Int], callSite: CallSite, resultHandler: (Int, U) =&gt; Unit, properties: Properties): Unit = { val start = System.nanoTime val waiter = submitJob(rdd, func, partitions, callSite, resultHandler, properties) ThreadUtils.awaitReady(waiter.completionFuture, Duration.Inf) waiter.completionFuture.value.get match { case scala.util.Success(_) =&gt; logInfo(&quot;Job %d finished: %s, took %f s&quot;.format (waiter.jobId, callSite.shortForm, (System.nanoTime - start) / 1e9)) case scala.util.Failure(exception) =&gt; logInfo(&quot;Job %d failed: %s, took %f s&quot;.format (waiter.jobId, callSite.shortForm, (System.nanoTime - start) / 1e9)) // SPARK-8644: Include user stack trace in exceptions coming from DAGScheduler. val callerStackTrace = Thread.currentThread().getStackTrace.tail exception.setStackTrace(exception.getStackTrace ++ callerStackTrace) throw exception } } 실제 Job을 submit하고 기다리는 부분은 아래 코드이다. val waiter = submitJob(rdd, func, partitions, callSite, resultHandler, properties) 다시 submitJob 코드를 확인해보면 다음과 같다. def submitJob[T, U]( rdd: RDD[T], func: (TaskContext, Iterator[T]) =&gt; U, partitions: Seq[Int], callSite: CallSite, resultHandler: (Int, U) =&gt; Unit, properties: Properties): JobWaiter[U] = { // Check to make sure we are not launching a task on a partition that does not exist. val maxPartitions = rdd.partitions.length partitions.find(p =&gt; p &gt;= maxPartitions || p &lt; 0).foreach { p =&gt; throw new IllegalArgumentException( &quot;Attempting to access a non-existent partition: &quot; + p + &quot;. &quot; + &quot;Total number of partitions: &quot; + maxPartitions) } val jobId = nextJobId.getAndIncrement() if (partitions.isEmpty) { val time = clock.getTimeMillis() listenerBus.post( SparkListenerJobStart(jobId, time, Seq[StageInfo](), properties)) listenerBus.post( SparkListenerJobEnd(jobId, time, JobSucceeded)) // Return immediately if the job is running 0 tasks return new JobWaiter[U](this, jobId, 0, resultHandler) } assert(partitions.nonEmpty) val func2 = func.asInstanceOf[(TaskContext, Iterator[_]) =&gt; _] val waiter = new JobWaiter[U](this, jobId, partitions.size, resultHandler) eventProcessLoop.post(JobSubmitted( jobId, rdd, func2, partitions.toArray, callSite, waiter, SerializationUtils.clone(properties))) waiter } 코드의 윗부분들은 Partition이 없는 경우 등 특수한 상황을 처리하는 부분이고, 우리가 실제로 눈여겨보아야 할 부분은 아래의 코드이다. val func2 = func.asInstanceOf[(TaskContext, Iterator[_]) =&gt; _] val waiter = new JobWaiter[U](this, jobId, partitions.size, resultHandler) eventProcessLoop.post(JobSubmitted( jobId, rdd, func2, partitions.toArray, callSite, waiter, SerializationUtils.clone(properties))) waiter EventLoop 타입인 eventProcessLoop 객체의 post 함수 호출을 통해 실제 작업을 호출하게 된다. EventLoop와 DAGSchedulerEventProcessLoop EventLoop Job을 수행하는 Action 연산이나 Job을 종료하는 Job Cancel이 호출될 경우 이러한 작업을 처리하는 Thread를 만들어 수행하는 추상 클래스이며, DagSchedulerEventProcessLoop는 EventLoop를 상속한 구체 클래스이다. 위의 DagScheduler에서 post를 호출하게 되면 EventLoop의 eventQueue에 작업을 넣는다. def post(event: E): Unit = { if (!stopped.get) { if (eventThread.isAlive) { eventQueue.put(event) } else { onError(new IllegalStateException(s&quot;$name has already been stopped accidentally.&quot;)) } } } EventLoop는 무한루프를 돌며 EventQueue에서 작업을 꺼내 onReceive 함수를 호출한다. override def run(): Unit = { try { while (!stopped.get) { val event = eventQueue.take() try { onReceive(event) } catch { case NonFatal(e) =&gt; try { onError(e) } catch { case NonFatal(e) =&gt; logError(&quot;Unexpected error in &quot; + name, e) } } } } catch { case ie: InterruptedException =&gt; // exit even if eventQueue is not empty case NonFatal(e) =&gt; logError(&quot;Unexpected error in &quot; + name, e) } } onReceive 함수는 EventLoop 클래스의 구현체인 DagSchedulerEventProcessLoop의 onReceive에 구현되어 있다. override def onReceive(event: DAGSchedulerEvent): Unit = { val timerContext = timer.time() try { doOnReceive(event) } finally { timerContext.stop() } } onReceive의 내부에서는 다시 doOnReceive 함수를 호출하게 된다. doOnReceive 함수에서는 매개변수로 전달받은 Event를 패턴매칭을 통해 걸러내고 DagScheduler의 handle 함수에게 넘기게 된다. private def doOnReceive(event: DAGSchedulerEvent): Unit = event match { case JobSubmitted(jobId, rdd, func, partitions, callSite, listener, properties) =&gt; dagScheduler.handleJobSubmitted(jobId, rdd, func, partitions, callSite, listener, properties) case MapStageSubmitted(jobId, dependency, callSite, listener, properties) =&gt; dagScheduler.handleMapStageSubmitted(jobId, dependency, callSite, listener, properties) case StageCancelled(stageId, reason) =&gt; dagScheduler.handleStageCancellation(stageId, reason) case JobCancelled(jobId, reason) =&gt; dagScheduler.handleJobCancellation(jobId, reason) ...생략 우리가 DagScheduler에서 호출한 submitJob 코드를 보면 아래와 같았다. eventProcessLoop.post(JobSubmitted( jobId, rdd, func2, partitions.toArray, callSite, waiter, SerializationUtils.clone(properties))) JobSumitted 타입의 객체를 전달했기 때문에 case문의 첫번째에 걸려 DagScheduler의 handleJobSubmitted를 호출한다. case JobSubmitted(jobId, rdd, func, partitions, callSite, listener, properties) =&gt; dagScheduler.handleJobSubmitted(jobId, rdd, func, partitions, callSite, listener, properties) handleJobSubmitted 함수가 워낙 길어 필요한 부분만 간추리면 아래와 같이 볼 수 있다. private[scheduler] def handleJobSubmitted(jobId: Int, finalRDD: RDD[_], func: (TaskContext, Iterator[_]) =&gt; _, partitions: Array[Int], callSite: CallSite, listener: JobListener, properties: Properties) { var finalStage: ResultStage = null try { // New stage creation may throw an exception if, for example, jobs are run on a // HadoopRDD whose underlying HDFS files have been deleted. finalStage = createResultStage(finalRDD, func, partitions, jobId, callSite) } catch { ...생략 } // Job submitted, clear internal data. barrierJobIdToNumTasksCheckFailures.remove(jobId) val job = new ActiveJob(jobId, finalStage, callSite, listener, properties) clearCacheLocs() ...생략 jobIdToActiveJob(jobId) = job activeJobs += job finalStage.setActiveJob(job) val stageIds = jobIdToStageIds(jobId).toArray val stageInfos = stageIds.flatMap(id =&gt; stageIdToStage.get(id).map(_.latestInfo)) listenerBus.post( SparkListenerJobStart(job.jobId, jobSubmissionTime, stageInfos, properties)) submitStage(finalStage) } createResultStage 함수를 호출하여 Action 연산을 호출한 RDD를 통해 ResultStage를 생성하고 이를 submitStage 함수를 통해 다시 DagSchedulerEventProcessLoop에게 전달한다. Stage의 정의와 종류 Stage는 동일한 Shuffle Dependency를 가진 Task들의 집합이다(즉, Shuffle이 Stage를 나누는 기준이 된다). Stage를 구성하는 Task들은 Narrow Dependency를 통해 연결되어 있으며, 병렬로 실행될 수 있다. Stage는 ShuffleMapStage와 ResultStage로 나뉘어진다. ShuffleMapStage: Task들의 결과가 다른 Stage의 Input으로 들어가는 Stage ResultStage: Action의 결과를 출력하기 위해 동작하는 Stage 즉, 1개의 Spark Job은 1개 이상의 ShuffleMapStage와 1개의 ResultStage로 구성된다고 볼 수 있다. DagScheduler의 동작(2) createResultStage 함수의 코드는 아래와 같다. private def createResultStage( rdd: RDD[_], func: (TaskContext, Iterator[_]) =&gt; _, partitions: Array[Int], jobId: Int, callSite: CallSite): ResultStage = { checkBarrierStageWithDynamicAllocation(rdd) checkBarrierStageWithNumSlots(rdd) checkBarrierStageWithRDDChainPattern(rdd, partitions.toSet.size) val parents = getOrCreateParentStages(rdd, jobId) val id = nextStageId.getAndIncrement() val stage = new ResultStage(id, rdd, func, partitions, parents, jobId, callSite) stageIdToStage(id) = stage updateJobIdStageIdMaps(jobId, stage) stage } getOrCreateParentStages 라는 함수를 통해 ResultStage 를 생성하는 이전 Stage를 가져온다. 여기서 우리가 처음 호출했던 코드를 다시 확인해보자. val parallelizedRDD = sc.parallelize(Seq(1,2,3,4,5,6,7,8,9,10), 2) val transformedRDD = parallelizedRDD.map(_ + &quot;th value&quot;) transformedRDD.count() parallelize와 map으로만 구성된 RDD이기 때문에 Shuffle이 존재하지 않고, 결과적으로 이 코드는 1개의 Stage로만 이루어져 있다. 따라서 위의 getOrCreateParentStages 함수는 null을 반환하게 된다. 따라서 createResultStage에서는 1개의 ResultStage만 반환하게 된다. 생성된 Stage는 handleJobSubmitted의 submitStage 함수를 통해 처리된다. private[scheduler] def handleJobSubmitted(jobId: Int, finalRDD: RDD[_], func: (TaskContext, Iterator[_]) =&gt; _, partitions: Array[Int], callSite: CallSite, listener: JobListener, properties: Properties) { var finalStage: ResultStage = null try { // New stage creation may throw an exception if, for example, jobs are run on a // HadoopRDD whose underlying HDFS files have been deleted. finalStage = createResultStage(finalRDD, func, partitions, jobId, callSite) } catch { ...생략 } ...생략 submitStage(finalStage) } submitStage의 코드는 아래와 같다. private def submitStage(stage: Stage) { val jobId = activeJobForStage(stage) if (jobId.isDefined) { logDebug(&quot;submitStage(&quot; + stage + &quot;)&quot;) if (!waitingStages(stage) &amp;&amp; !runningStages(stage) &amp;&amp; !failedStages(stage)) { val missing = getMissingParentStages(stage).sortBy(_.id) logDebug(&quot;missing: &quot; + missing) if (missing.isEmpty) { logInfo(&quot;Submitting &quot; + stage + &quot; (&quot; + stage.rdd + &quot;), which has no missing parents&quot;) submitMissingTasks(stage, jobId.get) } else { for (parent &lt;- missing) { submitStage(parent) } waitingStages += stage } } } else { abortStage(stage, &quot;No active job for stage &quot; + stage.id, None) } } 일단 getMissingParentStages 함수를 통해 해당 Stage 이전에 실행되어야 하는 Stage를 찾아내고 실행한다. 이 예제에서는 이전에 실행되어야 하는 Stage가 존재하지 않으므로 submitMissingTasks 함수가 실행된다. submitMissingTasks 함수는 워낙 길어서 필요한 부분만 잘라보았는데, 중요한 부분은 아래와 같다. val tasks: Seq[Task[_]] = try { val serializedTaskMetrics = closureSerializer.serialize(stage.latestInfo.taskMetrics).array() stage match { case stage: ShuffleMapStage =&gt; stage.pendingPartitions.clear() partitionsToCompute.map { id =&gt; val locs = taskIdToLocations(id) val part = partitions(id) stage.pendingPartitions += id new ShuffleMapTask(stage.id, stage.latestInfo.attemptNumber, taskBinary, part, locs, properties, serializedTaskMetrics, Option(jobId), Option(sc.applicationId), sc.applicationAttemptId, stage.rdd.isBarrier()) } case stage: ResultStage =&gt; partitionsToCompute.map { id =&gt; val p: Int = stage.partitions(id) val part = partitions(p) val locs = taskIdToLocations(id) new ResultTask(stage.id, stage.latestInfo.attemptNumber, taskBinary, part, locs, id, properties, serializedTaskMetrics, Option(jobId), Option(sc.applicationId), sc.applicationAttemptId, stage.rdd.isBarrier()) } } } catch { case NonFatal(e) =&gt; abortStage(stage, s&quot;Task creation failed: $e\n${Utils.exceptionString(e)}&quot;, Some(e)) runningStages -= stage return } 위의 코드는 Stage를 Task로 분리하여 TaskSet 형태로 만드는 과정이다. Task는 1개의 Partition을 연산하는 작업을 의미하며, TaskSet은 1개 이상의 Task로 구성된 개념으로 사실상 Stage와 동일하다고 생각하면 될 것 같다. Task는 Stage의 종류에 따라 ShuffleMapStage일 경우 ShuffleMapTask, ResultStage일 경우 ResultTask로 구분되어 생성된다. 이렇게 생성된 TaskSet은 TaskScheduler의 submitTasks 함수에 전달되어 실행된다. taskScheduler.submitTasks(new TaskSet( tasks.toArray, stage.id, stage.latestInfo.attemptNumber, jobId, properties)) TaskScheduler의 구현체인 TaskSchedulerImpl의 submitTasks 에서는 다시 SchedulerBackend의 구현체인 CoarseGrainedSchedulerBackend의 receiveOffers를 호출하게 된다. 사실 이 부분에서 receiveOffers의 인자로 넘기는게 없는데, 실행시킬 수 있다는게 이해가 가지 않는다. 다만 CoarseGrainedSchedulerBackend에서 TaskSchedulerImpl 객체를 내부 변수로 가지고 있기 때문에 TaskScehdulerImpl의 내부 변수를 참조하여 실행시키는 것이 아닌가 하는 추측으로 진행을 했다. SchedulerBackend(CoarseGrainedSchedulerBackend)의 동작 SchedulerBackend의 구현체인 CoarseGrainedSchedulerBackend의 receiveOffer는 다시 DriverEndpoint 객체의 send 함수를 호출하여 실행을 요청한다. DriverEndpoint의 receive 함수에서는 ReceiveOffer 이벤트를 수신하여 makeOffers 함수를 수행한다. case ReviveOffers =&gt; makeOffers() makeOffers 함수에서는 실행할 Task의 정보를 받아와 launchTask 함수를 통해 실제 Task 실행을 수행한다. private def makeOffers() { // Make sure no executor is killed while some task is launching on it val taskDescs = withLock { // Filter out executors under killing val activeExecutors = executorDataMap.filterKeys(executorIsAlive) val workOffers = activeExecutors.map { case (id, executorData) =&gt; new WorkerOffer(id, executorData.executorHost, executorData.freeCores, Some(executorData.executorAddress.hostPort), executorData.resourcesInfo.map { case (rName, rInfo) =&gt; (rName, rInfo.availableAddrs.toBuffer)} ) }.toIndexedSeq scheduler.resourceOffers(workOffers) } if (taskDescs.nonEmpty) { launchTasks(taskDescs) } } 위 함수에서 아마 TaskScheduler에서 만든 TaskSet을 받아 처리하는 것 같은데, 어디서 데이터를 가져오는지는 잘 모르겠다. 아마 executorDataMap일 것 같은데.. 좀 더 살펴봐야 할 것 같다. 대망의 launchTask 함수이다. TaskSet을 구성하는 Task들을 Serialization하여 각 Executor에게 실행을 요청한다. private def launchTasks(tasks: Seq[Seq[TaskDescription]]) { for (task &lt;- tasks.flatten) { val serializedTask = TaskDescription.encode(task) if (serializedTask.limit() &gt;= maxRpcMessageSize) { Option(scheduler.taskIdToTaskSetManager.get(task.taskId)).foreach { taskSetMgr =&gt; try { var msg = &quot;Serialized task %s:%d was %d bytes, which exceeds max allowed: &quot; + s&quot;${RPC_MESSAGE_MAX_SIZE.key} (%d bytes). Consider increasing &quot; + s&quot;${RPC_MESSAGE_MAX_SIZE.key} or using broadcast variables for large values.&quot; msg = msg.format(task.taskId, task.index, serializedTask.limit(), maxRpcMessageSize) taskSetMgr.abort(msg) } catch { case e: Exception =&gt; logError(&quot;Exception in error callback&quot;, e) } } } else { val executorData = executorDataMap(task.executorId) // Do resources allocation here. The allocated resources will get released after the task // finishes. executorData.freeCores -= scheduler.CPUS_PER_TASK task.resources.foreach { case (rName, rInfo) =&gt; assert(executorData.resourcesInfo.contains(rName)) executorData.resourcesInfo(rName).acquire(rInfo.addresses) } logDebug(s&quot;Launching task ${task.taskId} on executor id: ${task.executorId} hostname: &quot; + s&quot;${executorData.executorHost}.&quot;) executorData.executorEndpoint.send(LaunchTask(new SerializableBuffer(serializedTask))) } } } 여기까지가 Driver 단에서 RDD의 Action을 수행한 후 Task의 실행을 Executor에게 Launch하도록 요청하는 과정이다. 3줄짜리 코드를 실행하기 위해 이렇게 많은 구성요소들이 결합하여 동작하는줄 모르고 있었고, 생각보다 실행이 매우 복잡하다는 것을 느낄 수 있었다." />
<link rel="canonical" href="http://localhost:4000/2019-07-21/how-rdd-count-works" />
<meta property="og:url" content="http://localhost:4000/2019-07-21/how-rdd-count-works" />
<meta property="og:site_name" content="leeyh0216’s devlog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-07-21T21:00:00+09:00" />
<script type="application/ld+json">
{"headline":"Spark RDD의 count()는 어떻게 동작하는가?(Shuffle이 없는, Driver 편)","dateModified":"2019-07-21T21:00:00+09:00","datePublished":"2019-07-21T21:00:00+09:00","url":"http://localhost:4000/2019-07-21/how-rdd-count-works","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2019-07-21/how-rdd-count-works"},"author":{"@type":"Person","name":"leeyh0216"},"description":"Spark RDD의 count()는 어떻게 동작하는가?(Shuffle이 없는, Driver 편) Spark RDD의 기본 연산 중 하나인 count()가 어떻게 동작하는지 알아보도록 한다. Shuffle이 들어가면 분석이 너무 어렵기 때문에 Shuffle이 발생하지 않는 코드로만 추적해보았으며, 이번 글에서는 Driver에서 발생하는 과정만을 다룬다. Shuffle이 없는 count() Spark 코드를 확인해보면 Shuffle이 존재하는 연산보다 Shuffle이 존재하지 않는 연산이 훨씬 쉽고, 읽어야 할 코드의 양이 적기 때문에 Shuffle이 존재하지 않는 RDD의 count()부터 알아보기로 한다. 아래와 같이 한 번의 map으로 이루어진 RDD의 count()가 어떻게 동작하는지 알아본다. val parallelizedRDD = sc.parallelize(Seq(1,2,3,4,5,6,7,8,9,10), 2) val transformedRDD = parallelizedRDD.map(_ + &quot;th value&quot;) transformedRDD.count() val parallelizedRDD = sc.parallelize(Seq(1,2,3,4,5,6,7,8,9,10), 2) SparkContext 클래스에 있는 parallelize는 Caller(Driver)에 존재하는 Scala Collection을 RDD로 만드는 함수이다. 반환 타입은 ParallelCollectionRDD이다. def parallelize[T: ClassTag]( seq: Seq[T], numSlices: Int = defaultParallelism): RDD[T] = withScope { assertNotStopped() new ParallelCollectionRDD[T](this, seq, numSlices, Map[Int, Seq[String]]() } ParallelCollectionRDD는 RDD클래스를 상속하는데, 생성자를 눈여겨 보아야 한다. private[spark] class ParallelCollectionRDD[T: ClassTag]( sc: SparkContext, @transient private val data: Seq[T], numSlices: Int, locationPrefs: Map[Int, Seq[String]]) extends RDD[T](sc, Nil) { 위 코드에서 호출하고 있는 부모 클래스 RDD의 생성자 코드는 아래와 같다. abstract class RDD[T: ClassTag]( @transient private var _sc: SparkContext, @transient private var deps: Seq[Dependency[_]] ) extends Serializable with Logging { parallelize 함수를 통해 생성되는 RDD는 부모 RDD가 존재하지 않기 때문에 Dependency가 존재하지 않아 RDD의 Dependency가 null로 만들어진다. 그리고 RDD에서 중요한 요소 중 하나인 Partition이 어떻게 생성되는지 확인해보도록 한다. 아래 코드는 ParallelCollectionRDD 클래스의 getPartitions 함수이다. override def getPartitions: Array[Partition] = { val slices = ParallelCollectionRDD.slice(data, numSlices).toArray slices.indices.map(i =&gt; new ParallelCollectionPartition(id, i, slices(i))).toArray } parallelize 함수의 인자인 data를 numSlices개로 잘라서 ParallelCollectionPartition으로 만든다. 아래 코드를 실행해보면 생성된 파티션의 정보를 확인할 수 있다. val parallelizedRDD = sc.parallelize(Seq(1,2,3,4,5,6,7,8,9,10), 2) parallelizedRDD.partitions.map(_.asInstanceOf[ParallelCollectionPartition[Int]]).foreach(p =&gt; println(s&quot;RDD: ${p.rddId}, Partition: ${p.index}, Values: ${p.values.mkString(&quot;,&quot;)}&quot;)) 출력 결과: RDD: 0, Partition: 0, Values: 1,2,3,4,5 RDD: 0, Partition: 1, Values: 6,7,8,9,10 RDD의 ID RDD의 ID는 RDD 객체 생성 시 SparkContext의 newRddId 함수를 호출하여 생성한다. 즉, RDD의 ID는 SparkContext 내에서 유일한 값이다. RDD 클래스의 id 필드 /** A unique ID for this RDD (within its SparkContext). */ val id: Int = sc.newRddId() SparkContext 클래스의 newRddId 함수 /** Register a new RDD, returning its RDD ID */ private[spark] def newRddId(): Int = nextRddId.getAndIncrement() val transformedRDD = parallelizedRDD.map(_ + “th value”) parallelize 함수를 통해 생성된 RDD에 map 함수를 적용하여 내부 값들을 변환하는 동작이다. map T 타입(원본 RDD의 요소 타입)을 U 타입으로 변환하는 함수를 인자로 받고, MapPartitionsRDD 타입의 객체를 반환하는 함수이다. MapPartitionsRDD 클래스의 생성자는 다음과 같다. private[spark] class MapPartitionsRDD[U: ClassTag, T: ClassTag]( var prev: RDD[T], f: (TaskContext, Int, Iterator[T]) =&gt; Iterator[U], // (TaskContext, partition index, iterator) preservesPartitioning: Boolean = false, isFromBarrier: Boolean = false, isOrderSensitive: Boolean = false) extends RDD[U](prev) { 이 떄 주의깊게 보아야 할 점은 RDD의 생성자에 Caller RDD(예시에서는 ParallelizedRDD)를 넘기고 있다. 해당 생성자의 코드는 아래와 같다. /** Construct an RDD with just a one-to-one dependency on one parent */ def this(@transient oneParent: RDD[_]) = this(oneParent.context, List(new OneToOneDependency(oneParent))) 아까와 달리 Dependency에 null이 아닌 OneToOneDependency를 넣어주고 있다. map은 NarrowDependency, 즉 Shuffle이 발생하지 않는 Transformation 연산이기 때문에 이전 RDD의 파티션과 새로 생성되는 RDD의 파티션이 1:1 관계를 가지게 되어 있다. OneToOneDependency Parent RDD와 Child RDD가 1:1 관계를 가지는 것을 표현하는 클래스이다. /** * :: DeveloperApi :: * Represents a one-to-one dependency between partitions of the parent and child RDDs. */ @DeveloperApi class OneToOneDependency[T](rdd: RDD[T]) extends NarrowDependency[T](rdd) { override def getParents(partitionId: Int): List[Int] = List(partitionId) } parallelizedRDD와 transformedRDD의 관계는 OneToOneDependency를 이용하여 아래와 같이 표현할 수 있다. Parent(parallelizedRDD) &lt;— OneToOneDependency —&gt; Child(transformedRDD) transformedRDD의 Partition 구성 transformedRDD의 파티션은 어떤 형태를 가지고 있을까? transformedRDD의 getPartitions 함수는 다음과 같다. override def getPartitions: Array[Partition] = firstParent[T].partitions 부모 파티션의 Partition을 그대로 반환하게 되어 있다. map 과정에서 Shuffle이 발생하지 않기 때문에 RDD의 관계와 같이 Partition의 관계도 부모와 자식이 1:1로 유지되는 것을 알 수 있다. 코드를 통해 실제로도 동일한 파티션인지 확인해본다. 실제 값을 출력하는 방법과 객체를 비교하는 방법으로 검증해보았다. 실제 값을 출력하는 방법(위의 parallelizedRDD에 대해 호출한 출력값과 동일해야 함) transformedRDD.partitions.map(_.asInstanceOf[ParallelCollectionPartition[Int]]).foreach(p =&gt; println(s&quot;RDD: ${p.rddId}, Partition: ${p.index}, Values: ${p.values.mkString(&quot;,&quot;)}&quot;)) 출력 결과: RDD: 0, Partition: 0, Values: 1,2,3,4,5 RDD: 0, Partition: 1, Values: 6,7,8,9,10 partitions 객체가 동일한지 확인하는 방법 assert(parallelizedRDD.partitions === transformedRDD.partitions) transformedRDD.count() count()은 Action으로써 실제로 작업이 실행되는 함수이다. count의 코드는 아래와 같다. def count(): Long = sc.runJob(this, Utils.getIteratorSize _).sum SparkContext 객체의 runJob 함수를 호출한다. 호출되는 runJob은 내부적으로 다시 오버로딩 된 runJob 함수들을 호출하게 된다. def runJob[T, U: ClassTag](rdd: RDD[T], func: Iterator[T] =&gt; U): Array[U] = { runJob(rdd, func, 0 until rdd.partitions.length) } def runJob[T, U: ClassTag]( rdd: RDD[T], func: Iterator[T] =&gt; U, partitions: Seq[Int]): Array[U] = { val cleanedFunc = clean(func) runJob(rdd, (ctx: TaskContext, it: Iterator[T]) =&gt; cleanedFunc(it), partitions) } def runJob[T, U: ClassTag]( rdd: RDD[T], func: (TaskContext, Iterator[T]) =&gt; U, partitions: Seq[Int]): Array[U] = { val results = new Array[U](partitions.size) runJob[T, U](rdd, func, partitions, (index, res) =&gt; results(index) = res) results } def runJob[T, U: ClassTag]( rdd: RDD[T], func: (TaskContext, Iterator[T]) =&gt; U, partitions: Seq[Int], resultHandler: (Int, U) =&gt; Unit): Unit = { if (stopped.get()) { throw new IllegalStateException(&quot;SparkContext has been shutdown&quot;) } val callSite = getCallSite val cleanedFunc = clean(func) logInfo(&quot;Starting job: &quot; + callSite.shortForm) if (conf.getBoolean(&quot;spark.logLineage&quot;, false)) { logInfo(&quot;RDD&#39;s recursive dependencies:\\n&quot; + rdd.toDebugString) } dagScheduler.runJob(rdd, cleanedFunc, partitions, callSite, resultHandler, localProperties.get) progressBar.foreach(_.finishAll()) rdd.doCheckpoint() } 대부분의 runJob의 매개변수의 구성은 아래와 같다. rdd: Action을 호출하는 RDD이다. func: rdd의 각 파티션에 적용할 함수이다. partitions: rdd를 구성하는 Partition의 Sequence 다른 코드(Clousure를 닫아주는 clean 등)들은 부가적인 부분이고 실제 Job을 수행하는 부분은 dagScheduler의 runJob 함수 호출이다. DagScheduler의 동작(1) count(), show(), save() 등과 같은 Action을 호출하게 되면, DagScheduler에서 RDD를 Job으로 변환하여 실제 연산을 수행하게 된다. SparkContext에서 호출한 DagScheduler의 runJob의 코드는 아래와 같다. def runJob[T, U]( rdd: RDD[T], func: (TaskContext, Iterator[T]) =&gt; U, partitions: Seq[Int], callSite: CallSite, resultHandler: (Int, U) =&gt; Unit, properties: Properties): Unit = { val start = System.nanoTime val waiter = submitJob(rdd, func, partitions, callSite, resultHandler, properties) ThreadUtils.awaitReady(waiter.completionFuture, Duration.Inf) waiter.completionFuture.value.get match { case scala.util.Success(_) =&gt; logInfo(&quot;Job %d finished: %s, took %f s&quot;.format (waiter.jobId, callSite.shortForm, (System.nanoTime - start) / 1e9)) case scala.util.Failure(exception) =&gt; logInfo(&quot;Job %d failed: %s, took %f s&quot;.format (waiter.jobId, callSite.shortForm, (System.nanoTime - start) / 1e9)) // SPARK-8644: Include user stack trace in exceptions coming from DAGScheduler. val callerStackTrace = Thread.currentThread().getStackTrace.tail exception.setStackTrace(exception.getStackTrace ++ callerStackTrace) throw exception } } 실제 Job을 submit하고 기다리는 부분은 아래 코드이다. val waiter = submitJob(rdd, func, partitions, callSite, resultHandler, properties) 다시 submitJob 코드를 확인해보면 다음과 같다. def submitJob[T, U]( rdd: RDD[T], func: (TaskContext, Iterator[T]) =&gt; U, partitions: Seq[Int], callSite: CallSite, resultHandler: (Int, U) =&gt; Unit, properties: Properties): JobWaiter[U] = { // Check to make sure we are not launching a task on a partition that does not exist. val maxPartitions = rdd.partitions.length partitions.find(p =&gt; p &gt;= maxPartitions || p &lt; 0).foreach { p =&gt; throw new IllegalArgumentException( &quot;Attempting to access a non-existent partition: &quot; + p + &quot;. &quot; + &quot;Total number of partitions: &quot; + maxPartitions) } val jobId = nextJobId.getAndIncrement() if (partitions.isEmpty) { val time = clock.getTimeMillis() listenerBus.post( SparkListenerJobStart(jobId, time, Seq[StageInfo](), properties)) listenerBus.post( SparkListenerJobEnd(jobId, time, JobSucceeded)) // Return immediately if the job is running 0 tasks return new JobWaiter[U](this, jobId, 0, resultHandler) } assert(partitions.nonEmpty) val func2 = func.asInstanceOf[(TaskContext, Iterator[_]) =&gt; _] val waiter = new JobWaiter[U](this, jobId, partitions.size, resultHandler) eventProcessLoop.post(JobSubmitted( jobId, rdd, func2, partitions.toArray, callSite, waiter, SerializationUtils.clone(properties))) waiter } 코드의 윗부분들은 Partition이 없는 경우 등 특수한 상황을 처리하는 부분이고, 우리가 실제로 눈여겨보아야 할 부분은 아래의 코드이다. val func2 = func.asInstanceOf[(TaskContext, Iterator[_]) =&gt; _] val waiter = new JobWaiter[U](this, jobId, partitions.size, resultHandler) eventProcessLoop.post(JobSubmitted( jobId, rdd, func2, partitions.toArray, callSite, waiter, SerializationUtils.clone(properties))) waiter EventLoop 타입인 eventProcessLoop 객체의 post 함수 호출을 통해 실제 작업을 호출하게 된다. EventLoop와 DAGSchedulerEventProcessLoop EventLoop Job을 수행하는 Action 연산이나 Job을 종료하는 Job Cancel이 호출될 경우 이러한 작업을 처리하는 Thread를 만들어 수행하는 추상 클래스이며, DagSchedulerEventProcessLoop는 EventLoop를 상속한 구체 클래스이다. 위의 DagScheduler에서 post를 호출하게 되면 EventLoop의 eventQueue에 작업을 넣는다. def post(event: E): Unit = { if (!stopped.get) { if (eventThread.isAlive) { eventQueue.put(event) } else { onError(new IllegalStateException(s&quot;$name has already been stopped accidentally.&quot;)) } } } EventLoop는 무한루프를 돌며 EventQueue에서 작업을 꺼내 onReceive 함수를 호출한다. override def run(): Unit = { try { while (!stopped.get) { val event = eventQueue.take() try { onReceive(event) } catch { case NonFatal(e) =&gt; try { onError(e) } catch { case NonFatal(e) =&gt; logError(&quot;Unexpected error in &quot; + name, e) } } } } catch { case ie: InterruptedException =&gt; // exit even if eventQueue is not empty case NonFatal(e) =&gt; logError(&quot;Unexpected error in &quot; + name, e) } } onReceive 함수는 EventLoop 클래스의 구현체인 DagSchedulerEventProcessLoop의 onReceive에 구현되어 있다. override def onReceive(event: DAGSchedulerEvent): Unit = { val timerContext = timer.time() try { doOnReceive(event) } finally { timerContext.stop() } } onReceive의 내부에서는 다시 doOnReceive 함수를 호출하게 된다. doOnReceive 함수에서는 매개변수로 전달받은 Event를 패턴매칭을 통해 걸러내고 DagScheduler의 handle 함수에게 넘기게 된다. private def doOnReceive(event: DAGSchedulerEvent): Unit = event match { case JobSubmitted(jobId, rdd, func, partitions, callSite, listener, properties) =&gt; dagScheduler.handleJobSubmitted(jobId, rdd, func, partitions, callSite, listener, properties) case MapStageSubmitted(jobId, dependency, callSite, listener, properties) =&gt; dagScheduler.handleMapStageSubmitted(jobId, dependency, callSite, listener, properties) case StageCancelled(stageId, reason) =&gt; dagScheduler.handleStageCancellation(stageId, reason) case JobCancelled(jobId, reason) =&gt; dagScheduler.handleJobCancellation(jobId, reason) ...생략 우리가 DagScheduler에서 호출한 submitJob 코드를 보면 아래와 같았다. eventProcessLoop.post(JobSubmitted( jobId, rdd, func2, partitions.toArray, callSite, waiter, SerializationUtils.clone(properties))) JobSumitted 타입의 객체를 전달했기 때문에 case문의 첫번째에 걸려 DagScheduler의 handleJobSubmitted를 호출한다. case JobSubmitted(jobId, rdd, func, partitions, callSite, listener, properties) =&gt; dagScheduler.handleJobSubmitted(jobId, rdd, func, partitions, callSite, listener, properties) handleJobSubmitted 함수가 워낙 길어 필요한 부분만 간추리면 아래와 같이 볼 수 있다. private[scheduler] def handleJobSubmitted(jobId: Int, finalRDD: RDD[_], func: (TaskContext, Iterator[_]) =&gt; _, partitions: Array[Int], callSite: CallSite, listener: JobListener, properties: Properties) { var finalStage: ResultStage = null try { // New stage creation may throw an exception if, for example, jobs are run on a // HadoopRDD whose underlying HDFS files have been deleted. finalStage = createResultStage(finalRDD, func, partitions, jobId, callSite) } catch { ...생략 } // Job submitted, clear internal data. barrierJobIdToNumTasksCheckFailures.remove(jobId) val job = new ActiveJob(jobId, finalStage, callSite, listener, properties) clearCacheLocs() ...생략 jobIdToActiveJob(jobId) = job activeJobs += job finalStage.setActiveJob(job) val stageIds = jobIdToStageIds(jobId).toArray val stageInfos = stageIds.flatMap(id =&gt; stageIdToStage.get(id).map(_.latestInfo)) listenerBus.post( SparkListenerJobStart(job.jobId, jobSubmissionTime, stageInfos, properties)) submitStage(finalStage) } createResultStage 함수를 호출하여 Action 연산을 호출한 RDD를 통해 ResultStage를 생성하고 이를 submitStage 함수를 통해 다시 DagSchedulerEventProcessLoop에게 전달한다. Stage의 정의와 종류 Stage는 동일한 Shuffle Dependency를 가진 Task들의 집합이다(즉, Shuffle이 Stage를 나누는 기준이 된다). Stage를 구성하는 Task들은 Narrow Dependency를 통해 연결되어 있으며, 병렬로 실행될 수 있다. Stage는 ShuffleMapStage와 ResultStage로 나뉘어진다. ShuffleMapStage: Task들의 결과가 다른 Stage의 Input으로 들어가는 Stage ResultStage: Action의 결과를 출력하기 위해 동작하는 Stage 즉, 1개의 Spark Job은 1개 이상의 ShuffleMapStage와 1개의 ResultStage로 구성된다고 볼 수 있다. DagScheduler의 동작(2) createResultStage 함수의 코드는 아래와 같다. private def createResultStage( rdd: RDD[_], func: (TaskContext, Iterator[_]) =&gt; _, partitions: Array[Int], jobId: Int, callSite: CallSite): ResultStage = { checkBarrierStageWithDynamicAllocation(rdd) checkBarrierStageWithNumSlots(rdd) checkBarrierStageWithRDDChainPattern(rdd, partitions.toSet.size) val parents = getOrCreateParentStages(rdd, jobId) val id = nextStageId.getAndIncrement() val stage = new ResultStage(id, rdd, func, partitions, parents, jobId, callSite) stageIdToStage(id) = stage updateJobIdStageIdMaps(jobId, stage) stage } getOrCreateParentStages 라는 함수를 통해 ResultStage 를 생성하는 이전 Stage를 가져온다. 여기서 우리가 처음 호출했던 코드를 다시 확인해보자. val parallelizedRDD = sc.parallelize(Seq(1,2,3,4,5,6,7,8,9,10), 2) val transformedRDD = parallelizedRDD.map(_ + &quot;th value&quot;) transformedRDD.count() parallelize와 map으로만 구성된 RDD이기 때문에 Shuffle이 존재하지 않고, 결과적으로 이 코드는 1개의 Stage로만 이루어져 있다. 따라서 위의 getOrCreateParentStages 함수는 null을 반환하게 된다. 따라서 createResultStage에서는 1개의 ResultStage만 반환하게 된다. 생성된 Stage는 handleJobSubmitted의 submitStage 함수를 통해 처리된다. private[scheduler] def handleJobSubmitted(jobId: Int, finalRDD: RDD[_], func: (TaskContext, Iterator[_]) =&gt; _, partitions: Array[Int], callSite: CallSite, listener: JobListener, properties: Properties) { var finalStage: ResultStage = null try { // New stage creation may throw an exception if, for example, jobs are run on a // HadoopRDD whose underlying HDFS files have been deleted. finalStage = createResultStage(finalRDD, func, partitions, jobId, callSite) } catch { ...생략 } ...생략 submitStage(finalStage) } submitStage의 코드는 아래와 같다. private def submitStage(stage: Stage) { val jobId = activeJobForStage(stage) if (jobId.isDefined) { logDebug(&quot;submitStage(&quot; + stage + &quot;)&quot;) if (!waitingStages(stage) &amp;&amp; !runningStages(stage) &amp;&amp; !failedStages(stage)) { val missing = getMissingParentStages(stage).sortBy(_.id) logDebug(&quot;missing: &quot; + missing) if (missing.isEmpty) { logInfo(&quot;Submitting &quot; + stage + &quot; (&quot; + stage.rdd + &quot;), which has no missing parents&quot;) submitMissingTasks(stage, jobId.get) } else { for (parent &lt;- missing) { submitStage(parent) } waitingStages += stage } } } else { abortStage(stage, &quot;No active job for stage &quot; + stage.id, None) } } 일단 getMissingParentStages 함수를 통해 해당 Stage 이전에 실행되어야 하는 Stage를 찾아내고 실행한다. 이 예제에서는 이전에 실행되어야 하는 Stage가 존재하지 않으므로 submitMissingTasks 함수가 실행된다. submitMissingTasks 함수는 워낙 길어서 필요한 부분만 잘라보았는데, 중요한 부분은 아래와 같다. val tasks: Seq[Task[_]] = try { val serializedTaskMetrics = closureSerializer.serialize(stage.latestInfo.taskMetrics).array() stage match { case stage: ShuffleMapStage =&gt; stage.pendingPartitions.clear() partitionsToCompute.map { id =&gt; val locs = taskIdToLocations(id) val part = partitions(id) stage.pendingPartitions += id new ShuffleMapTask(stage.id, stage.latestInfo.attemptNumber, taskBinary, part, locs, properties, serializedTaskMetrics, Option(jobId), Option(sc.applicationId), sc.applicationAttemptId, stage.rdd.isBarrier()) } case stage: ResultStage =&gt; partitionsToCompute.map { id =&gt; val p: Int = stage.partitions(id) val part = partitions(p) val locs = taskIdToLocations(id) new ResultTask(stage.id, stage.latestInfo.attemptNumber, taskBinary, part, locs, id, properties, serializedTaskMetrics, Option(jobId), Option(sc.applicationId), sc.applicationAttemptId, stage.rdd.isBarrier()) } } } catch { case NonFatal(e) =&gt; abortStage(stage, s&quot;Task creation failed: $e\\n${Utils.exceptionString(e)}&quot;, Some(e)) runningStages -= stage return } 위의 코드는 Stage를 Task로 분리하여 TaskSet 형태로 만드는 과정이다. Task는 1개의 Partition을 연산하는 작업을 의미하며, TaskSet은 1개 이상의 Task로 구성된 개념으로 사실상 Stage와 동일하다고 생각하면 될 것 같다. Task는 Stage의 종류에 따라 ShuffleMapStage일 경우 ShuffleMapTask, ResultStage일 경우 ResultTask로 구분되어 생성된다. 이렇게 생성된 TaskSet은 TaskScheduler의 submitTasks 함수에 전달되어 실행된다. taskScheduler.submitTasks(new TaskSet( tasks.toArray, stage.id, stage.latestInfo.attemptNumber, jobId, properties)) TaskScheduler의 구현체인 TaskSchedulerImpl의 submitTasks 에서는 다시 SchedulerBackend의 구현체인 CoarseGrainedSchedulerBackend의 receiveOffers를 호출하게 된다. 사실 이 부분에서 receiveOffers의 인자로 넘기는게 없는데, 실행시킬 수 있다는게 이해가 가지 않는다. 다만 CoarseGrainedSchedulerBackend에서 TaskSchedulerImpl 객체를 내부 변수로 가지고 있기 때문에 TaskScehdulerImpl의 내부 변수를 참조하여 실행시키는 것이 아닌가 하는 추측으로 진행을 했다. SchedulerBackend(CoarseGrainedSchedulerBackend)의 동작 SchedulerBackend의 구현체인 CoarseGrainedSchedulerBackend의 receiveOffer는 다시 DriverEndpoint 객체의 send 함수를 호출하여 실행을 요청한다. DriverEndpoint의 receive 함수에서는 ReceiveOffer 이벤트를 수신하여 makeOffers 함수를 수행한다. case ReviveOffers =&gt; makeOffers() makeOffers 함수에서는 실행할 Task의 정보를 받아와 launchTask 함수를 통해 실제 Task 실행을 수행한다. private def makeOffers() { // Make sure no executor is killed while some task is launching on it val taskDescs = withLock { // Filter out executors under killing val activeExecutors = executorDataMap.filterKeys(executorIsAlive) val workOffers = activeExecutors.map { case (id, executorData) =&gt; new WorkerOffer(id, executorData.executorHost, executorData.freeCores, Some(executorData.executorAddress.hostPort), executorData.resourcesInfo.map { case (rName, rInfo) =&gt; (rName, rInfo.availableAddrs.toBuffer)} ) }.toIndexedSeq scheduler.resourceOffers(workOffers) } if (taskDescs.nonEmpty) { launchTasks(taskDescs) } } 위 함수에서 아마 TaskScheduler에서 만든 TaskSet을 받아 처리하는 것 같은데, 어디서 데이터를 가져오는지는 잘 모르겠다. 아마 executorDataMap일 것 같은데.. 좀 더 살펴봐야 할 것 같다. 대망의 launchTask 함수이다. TaskSet을 구성하는 Task들을 Serialization하여 각 Executor에게 실행을 요청한다. private def launchTasks(tasks: Seq[Seq[TaskDescription]]) { for (task &lt;- tasks.flatten) { val serializedTask = TaskDescription.encode(task) if (serializedTask.limit() &gt;= maxRpcMessageSize) { Option(scheduler.taskIdToTaskSetManager.get(task.taskId)).foreach { taskSetMgr =&gt; try { var msg = &quot;Serialized task %s:%d was %d bytes, which exceeds max allowed: &quot; + s&quot;${RPC_MESSAGE_MAX_SIZE.key} (%d bytes). Consider increasing &quot; + s&quot;${RPC_MESSAGE_MAX_SIZE.key} or using broadcast variables for large values.&quot; msg = msg.format(task.taskId, task.index, serializedTask.limit(), maxRpcMessageSize) taskSetMgr.abort(msg) } catch { case e: Exception =&gt; logError(&quot;Exception in error callback&quot;, e) } } } else { val executorData = executorDataMap(task.executorId) // Do resources allocation here. The allocated resources will get released after the task // finishes. executorData.freeCores -= scheduler.CPUS_PER_TASK task.resources.foreach { case (rName, rInfo) =&gt; assert(executorData.resourcesInfo.contains(rName)) executorData.resourcesInfo(rName).acquire(rInfo.addresses) } logDebug(s&quot;Launching task ${task.taskId} on executor id: ${task.executorId} hostname: &quot; + s&quot;${executorData.executorHost}.&quot;) executorData.executorEndpoint.send(LaunchTask(new SerializableBuffer(serializedTask))) } } } 여기까지가 Driver 단에서 RDD의 Action을 수행한 후 Task의 실행을 Executor에게 Launch하도록 요청하는 과정이다. 3줄짜리 코드를 실행하기 위해 이렇게 많은 구성요소들이 결합하여 동작하는줄 모르고 있었고, 생각보다 실행이 매우 복잡하다는 것을 느낄 수 있었다.","@type":"BlogPosting","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


  <!-- CSS -->
  <link rel="stylesheet" href="/assets/main.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">

  <!-- Favicon -->
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png">

  <!-- RSS -->
  <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="leeyh0216's devlog" />

  <!-- Google Analytics-->
  
</head>


  <body>

    <nav class="nav">
  <div class="nav-container">
    <a href="/">
      <h2 class="nav-title">leeyh0216's devlog</h2>
    </a>
    <ul>
      <li><a href="/about">About</a></li>
      <li><a href="/">Posts</a></li>
    </ul>
  </div>
</nav>


    <main>
      <div class="post">
  <div class="post-info">
    <span>Written by</span>
    
        leeyh0216
    

    
      <br>
      <span>on&nbsp;</span><time datetime="2019-07-21 21:00:00 +0900">July 21, 2019</time>
    
  </div>

  <h1 class="post-title">Spark RDD의 count()는 어떻게 동작하는가?(Shuffle이 없는, Driver 편)</h1>
  <div class="post-line"></div>

  <h1 id="spark-rdd의-count는-어떻게-동작하는가shuffle이-없는-driver-편">Spark RDD의 count()는 어떻게 동작하는가?(Shuffle이 없는, Driver 편)</h1>

<p>Spark RDD의 기본 연산 중 하나인 count()가 어떻게 동작하는지 알아보도록 한다.</p>

<p>Shuffle이 들어가면 분석이 너무 어렵기 때문에 Shuffle이 발생하지 않는 코드로만 추적해보았으며, 이번 글에서는 Driver에서 발생하는 과정만을 다룬다.</p>

<h2 id="shuffle이-없는-count">Shuffle이 없는 count()</h2>

<p>Spark 코드를 확인해보면 Shuffle이 존재하는 연산보다 Shuffle이 존재하지 않는 연산이 훨씬 쉽고, 읽어야 할 코드의 양이 적기 때문에 Shuffle이 존재하지 않는 RDD의 count()부터 알아보기로 한다.</p>

<p>아래와 같이 한 번의 map으로 이루어진 RDD의 count()가 어떻게 동작하는지 알아본다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val parallelizedRDD = sc.parallelize(Seq(1,2,3,4,5,6,7,8,9,10), 2)
val transformedRDD = parallelizedRDD.map(_ + "th value")
transformedRDD.count()
</code></pre></div></div>

<h3 id="val-parallelizedrdd--scparallelizeseq12345678910-2">val parallelizedRDD = sc.parallelize(Seq(1,2,3,4,5,6,7,8,9,10), 2)</h3>

<p><code class="highlighter-rouge">SparkContext</code> 클래스에 있는 <code class="highlighter-rouge">parallelize</code>는 Caller(Driver)에 존재하는 Scala Collection을 RDD로 만드는 함수이다. 반환 타입은 <code class="highlighter-rouge">ParallelCollectionRDD</code>이다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def parallelize[T: ClassTag](
    seq: Seq[T],
    numSlices: Int = defaultParallelism): RDD[T] = withScope {
  assertNotStopped()
  new ParallelCollectionRDD[T](this, seq, numSlices, Map[Int, Seq[String]]()
}
</code></pre></div></div>

<p><code class="highlighter-rouge">ParallelCollectionRDD</code>는 <code class="highlighter-rouge">RDD</code>클래스를 상속하는데, 생성자를 눈여겨 보아야 한다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private[spark] class ParallelCollectionRDD[T: ClassTag](
    sc: SparkContext,
    @transient private val data: Seq[T],
    numSlices: Int,
    locationPrefs: Map[Int, Seq[String]])
    extends RDD[T](sc, Nil) {
</code></pre></div></div>

<p>위 코드에서 호출하고 있는 부모 클래스 <code class="highlighter-rouge">RDD</code>의 생성자 코드는 아래와 같다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>abstract class RDD[T: ClassTag](
    @transient private var _sc: SparkContext,
    @transient private var deps: Seq[Dependency[_]]
  ) extends Serializable with Logging {
</code></pre></div></div>
<p><code class="highlighter-rouge">parallelize</code> 함수를 통해 생성되는 RDD는 부모 RDD가 존재하지 않기 때문에 Dependency가 존재하지 않아 RDD의 Dependency가 <code class="highlighter-rouge">null</code>로 만들어진다.</p>

<p>그리고 RDD에서 중요한 요소 중 하나인 Partition이 어떻게 생성되는지 확인해보도록 한다. 아래 코드는 <code class="highlighter-rouge">ParallelCollectionRDD</code> 클래스의 <code class="highlighter-rouge">getPartitions</code> 함수이다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>override def getPartitions: Array[Partition] = {
  val slices = ParallelCollectionRDD.slice(data, numSlices).toArray
  slices.indices.map(i =&gt; new ParallelCollectionPartition(id, i, slices(i))).toArray
}
</code></pre></div></div>
<p><code class="highlighter-rouge">parallelize</code> 함수의 인자인 data를 numSlices개로 잘라서 ParallelCollectionPartition으로 만든다.</p>

<p>아래 코드를 실행해보면 생성된 파티션의 정보를 확인할 수 있다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val parallelizedRDD = sc.parallelize(Seq(1,2,3,4,5,6,7,8,9,10), 2)
parallelizedRDD.partitions.map(_.asInstanceOf[ParallelCollectionPartition[Int]]).foreach(p =&gt; println(s"RDD: ${p.rddId}, Partition: ${p.index}, Values: ${p.values.mkString(",")}"))
</code></pre></div></div>
<p>출력 결과:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RDD: 0, Partition: 0, Values: 1,2,3,4,5
RDD: 0, Partition: 1, Values: 6,7,8,9,10
</code></pre></div></div>

<h4 id="rdd의-id">RDD의 ID</h4>

<p>RDD의 ID는 RDD 객체 생성 시 <code class="highlighter-rouge">SparkContext</code>의 <code class="highlighter-rouge">newRddId</code> 함수를 호출하여 생성한다. 즉, RDD의 ID는 <code class="highlighter-rouge">SparkContext</code> 내에서 유일한 값이다.</p>

<p><strong>RDD 클래스의 id 필드</strong></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/** A unique ID for this RDD (within its SparkContext). */
  val id: Int = sc.newRddId()
</code></pre></div></div>
<p><strong>SparkContext 클래스의 newRddId 함수</strong></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/** Register a new RDD, returning its RDD ID */
  private[spark] def newRddId(): Int = nextRddId.getAndIncrement()
</code></pre></div></div>

<h3 id="val-transformedrdd--parallelizedrddmap_--th-value">val transformedRDD = parallelizedRDD.map(_ + “th value”)</h3>

<p><code class="highlighter-rouge">parallelize</code> 함수를 통해 생성된 RDD에 <code class="highlighter-rouge">map</code> 함수를 적용하여 내부 값들을 변환하는 동작이다.</p>

<p><code class="highlighter-rouge">map</code> T 타입(원본 RDD의 요소 타입)을 U 타입으로 변환하는 함수를 인자로 받고, <code class="highlighter-rouge">MapPartitionsRDD</code> 타입의 객체를 반환하는 함수이다.</p>

<p><code class="highlighter-rouge">MapPartitionsRDD</code> 클래스의 생성자는 다음과 같다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private[spark] class MapPartitionsRDD[U: ClassTag, T: ClassTag](
    var prev: RDD[T],
    f: (TaskContext, Int, Iterator[T]) =&gt; Iterator[U],  // (TaskContext, partition index, iterator)
    preservesPartitioning: Boolean = false,
    isFromBarrier: Boolean = false,
    isOrderSensitive: Boolean = false)
  extends RDD[U](prev) {
</code></pre></div></div>
<p>이 떄 주의깊게 보아야 할 점은 RDD의 생성자에 Caller RDD(예시에서는 ParallelizedRDD)를 넘기고 있다.</p>

<p>해당 생성자의 코드는 아래와 같다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/** Construct an RDD with just a one-to-one dependency on one parent */
def this(@transient oneParent: RDD[_]) =
  this(oneParent.context, List(new OneToOneDependency(oneParent)))
</code></pre></div></div>
<p>아까와 달리 Dependency에 <code class="highlighter-rouge">null</code>이 아닌 <code class="highlighter-rouge">OneToOneDependency</code>를 넣어주고 있다. <code class="highlighter-rouge">map</code>은 <code class="highlighter-rouge">NarrowDependency</code>, 즉 Shuffle이 발생하지 않는 Transformation 연산이기 때문에 이전 RDD의 파티션과 새로 생성되는 RDD의 파티션이 1:1 관계를 가지게 되어 있다.</p>

<h4 id="onetoonedependency">OneToOneDependency</h4>

<p>Parent RDD와 Child RDD가 1:1 관계를 가지는 것을 표현하는 클래스이다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/**
 * :: DeveloperApi ::
 * Represents a one-to-one dependency between partitions of the parent and child RDDs.
 */
@DeveloperApi
class OneToOneDependency[T](rdd: RDD[T]) extends NarrowDependency[T](rdd) {
  override def getParents(partitionId: Int): List[Int] = List(partitionId)
}
</code></pre></div></div>

<p><code class="highlighter-rouge">parallelizedRDD</code>와 <code class="highlighter-rouge">transformedRDD</code>의 관계는 <code class="highlighter-rouge">OneToOneDependency</code>를 이용하여 아래와 같이 표현할 수 있다.</p>

<p>Parent(parallelizedRDD) &lt;— OneToOneDependency —&gt; Child(transformedRDD)</p>

<h4 id="transformedrdd의-partition-구성">transformedRDD의 Partition 구성</h4>

<p><code class="highlighter-rouge">transformedRDD</code>의 파티션은 어떤 형태를 가지고 있을까? <code class="highlighter-rouge">transformedRDD</code>의 <code class="highlighter-rouge">getPartitions</code> 함수는 다음과 같다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>override def getPartitions: Array[Partition] = firstParent[T].partitions
</code></pre></div></div>

<p>부모 파티션의 Partition을 그대로 반환하게 되어 있다. map 과정에서 Shuffle이 발생하지 않기 때문에 RDD의 관계와 같이 Partition의 관계도 부모와 자식이 1:1로 유지되는 것을 알 수 있다.</p>

<p>코드를 통해 실제로도 동일한 파티션인지 확인해본다. 실제 값을 출력하는 방법과 객체를 비교하는 방법으로 검증해보았다.</p>

<p><strong>실제 값을 출력하는 방법(위의 parallelizedRDD에 대해 호출한 출력값과 동일해야 함)</strong></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>transformedRDD.partitions.map(_.asInstanceOf[ParallelCollectionPartition[Int]]).foreach(p =&gt; println(s"RDD: ${p.rddId}, Partition: ${p.index}, Values: ${p.values.mkString(",")}"))
</code></pre></div></div>
<p>출력 결과:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>RDD: 0, Partition: 0, Values: 1,2,3,4,5
RDD: 0, Partition: 1, Values: 6,7,8,9,10
</code></pre></div></div>
<p><strong>partitions 객체가 동일한지 확인하는 방법</strong></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>assert(parallelizedRDD.partitions === transformedRDD.partitions)
</code></pre></div></div>

<h3 id="transformedrddcount">transformedRDD.count()</h3>

<p><code class="highlighter-rouge">count()</code>은 Action으로써 실제로 작업이 실행되는 함수이다. <code class="highlighter-rouge">count</code>의 코드는 아래와 같다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def count(): Long = sc.runJob(this, Utils.getIteratorSize _).sum
</code></pre></div></div>

<p><code class="highlighter-rouge">SparkContext</code> 객체의 <code class="highlighter-rouge">runJob</code> 함수를 호출한다. 호출되는 <code class="highlighter-rouge">runJob</code>은 내부적으로 다시 오버로딩 된 <code class="highlighter-rouge">runJob</code> 함수들을 호출하게 된다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def runJob[T, U: ClassTag](rdd: RDD[T], func: Iterator[T] =&gt; U): Array[U] = {
    runJob(rdd, func, 0 until rdd.partitions.length)
  }
</code></pre></div></div>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def runJob[T, U: ClassTag](
      rdd: RDD[T],
      func: Iterator[T] =&gt; U,
      partitions: Seq[Int]): Array[U] = {
    val cleanedFunc = clean(func)
    runJob(rdd, (ctx: TaskContext, it: Iterator[T]) =&gt; cleanedFunc(it), partitions)
  }
</code></pre></div></div>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def runJob[T, U: ClassTag](
      rdd: RDD[T],
      func: (TaskContext, Iterator[T]) =&gt; U,
      partitions: Seq[Int]): Array[U] = {
    val results = new Array[U](partitions.size)
    runJob[T, U](rdd, func, partitions, (index, res) =&gt; results(index) = res)
    results
  }
</code></pre></div></div>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def runJob[T, U: ClassTag](
      rdd: RDD[T],
      func: (TaskContext, Iterator[T]) =&gt; U,
      partitions: Seq[Int],
      resultHandler: (Int, U) =&gt; Unit): Unit = {
    if (stopped.get()) {
      throw new IllegalStateException("SparkContext has been shutdown")
    }
    val callSite = getCallSite
    val cleanedFunc = clean(func)
    logInfo("Starting job: " + callSite.shortForm)
    if (conf.getBoolean("spark.logLineage", false)) {
      logInfo("RDD's recursive dependencies:\n" + rdd.toDebugString)
    }
    dagScheduler.runJob(rdd, cleanedFunc, partitions, callSite, resultHandler, localProperties.get)
    progressBar.foreach(_.finishAll())
    rdd.doCheckpoint()
  }
</code></pre></div></div>
<p>대부분의 runJob의 매개변수의 구성은 아래와 같다.</p>
<ul>
  <li>rdd: Action을 호출하는 RDD이다.</li>
  <li>func: rdd의 각 파티션에 적용할 함수이다.</li>
  <li>partitions: rdd를 구성하는 Partition의 Sequence</li>
</ul>

<p>다른 코드(Clousure를 닫아주는 clean 등)들은 부가적인 부분이고 실제 Job을 수행하는 부분은 <code class="highlighter-rouge">dagScheduler</code>의 <code class="highlighter-rouge">runJob</code> 함수 호출이다.</p>

<h3 id="dagscheduler의-동작1">DagScheduler의 동작(1)</h3>

<p><code class="highlighter-rouge">count()</code>, <code class="highlighter-rouge">show()</code>, <code class="highlighter-rouge">save()</code> 등과 같은 Action을 호출하게 되면, DagScheduler에서 RDD를 Job으로 변환하여 실제 연산을 수행하게 된다.</p>

<p><code class="highlighter-rouge">SparkContext</code>에서 호출한 <code class="highlighter-rouge">DagScheduler</code>의 <code class="highlighter-rouge">runJob</code>의 코드는 아래와 같다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def runJob[T, U](
      rdd: RDD[T],
      func: (TaskContext, Iterator[T]) =&gt; U,
      partitions: Seq[Int],
      callSite: CallSite,
      resultHandler: (Int, U) =&gt; Unit,
      properties: Properties): Unit = {
  val start = System.nanoTime
  val waiter = submitJob(rdd, func, partitions, callSite, resultHandler, properties)
  ThreadUtils.awaitReady(waiter.completionFuture, Duration.Inf)
  waiter.completionFuture.value.get match {
    case scala.util.Success(_) =&gt;
      logInfo("Job %d finished: %s, took %f s".format
        (waiter.jobId, callSite.shortForm, (System.nanoTime - start) / 1e9))
    case scala.util.Failure(exception) =&gt;
      logInfo("Job %d failed: %s, took %f s".format
        (waiter.jobId, callSite.shortForm, (System.nanoTime - start) / 1e9))
      // SPARK-8644: Include user stack trace in exceptions coming from DAGScheduler.
      val callerStackTrace = Thread.currentThread().getStackTrace.tail
      exception.setStackTrace(exception.getStackTrace ++ callerStackTrace)
      throw exception
  }
}
</code></pre></div></div>
<p>실제 Job을 submit하고 기다리는 부분은 아래 코드이다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val waiter = submitJob(rdd, func, partitions, callSite, resultHandler, properties)
</code></pre></div></div>

<p>다시 <code class="highlighter-rouge">submitJob</code> 코드를 확인해보면 다음과 같다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def submitJob[T, U](
    rdd: RDD[T],
    func: (TaskContext, Iterator[T]) =&gt; U,
    partitions: Seq[Int],
    callSite: CallSite,
    resultHandler: (Int, U) =&gt; Unit,
    properties: Properties): JobWaiter[U] = {
  // Check to make sure we are not launching a task on a partition that does not exist.
  val maxPartitions = rdd.partitions.length
  partitions.find(p =&gt; p &gt;= maxPartitions || p &lt; 0).foreach { p =&gt;
    throw new IllegalArgumentException(
      "Attempting to access a non-existent partition: " + p + ". " +
      "Total number of partitions: " + maxPartitions)
  }

  val jobId = nextJobId.getAndIncrement()
  if (partitions.isEmpty) {
    val time = clock.getTimeMillis()
    listenerBus.post(
      SparkListenerJobStart(jobId, time, Seq[StageInfo](), properties))
    listenerBus.post(
      SparkListenerJobEnd(jobId, time, JobSucceeded))
    // Return immediately if the job is running 0 tasks
    return new JobWaiter[U](this, jobId, 0, resultHandler)
  }

  assert(partitions.nonEmpty)
  val func2 = func.asInstanceOf[(TaskContext, Iterator[_]) =&gt; _]
  val waiter = new JobWaiter[U](this, jobId, partitions.size, resultHandler)
  eventProcessLoop.post(JobSubmitted(
    jobId, rdd, func2, partitions.toArray, callSite, waiter,
    SerializationUtils.clone(properties)))
  waiter
}
</code></pre></div></div>

<p>코드의 윗부분들은 Partition이 없는 경우 등 특수한 상황을 처리하는 부분이고, 우리가 실제로 눈여겨보아야 할 부분은 아래의 코드이다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val func2 = func.asInstanceOf[(TaskContext, Iterator[_]) =&gt; _]
val waiter = new JobWaiter[U](this, jobId, partitions.size, resultHandler)
eventProcessLoop.post(JobSubmitted(
  jobId, rdd, func2, partitions.toArray, callSite, waiter,
  SerializationUtils.clone(properties)))
waiter
</code></pre></div></div>

<p><code class="highlighter-rouge">EventLoop</code> 타입인 <code class="highlighter-rouge">eventProcessLoop</code> 객체의 <code class="highlighter-rouge">post</code> 함수 호출을 통해 실제 작업을 호출하게 된다.</p>

<h3 id="eventloop와-dagschedulereventprocessloop">EventLoop와 DAGSchedulerEventProcessLoop</h3>

<p><code class="highlighter-rouge">EventLoop</code> Job을 수행하는 Action 연산이나 Job을 종료하는 Job Cancel이 호출될 경우 이러한 작업을 처리하는 Thread를 만들어 수행하는 추상 클래스이며, <code class="highlighter-rouge">DagSchedulerEventProcessLoop</code>는 <code class="highlighter-rouge">EventLoop</code>를 상속한 구체 클래스이다.</p>

<p>위의 <code class="highlighter-rouge">DagScheduler</code>에서 <code class="highlighter-rouge">post</code>를 호출하게 되면 EventLoop의 eventQueue에 작업을 넣는다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def post(event: E): Unit = {
  if (!stopped.get) {
    if (eventThread.isAlive) {
      eventQueue.put(event)
    } else {
      onError(new IllegalStateException(s"$name has already been stopped accidentally."))
    }
  }
}
</code></pre></div></div>
<p><code class="highlighter-rouge">EventLoop</code>는 무한루프를 돌며 EventQueue에서 작업을 꺼내 <code class="highlighter-rouge">onReceive</code> 함수를 호출한다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>override def run(): Unit = {
  try {
    while (!stopped.get) {
      val event = eventQueue.take()
      try {
        onReceive(event)
      } catch {
        case NonFatal(e) =&gt;
          try {
            onError(e)
          } catch {
            case NonFatal(e) =&gt; logError("Unexpected error in " + name, e)
          }
      }
    }
  } catch {
    case ie: InterruptedException =&gt; // exit even if eventQueue is not empty
    case NonFatal(e) =&gt; logError("Unexpected error in " + name, e)
  }
}
</code></pre></div></div>

<p><code class="highlighter-rouge">onReceive</code> 함수는 <code class="highlighter-rouge">EventLoop</code> 클래스의 구현체인 <code class="highlighter-rouge">DagSchedulerEventProcessLoop</code>의 <code class="highlighter-rouge">onReceive</code>에 구현되어 있다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>override def onReceive(event: DAGSchedulerEvent): Unit = {
  val timerContext = timer.time()
  try {
    doOnReceive(event)
  } finally {
    timerContext.stop()
  }
}
</code></pre></div></div>

<p><code class="highlighter-rouge">onReceive</code>의 내부에서는 다시 <code class="highlighter-rouge">doOnReceive</code> 함수를 호출하게 된다. <code class="highlighter-rouge">doOnReceive</code> 함수에서는 매개변수로 전달받은 Event를 패턴매칭을 통해 걸러내고 <code class="highlighter-rouge">DagScheduler</code>의 handle 함수에게 넘기게 된다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private def doOnReceive(event: DAGSchedulerEvent): Unit = event match {
  case JobSubmitted(jobId, rdd, func, partitions, callSite, listener, properties) =&gt;
    dagScheduler.handleJobSubmitted(jobId, rdd, func, partitions, callSite, listener, properties)

  case MapStageSubmitted(jobId, dependency, callSite, listener, properties) =&gt;
    dagScheduler.handleMapStageSubmitted(jobId, dependency, callSite, listener, properties)

  case StageCancelled(stageId, reason) =&gt;
    dagScheduler.handleStageCancellation(stageId, reason)

  case JobCancelled(jobId, reason) =&gt;
    dagScheduler.handleJobCancellation(jobId, reason)
...생략
</code></pre></div></div>

<p>우리가 DagScheduler에서 호출한 submitJob 코드를 보면 아래와 같았다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>eventProcessLoop.post(JobSubmitted(
  jobId, rdd, func2, partitions.toArray, callSite, waiter,
  SerializationUtils.clone(properties)))
</code></pre></div></div>

<p><code class="highlighter-rouge">JobSumitted</code> 타입의 객체를 전달했기 때문에 case문의 첫번째에 걸려 <code class="highlighter-rouge">DagScheduler</code>의 <code class="highlighter-rouge">handleJobSubmitted</code>를 호출한다.</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>case JobSubmitted(jobId, rdd, func, partitions, callSite, listener, properties) =&gt;
  dagScheduler.handleJobSubmitted(jobId, rdd, func, partitions, callSite, listener, properties)
</code></pre></div></div>

<p><code class="highlighter-rouge">handleJobSubmitted</code> 함수가 워낙 길어 필요한 부분만 간추리면 아래와 같이 볼 수 있다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private[scheduler] def handleJobSubmitted(jobId: Int,
    finalRDD: RDD[_],
    func: (TaskContext, Iterator[_]) =&gt; _,
    partitions: Array[Int],
    callSite: CallSite,
    listener: JobListener,
    properties: Properties) {
  var finalStage: ResultStage = null
  try {
    // New stage creation may throw an exception if, for example, jobs are run on a
    // HadoopRDD whose underlying HDFS files have been deleted.
    finalStage = createResultStage(finalRDD, func, partitions, jobId, callSite)
  } catch {
    ...생략
  }
  // Job submitted, clear internal data.
  barrierJobIdToNumTasksCheckFailures.remove(jobId)

  val job = new ActiveJob(jobId, finalStage, callSite, listener, properties)
  clearCacheLocs()
  ...생략
  jobIdToActiveJob(jobId) = job
  activeJobs += job
  finalStage.setActiveJob(job)
  val stageIds = jobIdToStageIds(jobId).toArray
  val stageInfos = stageIds.flatMap(id =&gt; stageIdToStage.get(id).map(_.latestInfo))
  listenerBus.post(
    SparkListenerJobStart(job.jobId, jobSubmissionTime, stageInfos, properties))
  submitStage(finalStage)
}
</code></pre></div></div>

<p><code class="highlighter-rouge">createResultStage</code> 함수를 호출하여 Action 연산을 호출한 RDD를 통해 ResultStage를 생성하고 이를 <code class="highlighter-rouge">submitStage</code> 함수를 통해 다시 DagSchedulerEventProcessLoop에게 전달한다.</p>

<h4 id="stage의-정의와-종류">Stage의 정의와 종류</h4>

<p>Stage는 동일한 Shuffle Dependency를 가진 Task들의 집합이다(즉, Shuffle이 Stage를 나누는 기준이 된다). Stage를 구성하는 Task들은 Narrow Dependency를 통해 연결되어 있으며, 병렬로 실행될 수 있다.</p>

<p>Stage는 <code class="highlighter-rouge">ShuffleMapStage</code>와 <code class="highlighter-rouge">ResultStage</code>로 나뉘어진다.</p>

<ul>
  <li>ShuffleMapStage: Task들의 결과가 다른 Stage의 Input으로 들어가는 Stage</li>
  <li>ResultStage: Action의 결과를 출력하기 위해 동작하는 Stage</li>
</ul>

<p>즉, 1개의 Spark Job은 1개 이상의 ShuffleMapStage와 1개의 ResultStage로 구성된다고 볼 수 있다.</p>

<h3 id="dagscheduler의-동작2">DagScheduler의 동작(2)</h3>

<p><code class="highlighter-rouge">createResultStage</code> 함수의 코드는 아래와 같다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private def createResultStage(
    rdd: RDD[_],
    func: (TaskContext, Iterator[_]) =&gt; _,
    partitions: Array[Int],
    jobId: Int,
    callSite: CallSite): ResultStage = {
  checkBarrierStageWithDynamicAllocation(rdd)
  checkBarrierStageWithNumSlots(rdd)
  checkBarrierStageWithRDDChainPattern(rdd, partitions.toSet.size)
  val parents = getOrCreateParentStages(rdd, jobId)
  val id = nextStageId.getAndIncrement()
  val stage = new ResultStage(id, rdd, func, partitions, parents, jobId, callSite)
  stageIdToStage(id) = stage
  updateJobIdStageIdMaps(jobId, stage)
  stage
}
</code></pre></div></div>

<p><code class="highlighter-rouge">getOrCreateParentStages</code> 라는 함수를 통해 ResultStage 를 생성하는 이전 Stage를 가져온다.</p>

<p>여기서 우리가 처음 호출했던 코드를 다시 확인해보자.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val parallelizedRDD = sc.parallelize(Seq(1,2,3,4,5,6,7,8,9,10), 2)
val transformedRDD = parallelizedRDD.map(_ + "th value")
transformedRDD.count()
</code></pre></div></div>

<p><code class="highlighter-rouge">parallelize</code>와 <code class="highlighter-rouge">map</code>으로만 구성된 RDD이기 때문에 Shuffle이 존재하지 않고, 결과적으로 이 코드는 1개의 Stage로만 이루어져 있다.</p>

<p>따라서 위의 <code class="highlighter-rouge">getOrCreateParentStages</code> 함수는 <code class="highlighter-rouge">null</code>을 반환하게 된다. 따라서 <code class="highlighter-rouge">createResultStage</code>에서는 1개의 ResultStage만 반환하게 된다.</p>

<p>생성된 Stage는 <code class="highlighter-rouge">handleJobSubmitted</code>의 <code class="highlighter-rouge">submitStage</code> 함수를 통해 처리된다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private[scheduler] def handleJobSubmitted(jobId: Int,
    finalRDD: RDD[_],
    func: (TaskContext, Iterator[_]) =&gt; _,
    partitions: Array[Int],
    callSite: CallSite,
    listener: JobListener,
    properties: Properties) {
  var finalStage: ResultStage = null
  try {
    // New stage creation may throw an exception if, for example, jobs are run on a
    // HadoopRDD whose underlying HDFS files have been deleted.
    finalStage = createResultStage(finalRDD, func, partitions, jobId, callSite)
  } catch {
    ...생략
  }
  ...생략
  submitStage(finalStage)
}
</code></pre></div></div>

<p><code class="highlighter-rouge">submitStage</code>의 코드는 아래와 같다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private def submitStage(stage: Stage) {
  val jobId = activeJobForStage(stage)
  if (jobId.isDefined) {
    logDebug("submitStage(" + stage + ")")
    if (!waitingStages(stage) &amp;&amp; !runningStages(stage) &amp;&amp; !failedStages(stage)) {
      val missing = getMissingParentStages(stage).sortBy(_.id)
      logDebug("missing: " + missing)
      if (missing.isEmpty) {
        logInfo("Submitting " + stage + " (" + stage.rdd + "), which has no missing parents")
        submitMissingTasks(stage, jobId.get)
      } else {
        for (parent &lt;- missing) {
          submitStage(parent)
        }
        waitingStages += stage
      }
    }
  } else {
    abortStage(stage, "No active job for stage " + stage.id, None)
  }
}
</code></pre></div></div>
<p>일단 <code class="highlighter-rouge">getMissingParentStages</code> 함수를 통해 해당 Stage 이전에 실행되어야 하는 Stage를 찾아내고 실행한다. 이 예제에서는 이전에 실행되어야 하는 Stage가 존재하지 않으므로 <code class="highlighter-rouge">submitMissingTasks</code> 함수가 실행된다.</p>

<p><code class="highlighter-rouge">submitMissingTasks</code> 함수는 워낙 길어서 필요한 부분만 잘라보았는데, 중요한 부분은 아래와 같다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>val tasks: Seq[Task[_]] = try {
  val serializedTaskMetrics = closureSerializer.serialize(stage.latestInfo.taskMetrics).array()
  stage match {
    case stage: ShuffleMapStage =&gt;
      stage.pendingPartitions.clear()
      partitionsToCompute.map { id =&gt;
        val locs = taskIdToLocations(id)
        val part = partitions(id)
        stage.pendingPartitions += id
        new ShuffleMapTask(stage.id, stage.latestInfo.attemptNumber,
          taskBinary, part, locs, properties, serializedTaskMetrics, Option(jobId),
          Option(sc.applicationId), sc.applicationAttemptId, stage.rdd.isBarrier())
      }

    case stage: ResultStage =&gt;
      partitionsToCompute.map { id =&gt;
        val p: Int = stage.partitions(id)
        val part = partitions(p)
        val locs = taskIdToLocations(id)
        new ResultTask(stage.id, stage.latestInfo.attemptNumber,
          taskBinary, part, locs, id, properties, serializedTaskMetrics,
          Option(jobId), Option(sc.applicationId), sc.applicationAttemptId,
          stage.rdd.isBarrier())
      }
  }
} catch {
  case NonFatal(e) =&gt;
    abortStage(stage, s"Task creation failed: $e\n${Utils.exceptionString(e)}", Some(e))
    runningStages -= stage
    return
}
</code></pre></div></div>

<p>위의 코드는 Stage를 Task로 분리하여 TaskSet 형태로 만드는 과정이다. Task는 1개의 Partition을 연산하는 작업을 의미하며, TaskSet은 1개 이상의 Task로 구성된 개념으로 사실상 Stage와 동일하다고 생각하면 될 것 같다.</p>

<p>Task는 Stage의 종류에 따라 <code class="highlighter-rouge">ShuffleMapStage</code>일 경우 <code class="highlighter-rouge">ShuffleMapTask</code>, <code class="highlighter-rouge">ResultStage</code>일 경우 <code class="highlighter-rouge">ResultTask</code>로 구분되어 생성된다.</p>

<p>이렇게 생성된 TaskSet은 <code class="highlighter-rouge">TaskScheduler</code>의 <code class="highlighter-rouge">submitTasks</code> 함수에 전달되어 실행된다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>taskScheduler.submitTasks(new TaskSet(
        tasks.toArray, stage.id, stage.latestInfo.attemptNumber, jobId, properties))
</code></pre></div></div>

<p><code class="highlighter-rouge">TaskScheduler</code>의 구현체인 <code class="highlighter-rouge">TaskSchedulerImpl</code>의 <code class="highlighter-rouge">submitTasks</code> 에서는 다시 <code class="highlighter-rouge">SchedulerBackend</code>의 구현체인 <code class="highlighter-rouge">CoarseGrainedSchedulerBackend</code>의 <code class="highlighter-rouge">receiveOffers</code>를 호출하게 된다.</p>

<blockquote>
  <p>사실 이 부분에서 receiveOffers의 인자로 넘기는게 없는데, 실행시킬 수 있다는게 이해가 가지 않는다. 다만 <code class="highlighter-rouge">CoarseGrainedSchedulerBackend</code>에서 <code class="highlighter-rouge">TaskSchedulerImpl</code> 객체를 내부 변수로 가지고 있기 때문에 <code class="highlighter-rouge">TaskScehdulerImpl</code>의 내부 변수를 참조하여 실행시키는 것이 아닌가 하는 추측으로 진행을 했다.</p>
</blockquote>

<h3 id="schedulerbackendcoarsegrainedschedulerbackend의-동작">SchedulerBackend(CoarseGrainedSchedulerBackend)의 동작</h3>

<p><code class="highlighter-rouge">SchedulerBackend</code>의 구현체인 <code class="highlighter-rouge">CoarseGrainedSchedulerBackend</code>의 <code class="highlighter-rouge">receiveOffer</code>는 다시 <code class="highlighter-rouge">DriverEndpoint</code> 객체의 <code class="highlighter-rouge">send</code> 함수를 호출하여 실행을 요청한다.</p>

<p><code class="highlighter-rouge">DriverEndpoint</code>의 <code class="highlighter-rouge">receive</code> 함수에서는 <code class="highlighter-rouge">ReceiveOffer</code> 이벤트를 수신하여 <code class="highlighter-rouge">makeOffers</code> 함수를 수행한다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>case ReviveOffers =&gt;
  makeOffers()
</code></pre></div></div>

<p><code class="highlighter-rouge">makeOffers</code> 함수에서는 실행할 Task의 정보를 받아와 <code class="highlighter-rouge">launchTask</code> 함수를 통해 실제 Task 실행을 수행한다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private def makeOffers() {
  // Make sure no executor is killed while some task is launching on it
  val taskDescs = withLock {
    // Filter out executors under killing
    val activeExecutors = executorDataMap.filterKeys(executorIsAlive)
    val workOffers = activeExecutors.map {
      case (id, executorData) =&gt;
        new WorkerOffer(id, executorData.executorHost, executorData.freeCores,
              Some(executorData.executorAddress.hostPort),
              executorData.resourcesInfo.map { case (rName, rInfo) =&gt;
              (rName, rInfo.availableAddrs.toBuffer)}
        )
    }.toIndexedSeq
    scheduler.resourceOffers(workOffers)
  }
  if (taskDescs.nonEmpty) {
    launchTasks(taskDescs)
  }
}
</code></pre></div></div>

<blockquote>
  <p>위 함수에서 아마 TaskScheduler에서 만든 TaskSet을 받아 처리하는 것 같은데, 어디서 데이터를 가져오는지는 잘 모르겠다. 아마 executorDataMap일 것 같은데.. 좀 더 살펴봐야 할 것 같다.</p>
</blockquote>

<p>대망의 <code class="highlighter-rouge">launchTask</code> 함수이다. TaskSet을 구성하는 Task들을 Serialization하여 각 Executor에게 실행을 요청한다.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private def launchTasks(tasks: Seq[Seq[TaskDescription]]) {
  for (task &lt;- tasks.flatten) {
    val serializedTask = TaskDescription.encode(task)
    if (serializedTask.limit() &gt;= maxRpcMessageSize) {
      Option(scheduler.taskIdToTaskSetManager.get(task.taskId)).foreach { taskSetMgr =&gt;
        try {
          var msg = "Serialized task %s:%d was %d bytes, which exceeds max allowed: " +
            s"${RPC_MESSAGE_MAX_SIZE.key} (%d bytes). Consider increasing " +
            s"${RPC_MESSAGE_MAX_SIZE.key} or using broadcast variables for large values."
          msg = msg.format(task.taskId, task.index, serializedTask.limit(), maxRpcMessageSize)
          taskSetMgr.abort(msg)
        } catch {
          case e: Exception =&gt; logError("Exception in error callback", e)
        }
      }
    }
    else {
      val executorData = executorDataMap(task.executorId)
      // Do resources allocation here. The allocated resources will get released after the task
      // finishes.
      executorData.freeCores -= scheduler.CPUS_PER_TASK
      task.resources.foreach { case (rName, rInfo) =&gt;
        assert(executorData.resourcesInfo.contains(rName))
        executorData.resourcesInfo(rName).acquire(rInfo.addresses)
      }

      logDebug(s"Launching task ${task.taskId} on executor id: ${task.executorId} hostname: " +
        s"${executorData.executorHost}.")

      executorData.executorEndpoint.send(LaunchTask(new SerializableBuffer(serializedTask)))
    }
  }
}
</code></pre></div></div>

<p>여기까지가 Driver 단에서 RDD의 Action을 수행한 후 Task의 실행을 Executor에게 Launch하도록 요청하는 과정이다.</p>

<p>3줄짜리 코드를 실행하기 위해 이렇게 많은 구성요소들이 결합하여 동작하는줄 모르고 있었고, 생각보다 실행이 매우 복잡하다는 것을 느낄 수 있었다.</p>


</div>

<div class="pagination">
  
    <a href="/2019-10-07/LongestSubstringWithoutRepeatingCharacters" class="left arrow">&#8592;</a>
  
  
    <a href="/2019-06-29/validation-with-chain-of-responsibility" class="right arrow">&#8594;</a>
  

  <a href="#" class="top">Top</a>
</div>

    </main>

    <footer>
  <span>
    &copy; <time datetime="2019-10-08 19:35:35 +0900">2019</time> leeyh0216. Made with Jekyll using the <a href="https://github.com/chesterhow/tale/">Tale</a> theme.
  </span>
</footer>

  </body>
</html>
