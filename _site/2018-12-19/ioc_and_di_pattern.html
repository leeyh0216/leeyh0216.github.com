<!DOCTYPE html>
<html lang="en">

  <head>
  
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Inversion of Control Containers and the Dependency Injection pattern | DevLog</title>
<meta name="generator" content="Jekyll v3.8.6" />
<meta property="og:title" content="Inversion of Control Containers and the Dependency Injection pattern" />
<meta name="author" content="leeyh0216" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="이 글은 Martin Fowler의 Inversion of Control Containers and the Dependency Injection pattern을 요약 정리한 글입니다. Inversion of Control Containers and the Dependency Injection pattern 많은 오픈소스들은 J2EE 기술에 대한 대안을 구축하는 다양한 활동을 하고 있다. 이러한 활동은 J2EE의 복잡도를 획기적인 방법으로 낮추기 위함이다. 이들이 다루는 공통적인 이슈는 서로 다른 요소들을 어떻게 결합하는지에 대한 것이다. 이러한 문제를 해결하기 위해 많은 프레임워크들이 등장했고, 몇몇 프레임워크는 다른 레이어에 있는 요소(컴포넌트)들을 조합하는 방식을 제공한다. 이러한 방식은 Lightweight Container(경량화된 컨테이너)라고 불리운다. Component and Service 컴포넌트: 어플리케이션에서 사용될 목적으로 만들어진 소프트웨어 구성 요소이며, 컴포넌트는 컴포넌트 작성자가 허용하는 방식으로만 확장이 가능하다. 서비스: 컴포넌트와 비슷하지만, 외부 어플리케이션에서 사용한다는 점에서 차이를 보인다. 컴포넌트는 Jar, Assembly, DLL 등을 통해 제공되어 로컬에서 사용하며, 서비스는 웹서비스, 메시징 시스템, RPC, Socket 등의 원격 인터페이스를 통해 사용된다. A Naive Example 원본 글에서 아래와 같은 예제가 제공된다. class MovieLister{ public Movie[] moviesDirectedBy(String arg) { List allMovies = finder.findAll(); for(Iterator it = allMovies.iterator(); it.hasNext();) { Movie movie = (Movie)it.next(); if (!movie.getDirector().equals(arg)) it.remove(); } } return (Movie[])allMovies.toArray(new Movie[allMovies.size()]); } 영화 목록 중 인자로 주어진 값을 영화 감독으로 가지는 영화를 추출하여 반환하는 moviesDirectedBy 라는 메서드가 정의되어 있는 MovieLister라는 클래스를 제공하고 있다. 위 예제의 요점은 ‘MovieLister 객체와 Finder 객체를 연결하는 법‘이다. MovieLister 객체는 영화가 어떻게 저장되는지에 대해서는 전혀 관심이 없다. 단지 조건에 부합하는 영화를 moviesDirectedBy 메서드로 찾고 싶을 뿐이다. 즉, Finder 객체와의 의존성을 없애고 싶은 것이다. 이러한 문제를 해결하기 위해 Finder 객체를 아래와 같이 Interface로 정의하였다. public interface MovieFinder { List findAll(); } Finder를 Interface로 정의하므로써, Finder와 MovieLister 객체의 분리는 잘 된 것 같다. 그러나 아래와 같이 MovieLister 클래스의 생성자에서 Finder 객체를 상속한 ColonDelimitedMovieFinder 클래스의 객체를 명시적으로 할당해준다면 어떨까? class MovieLister { private MovieFinder finder; public MovieLister() { this.finder = new ColonDelimitedMovieFinder(&quot;movies1.txt&quot;); } } 코드의 작성자만 사용할 때는 문제가 없지만, 다른 사람이 위 클래스를 사용하게 된다면 ColonDelimitedMovieFinder 클래스의 생성자로 전달되는 “movies1.txt” 변경 불가 텍스트 파일이 아닌 XML 혹은 SQL 등에 영화 목록이 저장되어 있을 경우 사용 불가 와 같은 문제점에 부딪히게 된다. 위 그림에서와 같이 MovieLister가 MovieFinder Interface에 의존하지만, 동시에 이를 상속하는 Concrete Class인 MovieFinderImpl을 생성하므로써 둘 모두에 의존성이 생기게 된다. 즉, MovieFinder를 Interface로 만든 보람이 없어지게 된다. MovieLister와 MovieFinder를 제대로 Decouple 시키기 위해서는, 아래 MovieFinderImpl에 대한 의존성을 완전히 없애야 한다. 이러한 문제는 Plugin 패턴으로 해결할 수 있고, 이러한 Plugin을 어플리케이션에 조합해서 넣는 방법을 IoC를 사용하므로써 해결할 수 있다. Plugin 이란? Interface는 어플리케이션 코드가 서로 다른 구현을 필요로 하는 여러 런타임 환경에서 동작할 때 주로 사용된다. 개발자는 Interface를 적절히 구현하여 Factory Method에 제공(리턴)한다. 예를 들어 위 그림에서 DomainObject 객체가 Primiary Key를 생성해야 할 때, Unit Test 환경에서는 In-Memory Counter를 사용하고, Production 환경에서는 Database Managed Sequence를 사용해야 한다. 만일 IdGenerator를 제공하는 Factory Method를 직접 구현한다면, 조건문을 사용해서 실행 환경에 따라 일일이 다른 IdGenerator 구현체를 반환해야 할 것이다. 이러한 경우 실행 환경, 배포 환경 등이 바뀔 때마다 모든 Factory 의 조건문을 수정해야하는 상황이 발생할 수 있다. Plugin은 중앙화된 런타임 구성을 제공하므로써 이러한 문제를 해결한다. IoC(Inversion of Control) 위의 A Naive Exmple 에서 MovieLister 클래스는 MovieFinder를 상속한 구현체를 생성자에서 인스턴스화하였다. 이는 MovieFinder가 Plugin 화 될 수 없게 만든다. 이를 가능하게 하기 위해서는, 별도의 Assembly" />
<meta property="og:description" content="이 글은 Martin Fowler의 Inversion of Control Containers and the Dependency Injection pattern을 요약 정리한 글입니다. Inversion of Control Containers and the Dependency Injection pattern 많은 오픈소스들은 J2EE 기술에 대한 대안을 구축하는 다양한 활동을 하고 있다. 이러한 활동은 J2EE의 복잡도를 획기적인 방법으로 낮추기 위함이다. 이들이 다루는 공통적인 이슈는 서로 다른 요소들을 어떻게 결합하는지에 대한 것이다. 이러한 문제를 해결하기 위해 많은 프레임워크들이 등장했고, 몇몇 프레임워크는 다른 레이어에 있는 요소(컴포넌트)들을 조합하는 방식을 제공한다. 이러한 방식은 Lightweight Container(경량화된 컨테이너)라고 불리운다. Component and Service 컴포넌트: 어플리케이션에서 사용될 목적으로 만들어진 소프트웨어 구성 요소이며, 컴포넌트는 컴포넌트 작성자가 허용하는 방식으로만 확장이 가능하다. 서비스: 컴포넌트와 비슷하지만, 외부 어플리케이션에서 사용한다는 점에서 차이를 보인다. 컴포넌트는 Jar, Assembly, DLL 등을 통해 제공되어 로컬에서 사용하며, 서비스는 웹서비스, 메시징 시스템, RPC, Socket 등의 원격 인터페이스를 통해 사용된다. A Naive Example 원본 글에서 아래와 같은 예제가 제공된다. class MovieLister{ public Movie[] moviesDirectedBy(String arg) { List allMovies = finder.findAll(); for(Iterator it = allMovies.iterator(); it.hasNext();) { Movie movie = (Movie)it.next(); if (!movie.getDirector().equals(arg)) it.remove(); } } return (Movie[])allMovies.toArray(new Movie[allMovies.size()]); } 영화 목록 중 인자로 주어진 값을 영화 감독으로 가지는 영화를 추출하여 반환하는 moviesDirectedBy 라는 메서드가 정의되어 있는 MovieLister라는 클래스를 제공하고 있다. 위 예제의 요점은 ‘MovieLister 객체와 Finder 객체를 연결하는 법‘이다. MovieLister 객체는 영화가 어떻게 저장되는지에 대해서는 전혀 관심이 없다. 단지 조건에 부합하는 영화를 moviesDirectedBy 메서드로 찾고 싶을 뿐이다. 즉, Finder 객체와의 의존성을 없애고 싶은 것이다. 이러한 문제를 해결하기 위해 Finder 객체를 아래와 같이 Interface로 정의하였다. public interface MovieFinder { List findAll(); } Finder를 Interface로 정의하므로써, Finder와 MovieLister 객체의 분리는 잘 된 것 같다. 그러나 아래와 같이 MovieLister 클래스의 생성자에서 Finder 객체를 상속한 ColonDelimitedMovieFinder 클래스의 객체를 명시적으로 할당해준다면 어떨까? class MovieLister { private MovieFinder finder; public MovieLister() { this.finder = new ColonDelimitedMovieFinder(&quot;movies1.txt&quot;); } } 코드의 작성자만 사용할 때는 문제가 없지만, 다른 사람이 위 클래스를 사용하게 된다면 ColonDelimitedMovieFinder 클래스의 생성자로 전달되는 “movies1.txt” 변경 불가 텍스트 파일이 아닌 XML 혹은 SQL 등에 영화 목록이 저장되어 있을 경우 사용 불가 와 같은 문제점에 부딪히게 된다. 위 그림에서와 같이 MovieLister가 MovieFinder Interface에 의존하지만, 동시에 이를 상속하는 Concrete Class인 MovieFinderImpl을 생성하므로써 둘 모두에 의존성이 생기게 된다. 즉, MovieFinder를 Interface로 만든 보람이 없어지게 된다. MovieLister와 MovieFinder를 제대로 Decouple 시키기 위해서는, 아래 MovieFinderImpl에 대한 의존성을 완전히 없애야 한다. 이러한 문제는 Plugin 패턴으로 해결할 수 있고, 이러한 Plugin을 어플리케이션에 조합해서 넣는 방법을 IoC를 사용하므로써 해결할 수 있다. Plugin 이란? Interface는 어플리케이션 코드가 서로 다른 구현을 필요로 하는 여러 런타임 환경에서 동작할 때 주로 사용된다. 개발자는 Interface를 적절히 구현하여 Factory Method에 제공(리턴)한다. 예를 들어 위 그림에서 DomainObject 객체가 Primiary Key를 생성해야 할 때, Unit Test 환경에서는 In-Memory Counter를 사용하고, Production 환경에서는 Database Managed Sequence를 사용해야 한다. 만일 IdGenerator를 제공하는 Factory Method를 직접 구현한다면, 조건문을 사용해서 실행 환경에 따라 일일이 다른 IdGenerator 구현체를 반환해야 할 것이다. 이러한 경우 실행 환경, 배포 환경 등이 바뀔 때마다 모든 Factory 의 조건문을 수정해야하는 상황이 발생할 수 있다. Plugin은 중앙화된 런타임 구성을 제공하므로써 이러한 문제를 해결한다. IoC(Inversion of Control) 위의 A Naive Exmple 에서 MovieLister 클래스는 MovieFinder를 상속한 구현체를 생성자에서 인스턴스화하였다. 이는 MovieFinder가 Plugin 화 될 수 없게 만든다. 이를 가능하게 하기 위해서는, 별도의 Assembly" />
<link rel="canonical" href="http://localhost:4000/2018-12-19/ioc_and_di_pattern" />
<meta property="og:url" content="http://localhost:4000/2018-12-19/ioc_and_di_pattern" />
<meta property="og:site_name" content="DevLog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-12-19T10:00:00+09:00" />
<script type="application/ld+json">
{"author":{"@type":"Person","name":"leeyh0216"},"url":"http://localhost:4000/2018-12-19/ioc_and_di_pattern","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2018-12-19/ioc_and_di_pattern"},"headline":"Inversion of Control Containers and the Dependency Injection pattern","dateModified":"2018-12-19T10:00:00+09:00","datePublished":"2018-12-19T10:00:00+09:00","description":"이 글은 Martin Fowler의 Inversion of Control Containers and the Dependency Injection pattern을 요약 정리한 글입니다. Inversion of Control Containers and the Dependency Injection pattern 많은 오픈소스들은 J2EE 기술에 대한 대안을 구축하는 다양한 활동을 하고 있다. 이러한 활동은 J2EE의 복잡도를 획기적인 방법으로 낮추기 위함이다. 이들이 다루는 공통적인 이슈는 서로 다른 요소들을 어떻게 결합하는지에 대한 것이다. 이러한 문제를 해결하기 위해 많은 프레임워크들이 등장했고, 몇몇 프레임워크는 다른 레이어에 있는 요소(컴포넌트)들을 조합하는 방식을 제공한다. 이러한 방식은 Lightweight Container(경량화된 컨테이너)라고 불리운다. Component and Service 컴포넌트: 어플리케이션에서 사용될 목적으로 만들어진 소프트웨어 구성 요소이며, 컴포넌트는 컴포넌트 작성자가 허용하는 방식으로만 확장이 가능하다. 서비스: 컴포넌트와 비슷하지만, 외부 어플리케이션에서 사용한다는 점에서 차이를 보인다. 컴포넌트는 Jar, Assembly, DLL 등을 통해 제공되어 로컬에서 사용하며, 서비스는 웹서비스, 메시징 시스템, RPC, Socket 등의 원격 인터페이스를 통해 사용된다. A Naive Example 원본 글에서 아래와 같은 예제가 제공된다. class MovieLister{ public Movie[] moviesDirectedBy(String arg) { List allMovies = finder.findAll(); for(Iterator it = allMovies.iterator(); it.hasNext();) { Movie movie = (Movie)it.next(); if (!movie.getDirector().equals(arg)) it.remove(); } } return (Movie[])allMovies.toArray(new Movie[allMovies.size()]); } 영화 목록 중 인자로 주어진 값을 영화 감독으로 가지는 영화를 추출하여 반환하는 moviesDirectedBy 라는 메서드가 정의되어 있는 MovieLister라는 클래스를 제공하고 있다. 위 예제의 요점은 ‘MovieLister 객체와 Finder 객체를 연결하는 법‘이다. MovieLister 객체는 영화가 어떻게 저장되는지에 대해서는 전혀 관심이 없다. 단지 조건에 부합하는 영화를 moviesDirectedBy 메서드로 찾고 싶을 뿐이다. 즉, Finder 객체와의 의존성을 없애고 싶은 것이다. 이러한 문제를 해결하기 위해 Finder 객체를 아래와 같이 Interface로 정의하였다. public interface MovieFinder { List findAll(); } Finder를 Interface로 정의하므로써, Finder와 MovieLister 객체의 분리는 잘 된 것 같다. 그러나 아래와 같이 MovieLister 클래스의 생성자에서 Finder 객체를 상속한 ColonDelimitedMovieFinder 클래스의 객체를 명시적으로 할당해준다면 어떨까? class MovieLister { private MovieFinder finder; public MovieLister() { this.finder = new ColonDelimitedMovieFinder(&quot;movies1.txt&quot;); } } 코드의 작성자만 사용할 때는 문제가 없지만, 다른 사람이 위 클래스를 사용하게 된다면 ColonDelimitedMovieFinder 클래스의 생성자로 전달되는 “movies1.txt” 변경 불가 텍스트 파일이 아닌 XML 혹은 SQL 등에 영화 목록이 저장되어 있을 경우 사용 불가 와 같은 문제점에 부딪히게 된다. 위 그림에서와 같이 MovieLister가 MovieFinder Interface에 의존하지만, 동시에 이를 상속하는 Concrete Class인 MovieFinderImpl을 생성하므로써 둘 모두에 의존성이 생기게 된다. 즉, MovieFinder를 Interface로 만든 보람이 없어지게 된다. MovieLister와 MovieFinder를 제대로 Decouple 시키기 위해서는, 아래 MovieFinderImpl에 대한 의존성을 완전히 없애야 한다. 이러한 문제는 Plugin 패턴으로 해결할 수 있고, 이러한 Plugin을 어플리케이션에 조합해서 넣는 방법을 IoC를 사용하므로써 해결할 수 있다. Plugin 이란? Interface는 어플리케이션 코드가 서로 다른 구현을 필요로 하는 여러 런타임 환경에서 동작할 때 주로 사용된다. 개발자는 Interface를 적절히 구현하여 Factory Method에 제공(리턴)한다. 예를 들어 위 그림에서 DomainObject 객체가 Primiary Key를 생성해야 할 때, Unit Test 환경에서는 In-Memory Counter를 사용하고, Production 환경에서는 Database Managed Sequence를 사용해야 한다. 만일 IdGenerator를 제공하는 Factory Method를 직접 구현한다면, 조건문을 사용해서 실행 환경에 따라 일일이 다른 IdGenerator 구현체를 반환해야 할 것이다. 이러한 경우 실행 환경, 배포 환경 등이 바뀔 때마다 모든 Factory 의 조건문을 수정해야하는 상황이 발생할 수 있다. Plugin은 중앙화된 런타임 구성을 제공하므로써 이러한 문제를 해결한다. IoC(Inversion of Control) 위의 A Naive Exmple 에서 MovieLister 클래스는 MovieFinder를 상속한 구현체를 생성자에서 인스턴스화하였다. 이는 MovieFinder가 Plugin 화 될 수 없게 만든다. 이를 가능하게 하기 위해서는, 별도의 Assembly","@type":"BlogPosting","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->


  <!-- CSS -->
  <link rel="stylesheet" href="/assets/main.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">

  <!-- Favicon -->
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png">

  <!-- RSS -->
  <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="DevLog" />

  <!-- Google Analytics-->
  <script data-ad-client="ca-pub-8829030678254956" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
</head>


  <body>

    <nav class="nav">
  <div class="nav-container">
    <a href="/">
      <h2 class="nav-title">DevLog</h2>
    </a>
    <ul>
      <li><a href="/about">About</a></li>
      <li><a href="/">Posts</a></li>
      <li><a href="/tags">Tags</a></li>
    </ul>
  </div>
</nav>


    <main>
      <div class="post">
  <div class="post-info">
    <span>Written by</span>
    
        leeyh0216
    

    
      <br>
      <span>on&nbsp;</span><time datetime="2018-12-19 10:00:00 +0900">December 19, 2018</time>
    
    
    
      <br>
      <span>
      
        
        <a style="text-decoration: none;" href="/tag/spring"><code class="highligher-rouge"><nobr>spring</nobr></code>&nbsp;</a>
      
      </span>
    
  </span>
  </div>

  <h1 class="post-title">Inversion of Control Containers and the Dependency Injection pattern</h1>
  <div class="post-line"></div>

  <blockquote>
  <p>이 글은 Martin Fowler의 Inversion of Control Containers and the Dependency Injection pattern을 요약 정리한 글입니다.</p>
</blockquote>

<h1 id="inversion-of-control-containers-and-the-dependency-injection-pattern">Inversion of Control Containers and the Dependency Injection pattern</h1>

<p>많은 오픈소스들은 J2EE 기술에 대한 대안을 구축하는 다양한 활동을 하고 있다. 이러한 활동은 J2EE의 복잡도를 획기적인 방법으로 낮추기 위함이다.</p>

<p>이들이 다루는 공통적인 이슈는 서로 다른 요소들을 어떻게 결합하는지에 대한 것이다. 이러한 문제를 해결하기 위해 많은 프레임워크들이 등장했고, 몇몇 프레임워크는 다른 레이어에 있는 요소(컴포넌트)들을 조합하는 방식을 제공한다. 이러한 방식은 Lightweight Container(경량화된 컨테이너)라고 불리운다.</p>

<h2 id="component-and-service">Component and Service</h2>

<ul>
  <li>
    <p>컴포넌트: 어플리케이션에서 사용될 목적으로 만들어진 소프트웨어 구성 요소이며, 컴포넌트는 컴포넌트 작성자가 허용하는 방식으로만 확장이 가능하다.</p>
  </li>
  <li>
    <p>서비스: 컴포넌트와 비슷하지만, 외부 어플리케이션에서 사용한다는 점에서 차이를 보인다.</p>
  </li>
</ul>

<p>컴포넌트는 Jar, Assembly, DLL 등을 통해 제공되어 로컬에서 사용하며, 서비스는 웹서비스, 메시징 시스템, RPC, Socket 등의 원격 인터페이스를 통해 사용된다.</p>

<h1 id="a-naive-example">A Naive Example</h1>

<p>원본 글에서 아래와 같은 예제가 제공된다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">MovieLister</span><span class="o">{</span>

    <span class="kd">public</span> <span class="nc">Movie</span><span class="o">[]</span> <span class="nf">moviesDirectedBy</span><span class="o">(</span><span class="nc">String</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span> <span class="n">allMovies</span> <span class="o">=</span> <span class="n">finder</span><span class="o">.</span><span class="na">findAll</span><span class="o">();</span>
        <span class="k">for</span><span class="o">(</span><span class="nc">Iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">allMovies</span><span class="o">.</span><span class="na">iterator</span><span class="o">();</span> <span class="n">it</span><span class="o">.</span><span class="na">hasNext</span><span class="o">();)</span> <span class="o">{</span>
            <span class="nc">Movie</span> <span class="n">movie</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Movie</span><span class="o">)</span><span class="n">it</span><span class="o">.</span><span class="na">next</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">movie</span><span class="o">.</span><span class="na">getDirector</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="n">arg</span><span class="o">))</span> <span class="n">it</span><span class="o">.</span><span class="na">remove</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="o">(</span><span class="nc">Movie</span><span class="o">[])</span><span class="n">allMovies</span><span class="o">.</span><span class="na">toArray</span><span class="o">(</span><span class="k">new</span> <span class="nc">Movie</span><span class="o">[</span><span class="n">allMovies</span><span class="o">.</span><span class="na">size</span><span class="o">()]);</span>
<span class="o">}</span></code></pre></figure>

<p>영화 목록 중 인자로 주어진 값을 영화 감독으로 가지는 영화를 추출하여 반환하는 <code class="highlighter-rouge">moviesDirectedBy</code> 라는 메서드가 정의되어 있는 <code class="highlighter-rouge">MovieLister</code>라는 클래스를 제공하고 있다.</p>

<p>위 예제의 요점은 ‘<strong>MovieLister 객체와 Finder 객체를 연결하는 법</strong>‘이다. <code class="highlighter-rouge">MovieLister</code> 객체는 영화가 어떻게 저장되는지에 대해서는 전혀 관심이 없다. 단지 조건에 부합하는 영화를 <code class="highlighter-rouge">moviesDirectedBy</code> 메서드로 찾고 싶을 뿐이다. 즉, <code class="highlighter-rouge">Finder</code> 객체와의 의존성을 없애고 싶은 것이다.</p>

<p>이러한 문제를 해결하기 위해 <code class="highlighter-rouge">Finder</code> 객체를 아래와 같이 <code class="highlighter-rouge">Interface</code>로 정의하였다.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">MovieFinder</span> <span class="o">{</span>
    <span class="nc">List</span> <span class="nf">findAll</span><span class="o">();</span>
<span class="o">}</span></code></pre></figure>

<p><code class="highlighter-rouge">Finder</code>를 Interface로 정의하므로써, <code class="highlighter-rouge">Finder</code>와 <code class="highlighter-rouge">MovieLister</code> 객체의 분리는 잘 된 것 같다. 그러나 아래와 같이 <code class="highlighter-rouge">MovieLister</code> 클래스의 생성자에서 <code class="highlighter-rouge">Finder</code> 객체를 상속한 <code class="highlighter-rouge">ColonDelimitedMovieFinder</code> 클래스의 객체를 명시적으로 할당해준다면 어떨까?</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nc">MovieLister</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">MovieFinder</span> <span class="n">finder</span><span class="o">;</span>
    <span class="kd">public</span> <span class="nf">MovieLister</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">finder</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ColonDelimitedMovieFinder</span><span class="o">(</span><span class="s">"movies1.txt"</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span></code></pre></figure>

<p>코드의 작성자만 사용할 때는 문제가 없지만, 다른 사람이 위 클래스를 사용하게 된다면</p>

<ul>
  <li>ColonDelimitedMovieFinder 클래스의 생성자로 전달되는 “movies1.txt” 변경 불가</li>
  <li>텍스트 파일이 아닌 XML 혹은 SQL 등에 영화 목록이 저장되어 있을 경우 사용 불가</li>
</ul>

<p>와 같은 문제점에 부딪히게 된다.</p>

<p><img src="/assets/spring/both_dependency.jpeg" alt="Dependency Issue" /></p>

<p>위 그림에서와 같이 <code class="highlighter-rouge">MovieLister</code>가 <code class="highlighter-rouge">MovieFinder</code> Interface에 의존하지만, 동시에 이를 상속하는 Concrete Class인 <code class="highlighter-rouge">MovieFinderImpl</code>을 생성하므로써 둘 모두에 의존성이 생기게 된다. 즉, <code class="highlighter-rouge">MovieFinder</code>를 Interface로 만든 보람이 없어지게 된다. <code class="highlighter-rouge">MovieLister</code>와 <code class="highlighter-rouge">MovieFinder</code>를 제대로 Decouple 시키기 위해서는, 아래 <code class="highlighter-rouge">MovieFinderImpl</code>에 대한 의존성을 완전히 없애야 한다.</p>

<p>이러한 문제는 Plugin 패턴으로 해결할 수 있고, 이러한 Plugin을 어플리케이션에 조합해서 넣는 방법을 IoC를 사용하므로써 해결할 수 있다.</p>

<h3 id="plugin-이란">Plugin 이란?</h3>

<p><img src="/assets/spring/plugin.jpg" alt="Plugin" /></p>

<p>Interface는 어플리케이션 코드가 서로 다른 구현을 필요로 하는 여러 런타임 환경에서 동작할 때 주로 사용된다. 개발자는 Interface를 적절히 구현하여 Factory Method에 제공(리턴)한다.</p>

<p>예를 들어 위 그림에서 DomainObject 객체가 Primiary Key를 생성해야 할 때, Unit Test 환경에서는 In-Memory Counter를 사용하고, Production 환경에서는 Database Managed Sequence를 사용해야 한다.</p>

<p>만일 IdGenerator를 제공하는 Factory Method를 직접 구현한다면, 조건문을 사용해서 실행 환경에 따라 일일이 다른 IdGenerator 구현체를 반환해야 할 것이다. 이러한 경우 실행 환경, 배포 환경 등이 바뀔 때마다 모든 Factory 의 조건문을 수정해야하는 상황이 발생할 수 있다.</p>

<p>Plugin은 중앙화된 런타임 구성을 제공하므로써 이러한 문제를 해결한다.</p>

<h2 id="iocinversion-of-control">IoC(Inversion of Control)</h2>

<p>위의 A Naive Exmple 에서 <code class="highlighter-rouge">MovieLister</code> 클래스는 <code class="highlighter-rouge">MovieFinder</code>를 상속한 구현체를 생성자에서 인스턴스화하였다. 이는 <code class="highlighter-rouge">MovieFinder</code>가 Plugin 화 될 수 없게 만든다. 이를 가능하게 하기 위해서는, 별도의 Assembly</p>


</div>

<div class="pagination">
  
    <a href="/2018-12-23/spring-core-4" class="left arrow">&#8592;</a>
  
  
    <a href="/2018-12-03/spring-core-3" class="right arrow">&#8594;</a>
  

  <a href="#" class="top">Top</a>
</div>

    </main>

    <footer>
  <span>
    &copy; <time datetime="2019-11-05 21:14:23 +0900">2019</time> leeyh0216. Made with Jekyll using the <a href="https://github.com/chesterhow/tale/">Tale</a> theme.
  </span>
</footer>

  </body>
</html>
